<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>[PATCH v2 00/53] object_id part 8</title><link rel="alternate" title="Atom feed" href="http://hjrcffqmbrq6wope.onion/git/new.atom" type="application/atom+xml"><style>pre{white-space:pre-wrap}</style></head><body><form action="../../"><pre><b>git@vger.kernel.org mailing list mirror (one of many)</b>
<input name="q" type="text"><input value="search" type="submit"> <a href="http://hjrcffqmbrq6wope.onion/git/_/text/help">help</a> / <a href="http://hjrcffqmbrq6wope.onion/git/new.atom">Atom feed</a></pre></form><pre><a href="#ed30e3cf6335ffd783b9c23ba587ff7a405153480" id="md30e3cf6335ffd783b9c23ba587ff7a405153480">*</a> <b>[PATCH v2 00/53] object_id part 8</b>
<b>@ 2017-05-01  2:28 brian m. carlson</b>
  2017-05-01  2:28 ` <a href="#m2dca3826d10f379ac5b197846b5d57e93318cfa1">[PATCH v2 03/53] Convert struct cache_tree to use struct object_id</a> brian m. carlson
                   ` <a href="#r2dca3826d10f379ac5b197846b5d57e93318cfa1">(50 more replies)</a>
  <a href="#rd30e3cf6335ffd783b9c23ba587ff7a405153480">0 siblings, 51 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:28 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is the eighth series of patches to convert unsigned char [20] to
struct object_id.  This series converts lookup_commit, lookup_blob,
lookup_tree, lookup_tag, and finally parse_object to struct object_id.

A small number of functions have temporaries inserted during the
conversion in order to allow conversion of functions that still need to
take unsigned char *; they are removed either later in the series or
will be in a future series.

This series can be fetched from the object-id-part8 branch from either
of the follwing:

<a href="https://github.com/bk2204/git">https://github.com/bk2204/git</a>
<a href="https://git.crustytoothpaste.net/git/bmc/git.git">https://git.crustytoothpaste.net/git/bmc/git.git</a>

Changes from v1:
* Rebase on master.  This led to a conflict with the ref-cache changes in patch
  39.  Extra-careful review here would be welcome.
* Undo the needless line rewrapping.
* Fix the commit message typo.
* Use GIT_MAX_RAWSZ instead of struct object_id for the pack checksum.

brian m. carlson (53):
  fetch-pack: convert to struct object_id
  Clean up outstanding object_id transforms.
  Convert struct cache_tree to use struct object_id
  builtin/name-rev: convert to struct object_id
  builtin/prune: convert to struct object_id
  bundle: convert to struct object_id
  branch: convert to struct object_id
  builtin/blame: convert static function to struct object_id
  builtin/rev-parse: convert to struct object_id
  fast-import: convert internal structs to struct object_id
  fast-import: convert to struct object_id
  submodule: convert merge_submodule to use struct object_id
  notes-cache: convert to struct object_id
  parse-options-cb: convert to struct object_id
  reflog_expire: convert to struct object_id
  builtin/verify-commit: convert to struct object_id
  tag: convert parse_tag_buffer to struct object_id
  http-push: convert some static functions to struct object_id
  notes-utils: convert internals to struct object_id
  revision: convert prepare_show_merge to struct object_id
  shallow: convert shallow registration functions to object_id
  sequencer: convert some functions to struct object_id
  builtin/tag: convert to struct object_id
  Convert remaining callers of lookup_commit_reference* to object_id
  Convert lookup_commit* to struct object_id
  pack: convert struct pack_idx_entry to struct object_id
  builtin/unpack-objects: convert to struct object_id
  Convert remaining callers of lookup_blob to object_id
  Convert lookup_blob to struct object_id
  tree: convert read_tree_1 to use struct object_id internally
  builtin/reflog: convert tree_is_complete to take struct object_id
  Convert lookup_tree to struct object_id
  log-tree: convert to struct object_id
  Convert lookup_tag to struct object_id
  Convert the verify_pack callback to struct object_id
  Convert struct ref_array_item to struct object_id
  ref-filter: convert some static functions to struct object_id
  refs: convert struct ref_update to use struct object_id
  refs/files-backend: convert many internals to struct object_id
  http-push: convert process_ls_object and descendants to object_id
  revision: rename add_pending_sha1 to add_pending_oid
  revision: convert remaining parse_object callers to object_id
  upload-pack: convert remaining parse_object callers to object_id
  sha1_name: convert internals of peel_onion to object_id
  builtin/read-tree: convert to struct object_id
  builtin/ls-files: convert overlay_tree_on_cache to object_id
  sequencer: convert fast_forward_to to struct object_id
  merge: convert checkout_fast_forward to struct object_id
  builtin/ls-tree: convert to struct object_id
  diff-lib: convert do_diff_cache to struct object_id
  sequencer: convert do_recursive_merge to struct object_id
  tree: convert parse_tree_indirect to struct object_id
  object: convert parse_object* to take struct object_id

 archive.c                       |   6 +-
 bisect.c                        |   2 +-
 blob.c                          |   6 +-
 blob.h                          |   2 +-
 branch.c                        |  16 +-
 builtin/am.c                    |  18 +-
 builtin/blame.c                 |  14 +-
 builtin/branch.c                |   6 +-
 builtin/checkout.c              |  18 +-
 builtin/clone.c                 |   4 +-
 builtin/commit-tree.c           |   2 +-
 builtin/commit.c                |   8 +-
 builtin/describe.c              |  10 +-
 builtin/diff-tree.c             |   8 +-
 builtin/diff.c                  |   6 +-
 builtin/fast-export.c           |   8 +-
 builtin/fetch.c                 |   7 +-
 builtin/fmt-merge-msg.c         |   8 +-
 builtin/fsck.c                  |  16 +-
 builtin/grep.c                  |   2 +-
 builtin/index-pack.c            |  56 ++---
 builtin/log.c                   |  10 +-
 builtin/ls-files.c              |   6 +-
 builtin/ls-tree.c               |   6 +-
 builtin/merge-base.c            |   6 +-
 builtin/merge-tree.c            |  10 +-
 builtin/merge.c                 |  12 +-
 builtin/name-rev.c              |  32 +--
 builtin/notes.c                 |   2 +-
 builtin/pack-objects.c          |  71 ++++---
 builtin/prune.c                 |   7 +-
 builtin/pull.c                  |  14 +-
 builtin/read-tree.c             |  10 +-
 builtin/receive-pack.c          |   8 +-
 builtin/reflog.c                |  36 ++--
 builtin/replace.c               |   6 +-
 builtin/reset.c                 |  10 +-
 builtin/rev-list.c              |   2 +-
 builtin/rev-parse.c             |  56 ++---
 builtin/show-branch.c           |   4 +-
 builtin/tag.c                   |  66 +++---
 builtin/unpack-objects.c        |  65 +++---
 builtin/verify-commit.c         |  12 +-
 bulk-checkin.c                  |   4 +-
 bundle.c                        |  39 ++--
 bundle.h                        |   4 +-
 cache-tree.c                    |  33 +--
 cache-tree.h                    |   3 +-
 cache.h                         |   4 +-
 commit.c                        |  38 ++--
 commit.h                        |  16 +-
 diff-lib.c                      |  12 +-
 diff.c                          |   4 +-
 diff.h                          |   2 +-
 fast-import.c                   | 443 ++++++++++++++++++++--------------------
 fetch-pack.c                    |  97 ++++-----
 fsck.c                          |   6 +-
 http-backend.c                  |   2 +-
 http-push.c                     |  55 ++---
 list-objects.c                  |   4 +-
 log-tree.c                      |  26 +--
 merge-recursive.c               |  16 +-
 merge.c                         |   4 +-
 notes-cache.c                   |  29 ++-
 notes-cache.h                   |   4 +-
 notes-merge.c                   |  26 +--
 notes-utils.c                   |  18 +-
 object.c                        |  38 ++--
 object.h                        |   8 +-
 pack-bitmap-write.c             |   8 +-
 pack-bitmap.c                   |   4 +-
 pack-check.c                    |  25 ++-
 pack-objects.c                  |   8 +-
 pack-write.c                    |  10 +-
 pack.h                          |   4 +-
 parse-options-cb.c              |   6 +-
 pretty.c                        |   2 +-
 reachable.c                     |   8 +-
 ref-filter.c                    |  38 ++--
 ref-filter.h                    |   2 +-
 reflog-walk.c                   |   6 +-
 refs.c                          |   4 +-
 refs.h                          |   6 +-
 refs/files-backend.c            | 155 +++++++-------
 refs/ref-cache.c                |   4 +-
 refs/ref-cache.h                |   2 +-
 refs/refs-internal.h            |   4 +-
 remote.c                        |  17 +-
 revision.c                      |  76 +++----
 revision.h                      |   6 +-
 sequencer.c                     |  59 +++---
 server-info.c                   |   2 +-
 sha1_name.c                     |  38 ++--
 shallow.c                       |  34 +--
 submodule.c                     |  32 +--
 submodule.h                     |   8 +-
 t/helper/test-dump-cache-tree.c |   4 +-
 t/helper/test-match-trees.c     |   4 +-
 tag.c                           |  25 ++-
 tag.h                           |   2 +-
 transport.c                     |   2 +-
 tree.c                          |  22 +-
 tree.h                          |   4 +-
 upload-pack.c                   |  60 +++---
 walker.c                        |   8 +-
 wt-status.c                     |   2 +-
 106 files changed, 1174 insertions(+), 1136 deletions(-)


<a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480" id="ed30e3cf6335ffd783b9c23ba587ff7a405153480">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-1-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rd30e3cf6335ffd783b9c23ba587ff7a405153480">52+ messages in thread</a></pre><hr><pre><a href="#e2dca3826d10f379ac5b197846b5d57e93318cfa1" id="m2dca3826d10f379ac5b197846b5d57e93318cfa1">*</a> <b>[PATCH v2 03/53] Convert struct cache_tree to use struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
<b>@ 2017-05-01  2:28 ` brian m. carlson</b>
  2017-05-01  2:28 ` <a href="#m1c64f91280af1ea8ed7b70c97a7609da8cd48da1">[PATCH v2 04/53] builtin/name-rev: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r1c64f91280af1ea8ed7b70c97a7609da8cd48da1">(49 subsequent siblings)</a>
  <a href="#r2dca3826d10f379ac5b197846b5d57e93318cfa1">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:28 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the sha1 member of struct cache_tree to struct object_id by
changing the definition and applying the following semantic patch, plus
the standard object_id transforms:

@@
struct cache_tree E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct cache_tree *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

Fix up one reference to active_cache_tree which was not automatically
caught by Coccinelle.  These changes are prerequisites for converting
parse_object.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/commit.c                |  2 +-
 builtin/fsck.c                  |  4 ++--
 cache-tree.c                    | 31 ++++++++++++++++---------------
 cache-tree.h                    |  3 ++-
 merge-recursive.c               |  2 +-
 revision.c                      |  2 +-
 sequencer.c                     |  3 ++-
 t/helper/test-dump-cache-tree.c |  4 ++--
 8 files changed, 27 insertions(+), 24 deletions(-)

diff --git a/builtin/commit.c b/builtin/commit.c
index 1d805f5da..8685c888f 100644
--- a/builtin/commit.c
+++ b/builtin/commit.c
@@ -1758,7 +1758,7 @@ int cmd_commit(int argc, const char **argv, const char *prefix)
 		append_merge_tag_headers(parents, &amp;tail);
 	}
 
-	if (commit_tree_extended(sb.buf, sb.len, active_cache_tree-&gt;sha1,
+	if (commit_tree_extended(sb.buf, sb.len, active_cache_tree-&gt;oid.hash,
 			 parents, oid.hash, author_ident.buf, sign_commit, extra)) {
 		rollback_index_files();
 		die(_("failed to write commit object"));
diff --git a/builtin/fsck.c b/builtin/fsck.c
index b5e13a455..c40e14de6 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
@@ -599,10 +599,10 @@ static int fsck_cache_tree(struct cache_tree *it)
 		fprintf(stderr, "Checking cache tree\n");
 
 	if (0 &lt;= it-&gt;entry_count) {
-		struct object *obj = parse_object(it-&gt;sha1);
+		struct object *obj = parse_object(it-&gt;oid.hash);
 		if (!obj) {
 			error("%s: invalid sha1 pointer in cache-tree",
-			      sha1_to_hex(it-&gt;sha1));
+			      oid_to_hex(&amp;it-&gt;oid));
 			errors_found |= ERROR_REFS;
 			return 1;
 		}
diff --git a/cache-tree.c b/cache-tree.c
index 345ea3596..35d507ed7 100644
--- a/cache-tree.c
+++ b/cache-tree.c
@@ -225,7 +225,7 @@ int cache_tree_fully_valid(struct cache_tree *it)
 	int i;
 	if (!it)
 		return 0;
-	if (it-&gt;entry_count &lt; 0 || !has_sha1_file(it-&gt;sha1))
+	if (it-&gt;entry_count &lt; 0 || !has_sha1_file(it-&gt;oid.hash))
 		return 0;
 	for (i = 0; i &lt; it-&gt;subtree_nr; i++) {
 		if (!cache_tree_fully_valid(it-&gt;down[i]-&gt;cache_tree))
@@ -253,7 +253,7 @@ static int update_one(struct cache_tree *it,
 
 	*skip_count = 0;
 
-	if (0 &lt;= it-&gt;entry_count &amp;&amp; has_sha1_file(it-&gt;sha1))
+	if (0 &lt;= it-&gt;entry_count &amp;&amp; has_sha1_file(it-&gt;oid.hash))
 		return it-&gt;entry_count;
 
 	/*
@@ -340,7 +340,7 @@ static int update_one(struct cache_tree *it,
 				die("cache-tree.c: '%.*s' in '%s' not found",
 				    entlen, path + baselen, path);
 			i += sub-&gt;count;
-			sha1 = sub-&gt;cache_tree-&gt;sha1;
+			sha1 = sub-&gt;cache_tree-&gt;oid.hash;
 			mode = S_IFDIR;
 			contains_ita = sub-&gt;cache_tree-&gt;entry_count &lt; 0;
 			if (contains_ita) {
@@ -402,12 +402,13 @@ static int update_one(struct cache_tree *it,
 		unsigned char sha1[20];
 		hash_sha1_file(buffer.buf, buffer.len, tree_type, sha1);
 		if (has_sha1_file(sha1))
-			hashcpy(it-&gt;sha1, sha1);
+			hashcpy(it-&gt;oid.hash, sha1);
 		else
 			to_invalidate = 1;
 	} else if (dryrun)
-		hash_sha1_file(buffer.buf, buffer.len, tree_type, it-&gt;sha1);
-	else if (write_sha1_file(buffer.buf, buffer.len, tree_type, it-&gt;sha1)) {
+		hash_sha1_file(buffer.buf, buffer.len, tree_type,
+			       it-&gt;oid.hash);
+	else if (write_sha1_file(buffer.buf, buffer.len, tree_type, it-&gt;oid.hash)) {
 		strbuf_release(&amp;buffer);
 		return -1;
 	}
@@ -417,7 +418,7 @@ static int update_one(struct cache_tree *it,
 #if DEBUG
 	fprintf(stderr, "cache-tree update-one (%d ent, %d subtree) %s\n",
 		it-&gt;entry_count, it-&gt;subtree_nr,
-		sha1_to_hex(it-&gt;sha1));
+		oid_to_hex(&amp;it-&gt;oid));
 #endif
 	return i;
 }
@@ -457,14 +458,14 @@ static void write_one(struct strbuf *buffer, struct cache_tree *it,
 	if (0 &lt;= it-&gt;entry_count)
 		fprintf(stderr, "cache-tree &lt;%.*s&gt; (%d ent, %d subtree) %s\n",
 			pathlen, path, it-&gt;entry_count, it-&gt;subtree_nr,
-			sha1_to_hex(it-&gt;sha1));
+			oid_to_hex(&amp;it-&gt;oid));
 	else
 		fprintf(stderr, "cache-tree &lt;%.*s&gt; (%d subtree) invalid\n",
 			pathlen, path, it-&gt;subtree_nr);
 #endif
 
 	if (0 &lt;= it-&gt;entry_count) {
-		strbuf_add(buffer, it-&gt;sha1, 20);
+		strbuf_add(buffer, it-&gt;oid.hash, 20);
 	}
 	for (i = 0; i &lt; it-&gt;subtree_nr; i++) {
 		struct cache_tree_sub *down = it-&gt;down[i];
@@ -521,7 +522,7 @@ static struct cache_tree *read_one(const char **buffer, unsigned long *size_p)
 	if (0 &lt;= it-&gt;entry_count) {
 		if (size &lt; 20)
 			goto free_return;
-		hashcpy(it-&gt;sha1, (const unsigned char*)buf);
+		hashcpy(it-&gt;oid.hash, (const unsigned char*)buf);
 		buf += 20;
 		size -= 20;
 	}
@@ -530,7 +531,7 @@ static struct cache_tree *read_one(const char **buffer, unsigned long *size_p)
 	if (0 &lt;= it-&gt;entry_count)
 		fprintf(stderr, "cache-tree &lt;%s&gt; (%d ent, %d subtree) %s\n",
 			*buffer, it-&gt;entry_count, subtree_nr,
-			sha1_to_hex(it-&gt;sha1));
+			oid_to_hex(&amp;it-&gt;oid));
 	else
 		fprintf(stderr, "cache-tree &lt;%s&gt; (%d subtrees) invalid\n",
 			*buffer, subtree_nr);
@@ -641,10 +642,10 @@ int write_index_as_tree(unsigned char *sha1, struct index_state *index_state, co
 		subtree = cache_tree_find(index_state-&gt;cache_tree, prefix);
 		if (!subtree)
 			return WRITE_TREE_PREFIX_ERROR;
-		hashcpy(sha1, subtree-&gt;sha1);
+		hashcpy(sha1, subtree-&gt;oid.hash);
 	}
 	else
-		hashcpy(sha1, index_state-&gt;cache_tree-&gt;sha1);
+		hashcpy(sha1, index_state-&gt;cache_tree-&gt;oid.hash);
 
 	if (0 &lt;= newfd)
 		rollback_lock_file(lock_file);
@@ -663,7 +664,7 @@ static void prime_cache_tree_rec(struct cache_tree *it, struct tree *tree)
 	struct name_entry entry;
 	int cnt;
 
-	hashcpy(it-&gt;sha1, tree-&gt;object.oid.hash);
+	oidcpy(&amp;it-&gt;oid, &amp;tree-&gt;object.oid);
 	init_tree_desc(&amp;desc, tree-&gt;buffer, tree-&gt;size);
 	cnt = 0;
 	while (tree_entry(&amp;desc, &amp;entry)) {
@@ -718,7 +719,7 @@ int cache_tree_matches_traversal(struct cache_tree *root,
 
 	it = find_cache_tree_from_traversal(root, info);
 	it = cache_tree_find(it, ent-&gt;path);
-	if (it &amp;&amp; it-&gt;entry_count &gt; 0 &amp;&amp; !hashcmp(ent-&gt;oid-&gt;hash, it-&gt;sha1))
+	if (it &amp;&amp; it-&gt;entry_count &gt; 0 &amp;&amp; !oidcmp(ent-&gt;oid, &amp;it-&gt;oid))
 		return it-&gt;entry_count;
 	return 0;
 }
diff --git a/cache-tree.h b/cache-tree.h
index 41c574663..f7b9cab7e 100644
--- a/cache-tree.h
+++ b/cache-tree.h
@@ -1,6 +1,7 @@
 #ifndef CACHE_TREE_H
 #define CACHE_TREE_H
 
+#include "cache.h"
 #include "tree.h"
 #include "tree-walk.h"
 
@@ -15,7 +16,7 @@ struct cache_tree_sub {
 
 struct cache_tree {
 	int entry_count; /* negative means "invalid" */
-	unsigned char sha1[20];
+	struct object_id oid;
 	int subtree_nr;
 	int subtree_alloc;
 	struct cache_tree_sub **down;
diff --git a/merge-recursive.c b/merge-recursive.c
index 62decd51c..9d6fd577e 100644
--- a/merge-recursive.c
+++ b/merge-recursive.c
@@ -304,7 +304,7 @@ struct tree *write_tree_from_memory(struct merge_options *o)
 		return NULL;
 	}
 
-	result = lookup_tree(active_cache_tree-&gt;sha1);
+	result = lookup_tree(active_cache_tree-&gt;oid.hash);
 
 	return result;
 }
diff --git a/revision.c b/revision.c
index 7ff61ff5f..2b56c3baf 100644
--- a/revision.c
+++ b/revision.c
@@ -1249,7 +1249,7 @@ static void add_cache_tree(struct cache_tree *it, struct rev_info *revs,
 	int i;
 
 	if (it-&gt;entry_count &gt;= 0) {
-		struct tree *tree = lookup_tree(it-&gt;sha1);
+		struct tree *tree = lookup_tree(it-&gt;oid.hash);
 		add_pending_object_with_path(revs, &amp;tree-&gt;object, "",
 					     040000, path-&gt;buf);
 	}
diff --git a/sequencer.c b/sequencer.c
index 130cc868e..d119baa51 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -508,7 +508,8 @@ static int is_index_unchanged(void)
 		if (cache_tree_update(&amp;the_index, 0))
 			return error(_("unable to update cache tree\n"));
 
-	return !hashcmp(active_cache_tree-&gt;sha1, head_commit-&gt;tree-&gt;object.oid.hash);
+	return !oidcmp(&amp;active_cache_tree-&gt;oid,
+		       &amp;head_commit-&gt;tree-&gt;object.oid);
 }
 
 static int write_author_script(const char *message)
diff --git a/t/helper/test-dump-cache-tree.c b/t/helper/test-dump-cache-tree.c
index 7af116d49..ebf3aab22 100644
--- a/t/helper/test-dump-cache-tree.c
+++ b/t/helper/test-dump-cache-tree.c
@@ -10,7 +10,7 @@ static void dump_one(struct cache_tree *it, const char *pfx, const char *x)
 		       "invalid", x, pfx, it-&gt;subtree_nr);
 	else
 		printf("%s %s%s (%d entries, %d subtrees)\n",
-		       sha1_to_hex(it-&gt;sha1), x, pfx,
+		       oid_to_hex(&amp;it-&gt;oid), x, pfx,
 		       it-&gt;entry_count, it-&gt;subtree_nr);
 }
 
@@ -32,7 +32,7 @@ static int dump_cache_tree(struct cache_tree *it,
 	}
 	else {
 		dump_one(it, pfx, "");
-		if (hashcmp(it-&gt;sha1, ref-&gt;sha1) ||
+		if (oidcmp(&amp;it-&gt;oid, &amp;ref-&gt;oid) ||
 		    ref-&gt;entry_count != it-&gt;entry_count ||
 		    ref-&gt;subtree_nr != it-&gt;subtree_nr) {
 			/* claims to be valid but is lying */

<a href="#m2dca3826d10f379ac5b197846b5d57e93318cfa1" id="e2dca3826d10f379ac5b197846b5d57e93318cfa1">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-4-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r2dca3826d10f379ac5b197846b5d57e93318cfa1">52+ messages in thread</a></pre><hr><pre><a href="#e1c64f91280af1ea8ed7b70c97a7609da8cd48da1" id="m1c64f91280af1ea8ed7b70c97a7609da8cd48da1">*</a> <b>[PATCH v2 04/53] builtin/name-rev: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
  2017-05-01  2:28 ` <a href="#m2dca3826d10f379ac5b197846b5d57e93318cfa1">[PATCH v2 03/53] Convert struct cache_tree to use struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:28 ` brian m. carlson</b>
  2017-05-01  2:28 ` <a href="#mc36a40b25b4c0081342f0b7715549e0aa08f046e">[PATCH v2 05/53] builtin/prune: convert to struct object_id</a> brian m. carlson
                   ` <a href="#rc36a40b25b4c0081342f0b7715549e0aa08f046e">(48 subsequent siblings)</a>
  <a href="#r1c64f91280af1ea8ed7b70c97a7609da8cd48da1">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:28 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert all the uses of unsigned char [20] to struct object_id.  Also,
convert some hard-coded integers into constants.

name_rev_line accepts a wide variety of free-form input and only
interprets 40-character hex values, passing through everything else.
Consequently, it is not a good candidate for parse_oid_hex, which is
much stricter.

This change is a prerequisite for converting parse_object.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/name-rev.c | 28 ++++++++++++++--------------
 1 file changed, 14 insertions(+), 14 deletions(-)

diff --git a/builtin/name-rev.c b/builtin/name-rev.c
index 92a5d8a5d..00760ecc6 100644
--- a/builtin/name-rev.c
+++ b/builtin/name-rev.c
@@ -114,7 +114,7 @@ struct name_ref_data {
 
 static struct tip_table {
 	struct tip_table_entry {
-		unsigned char sha1[20];
+		struct object_id oid;
 		const char *refname;
 	} *table;
 	int nr;
@@ -122,13 +122,13 @@ static struct tip_table {
 	int sorted;
 } tip_table;
 
-static void add_to_tip_table(const unsigned char *sha1, const char *refname,
+static void add_to_tip_table(const struct object_id *oid, const char *refname,
 			     int shorten_unambiguous)
 {
 	refname = name_ref_abbrev(refname, shorten_unambiguous);
 
 	ALLOC_GROW(tip_table.table, tip_table.nr + 1, tip_table.alloc);
-	hashcpy(tip_table.table[tip_table.nr].sha1, sha1);
+	oidcpy(&amp;tip_table.table[tip_table.nr].oid, oid);
 	tip_table.table[tip_table.nr].refname = xstrdup(refname);
 	tip_table.nr++;
 	tip_table.sorted = 0;
@@ -137,7 +137,7 @@ static void add_to_tip_table(const unsigned char *sha1, const char *refname,
 static int tipcmp(const void *a_, const void *b_)
 {
 	const struct tip_table_entry *a = a_, *b = b_;
-	return hashcmp(a-&gt;sha1, b-&gt;sha1);
+	return oidcmp(&amp;a-&gt;oid, &amp;b-&gt;oid);
 }
 
 static int name_ref(const char *path, const struct object_id *oid, int flags, void *cb_data)
@@ -194,7 +194,7 @@ static int name_ref(const char *path, const struct object_id *oid, int flags, vo
 			return 0;
 	}
 
-	add_to_tip_table(oid-&gt;hash, path, can_abbreviate_output);
+	add_to_tip_table(oid, path, can_abbreviate_output);
 
 	while (o &amp;&amp; o-&gt;type == OBJ_TAG) {
 		struct tag *t = (struct tag *) o;
@@ -216,7 +216,7 @@ static int name_ref(const char *path, const struct object_id *oid, int flags, vo
 static const unsigned char *nth_tip_table_ent(size_t ix, void *table_)
 {
 	struct tip_table_entry *table = table_;
-	return table[ix].sha1;
+	return table[ix].oid.hash;
 }
 
 static const char *get_exact_ref_match(const struct object *o)
@@ -301,9 +301,9 @@ static void name_rev_line(char *p, struct name_ref_data *data)
 #define ishex(x) (isdigit((x)) || ((x) &gt;= 'a' &amp;&amp; (x) &lt;= 'f'))
 		if (!ishex(*p))
 			forty = 0;
-		else if (++forty == 40 &amp;&amp;
+		else if (++forty == GIT_SHA1_HEXSZ &amp;&amp;
 			 !ishex(*(p+1))) {
-			unsigned char sha1[40];
+			struct object_id oid;
 			const char *name = NULL;
 			char c = *(p+1);
 			int p_len = p - p_start + 1;
@@ -311,9 +311,9 @@ static void name_rev_line(char *p, struct name_ref_data *data)
 			forty = 0;
 
 			*(p+1) = 0;
-			if (!get_sha1(p - 39, sha1)) {
+			if (!get_oid(p - (GIT_SHA1_HEXSZ - 1), &amp;oid)) {
 				struct object *o =
-					lookup_object(sha1);
+					lookup_object(oid.hash);
 				if (o)
 					name = get_rev_name(o, &amp;buf);
 			}
@@ -323,7 +323,7 @@ static void name_rev_line(char *p, struct name_ref_data *data)
 				continue;
 
 			if (data-&gt;name_only)
-				printf("%.*s%s", p_len - 40, p_start, name);
+				printf("%.*s%s", p_len - GIT_SHA1_HEXSZ, p_start, name);
 			else
 				printf("%.*s (%s)", p_len, p_start, name);
 			p_start = p + 1;
@@ -374,18 +374,18 @@ int cmd_name_rev(int argc, const char **argv, const char *prefix)
 		cutoff = 0;
 
 	for (; argc; argc--, argv++) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		struct object *object;
 		struct commit *commit;
 
-		if (get_sha1(*argv, sha1)) {
+		if (get_oid(*argv, &amp;oid)) {
 			fprintf(stderr, "Could not get sha1 for %s. Skipping.\n",
 					*argv);
 			continue;
 		}
 
 		commit = NULL;
-		object = parse_object(sha1);
+		object = parse_object(oid.hash);
 		if (object) {
 			struct object *peeled = deref_tag(object, *argv, 0);
 			if (peeled &amp;&amp; peeled-&gt;type == OBJ_COMMIT)

<a href="#m1c64f91280af1ea8ed7b70c97a7609da8cd48da1" id="e1c64f91280af1ea8ed7b70c97a7609da8cd48da1">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-5-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r1c64f91280af1ea8ed7b70c97a7609da8cd48da1">52+ messages in thread</a></pre><hr><pre><a href="#ec36a40b25b4c0081342f0b7715549e0aa08f046e" id="mc36a40b25b4c0081342f0b7715549e0aa08f046e">*</a> <b>[PATCH v2 05/53] builtin/prune: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
  2017-05-01  2:28 ` <a href="#m2dca3826d10f379ac5b197846b5d57e93318cfa1">[PATCH v2 03/53] Convert struct cache_tree to use struct object_id</a> brian m. carlson
  2017-05-01  2:28 ` <a href="#m1c64f91280af1ea8ed7b70c97a7609da8cd48da1">[PATCH v2 04/53] builtin/name-rev: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:28 ` brian m. carlson</b>
  2017-05-01  2:28 ` <a href="#m502cedc8f4fe38d0aea50d12e0589b397f603796">[PATCH v2 06/53] bundle: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r502cedc8f4fe38d0aea50d12e0589b397f603796">(47 subsequent siblings)</a>
  <a href="#rc36a40b25b4c0081342f0b7715549e0aa08f046e">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:28 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the sole instance of unsigned char [20] to struct object_id.
cmd_prune is a caller of parse_object, which we will convert later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/prune.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/builtin/prune.c b/builtin/prune.c
index 42633e0c6..96dca7d58 100644
--- a/builtin/prune.c
+++ b/builtin/prune.c
@@ -123,11 +123,11 @@ int cmd_prune(int argc, const char **argv, const char *prefix)
 		die(_("cannot prune in a precious-objects repo"));
 
 	while (argc--) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		const char *name = *argv++;
 
-		if (!get_sha1(name, sha1)) {
-			struct object *object = parse_object_or_die(sha1, name);
+		if (!get_oid(name, &amp;oid)) {
+			struct object *object = parse_object_or_die(oid.hash, name);
 			add_pending_object(&amp;revs, object, "");
 		}
 		else

<a href="#mc36a40b25b4c0081342f0b7715549e0aa08f046e" id="ec36a40b25b4c0081342f0b7715549e0aa08f046e">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-6-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc36a40b25b4c0081342f0b7715549e0aa08f046e">52+ messages in thread</a></pre><hr><pre><a href="#e502cedc8f4fe38d0aea50d12e0589b397f603796" id="m502cedc8f4fe38d0aea50d12e0589b397f603796">*</a> <b>[PATCH v2 06/53] bundle: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc36a40b25b4c0081342f0b7715549e0aa08f046e">(2 preceding siblings ...)</a>
  2017-05-01  2:28 ` <a href="#mc36a40b25b4c0081342f0b7715549e0aa08f046e">[PATCH v2 05/53] builtin/prune: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:28 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">[PATCH v2 07/53] branch: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">(46 subsequent siblings)</a>
  <a href="#r502cedc8f4fe38d0aea50d12e0589b397f603796">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:28 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the bundle code, plus the sole external user of struct
ref_list_entry, to use struct object_id.  Include cache.h from within
bundle.h to provide the definition.  Convert some of the hash parsing
code to use parse_oid_hex to avoid needing to hard-code constant values.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 bundle.c    | 33 +++++++++++++++++----------------
 bundle.h    |  4 +++-
 transport.c |  2 +-
 3 files changed, 21 insertions(+), 18 deletions(-)

diff --git a/bundle.c b/bundle.c
index bbf4efa0a..6e181bb3d 100644
--- a/bundle.c
+++ b/bundle.c
@@ -12,11 +12,11 @@
 
 static const char bundle_signature[] = "# v2 git bundle\n";
 
-static void add_to_ref_list(const unsigned char *sha1, const char *name,
+static void add_to_ref_list(const struct object_id *oid, const char *name,
 		struct ref_list *list)
 {
 	ALLOC_GROW(list-&gt;list, list-&gt;nr + 1, list-&gt;alloc);
-	hashcpy(list-&gt;list[list-&gt;nr].sha1, sha1);
+	oidcpy(&amp;list-&gt;list[list-&gt;nr].oid, oid);
 	list-&gt;list[list-&gt;nr].name = xstrdup(name);
 	list-&gt;nr++;
 }
@@ -40,8 +40,9 @@ static int parse_bundle_header(int fd, struct bundle_header *header,
 	/* The bundle header ends with an empty line */
 	while (!strbuf_getwholeline_fd(&amp;buf, fd, '\n') &amp;&amp;
 	       buf.len &amp;&amp; buf.buf[0] != '\n') {
-		unsigned char sha1[20];
+		struct object_id oid;
 		int is_prereq = 0;
+		const char *p;
 
 		if (*buf.buf == '-') {
 			is_prereq = 1;
@@ -54,9 +55,9 @@ static int parse_bundle_header(int fd, struct bundle_header *header,
 		 * Prerequisites have object name that is optionally
 		 * followed by SP and subject line.
 		 */
-		if (get_sha1_hex(buf.buf, sha1) ||
-		    (buf.len &gt; 40 &amp;&amp; !isspace(buf.buf[40])) ||
-		    (!is_prereq &amp;&amp; buf.len &lt;= 40)) {
+		if (parse_oid_hex(buf.buf, &amp;oid, &amp;p) ||
+		    (*p &amp;&amp; !isspace(*p)) ||
+		    (!is_prereq &amp;&amp; !*p)) {
 			if (report_path)
 				error(_("unrecognized header: %s%s (%d)"),
 				      (is_prereq ? "-" : ""), buf.buf, (int)buf.len);
@@ -64,9 +65,9 @@ static int parse_bundle_header(int fd, struct bundle_header *header,
 			break;
 		} else {
 			if (is_prereq)
-				add_to_ref_list(sha1, "", &amp;header-&gt;prerequisites);
+				add_to_ref_list(&amp;oid, "", &amp;header-&gt;prerequisites);
 			else
-				add_to_ref_list(sha1, buf.buf + 41, &amp;header-&gt;references);
+				add_to_ref_list(&amp;oid, p + 1, &amp;header-&gt;references);
 		}
 	}
 
@@ -115,7 +116,7 @@ static int list_refs(struct ref_list *r, int argc, const char **argv)
 			if (j == argc)
 				continue;
 		}
-		printf("%s %s\n", sha1_to_hex(r-&gt;list[i].sha1),
+		printf("%s %s\n", oid_to_hex(&amp;r-&gt;list[i].oid),
 				r-&gt;list[i].name);
 	}
 	return 0;
@@ -141,7 +142,7 @@ int verify_bundle(struct bundle_header *header, int verbose)
 	init_revisions(&amp;revs, NULL);
 	for (i = 0; i &lt; p-&gt;nr; i++) {
 		struct ref_list_entry *e = p-&gt;list + i;
-		struct object *o = parse_object(e-&gt;sha1);
+		struct object *o = parse_object(e-&gt;oid.hash);
 		if (o) {
 			o-&gt;flags |= PREREQ_MARK;
 			add_pending_object(&amp;revs, o, e-&gt;name);
@@ -149,7 +150,7 @@ int verify_bundle(struct bundle_header *header, int verbose)
 		}
 		if (++ret == 1)
 			error("%s", message);
-		error("%s %s", sha1_to_hex(e-&gt;sha1), e-&gt;name);
+		error("%s %s", oid_to_hex(&amp;e-&gt;oid), e-&gt;name);
 	}
 	if (revs.pending.nr != p-&gt;nr)
 		return ret;
@@ -285,16 +286,16 @@ static int compute_and_write_prerequisites(int bundle_fd,
 		return -1;
 	rls_fout = xfdopen(rls.out, "r");
 	while (strbuf_getwholeline(&amp;buf, rls_fout, '\n') != EOF) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		if (buf.len &gt; 0 &amp;&amp; buf.buf[0] == '-') {
 			write_or_die(bundle_fd, buf.buf, buf.len);
-			if (!get_sha1_hex(buf.buf + 1, sha1)) {
-				struct object *object = parse_object_or_die(sha1, buf.buf);
+			if (!get_oid_hex(buf.buf + 1, &amp;oid)) {
+				struct object *object = parse_object_or_die(oid.hash, buf.buf);
 				object-&gt;flags |= UNINTERESTING;
 				add_pending_object(revs, object, buf.buf);
 			}
-		} else if (!get_sha1_hex(buf.buf, sha1)) {
-			struct object *object = parse_object_or_die(sha1, buf.buf);
+		} else if (!get_oid_hex(buf.buf, &amp;oid)) {
+			struct object *object = parse_object_or_die(oid.hash, buf.buf);
 			object-&gt;flags |= SHOWN;
 		}
 	}
diff --git a/bundle.h b/bundle.h
index 1584e4d82..e9a4cb6a7 100644
--- a/bundle.h
+++ b/bundle.h
@@ -1,10 +1,12 @@
 #ifndef BUNDLE_H
 #define BUNDLE_H
 
+#include "cache.h"
+
 struct ref_list {
 	unsigned int nr, alloc;
 	struct ref_list_entry {
-		unsigned char sha1[20];
+		struct object_id oid;
 		char *name;
 	} *list;
 };
diff --git a/transport.c b/transport.c
index 4d33138a7..9bfcf870f 100644
--- a/transport.c
+++ b/transport.c
@@ -87,7 +87,7 @@ static struct ref *get_refs_from_bundle(struct transport *transport, int for_pus
 	for (i = 0; i &lt; data-&gt;header.references.nr; i++) {
 		struct ref_list_entry *e = data-&gt;header.references.list + i;
 		struct ref *ref = alloc_ref(e-&gt;name);
-		hashcpy(ref-&gt;old_oid.hash, e-&gt;sha1);
+		oidcpy(&amp;ref-&gt;old_oid, &amp;e-&gt;oid);
 		ref-&gt;next = result;
 		result = ref;
 	}

<a href="#m502cedc8f4fe38d0aea50d12e0589b397f603796" id="e502cedc8f4fe38d0aea50d12e0589b397f603796">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-7-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r502cedc8f4fe38d0aea50d12e0589b397f603796">52+ messages in thread</a></pre><hr><pre><a href="#e3e82d921d5e2b5c8a78bda08a60f6dde46fcb095" id="m3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">*</a> <b>[PATCH v2 07/53] branch: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r502cedc8f4fe38d0aea50d12e0589b397f603796">(3 preceding siblings ...)</a>
  2017-05-01  2:28 ` <a href="#m502cedc8f4fe38d0aea50d12e0589b397f603796">[PATCH v2 06/53] bundle: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">[PATCH v2 08/53] builtin/blame: convert static function to struct object_id</a> brian m. carlson
                   ` <a href="#rac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">(45 subsequent siblings)</a>
  <a href="#r3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This change is required to convert lookup_commit_reference later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 branch.c | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/branch.c b/branch.c
index ad5a2299b..1758c9708 100644
--- a/branch.c
+++ b/branch.c
@@ -191,9 +191,9 @@ int validate_new_branchname(const char *name, struct strbuf *ref,
 
 	if (!attr_only) {
 		const char *head;
-		unsigned char sha1[20];
+		struct object_id oid;
 
-		head = resolve_ref_unsafe("HEAD", 0, sha1, NULL);
+		head = resolve_ref_unsafe("HEAD", 0, oid.hash, NULL);
 		if (!is_bare_repository() &amp;&amp; head &amp;&amp; !strcmp(head, ref-&gt;buf))
 			die(_("Cannot force update the current branch."));
 	}
@@ -233,7 +233,7 @@ void create_branch(const char *name, const char *start_name,
 		   int quiet, enum branch_track track)
 {
 	struct commit *commit;
-	unsigned char sha1[20];
+	struct object_id oid;
 	char *real_ref;
 	struct strbuf ref = STRBUF_INIT;
 	int forcing = 0;
@@ -253,7 +253,7 @@ void create_branch(const char *name, const char *start_name,
 	}
 
 	real_ref = NULL;
-	if (get_sha1(start_name, sha1)) {
+	if (get_oid(start_name, &amp;oid)) {
 		if (explicit_tracking) {
 			if (advice_set_upstream_failure) {
 				error(_(upstream_missing), start_name);
@@ -265,7 +265,7 @@ void create_branch(const char *name, const char *start_name,
 		die(_("Not a valid object name: '%s'."), start_name);
 	}
 
-	switch (dwim_ref(start_name, strlen(start_name), sha1, &amp;real_ref)) {
+	switch (dwim_ref(start_name, strlen(start_name), oid.hash, &amp;real_ref)) {
 	case 0:
 		/* Not branching from any existing branch */
 		if (explicit_tracking)
@@ -286,9 +286,9 @@ void create_branch(const char *name, const char *start_name,
 		break;
 	}
 
-	if ((commit = lookup_commit_reference(sha1)) == NULL)
+	if ((commit = lookup_commit_reference(oid.hash)) == NULL)
 		die(_("Not a valid branch point: '%s'."), start_name);
-	hashcpy(sha1, commit-&gt;object.oid.hash);
+	oidcpy(&amp;oid, &amp;commit-&gt;object.oid);
 
 	if (reflog)
 		log_all_ref_updates = LOG_REFS_NORMAL;
@@ -306,7 +306,7 @@ void create_branch(const char *name, const char *start_name,
 		transaction = ref_transaction_begin(&amp;err);
 		if (!transaction ||
 		    ref_transaction_update(transaction, ref.buf,
-					   sha1, forcing ? NULL : null_sha1,
+					   oid.hash, forcing ? NULL : null_sha1,
 					   0, msg, &amp;err) ||
 		    ref_transaction_commit(transaction, &amp;err))
 			die("%s", err.buf);

<a href="#m3e82d921d5e2b5c8a78bda08a60f6dde46fcb095" id="e3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-8-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">52+ messages in thread</a></pre><hr><pre><a href="#eac7d1623a7bafeff0fe577e1266a73b89fc6a9e3" id="mac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">*</a> <b>[PATCH v2 08/53] builtin/blame: convert static function to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">(4 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">[PATCH v2 07/53] branch: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m898ba4f5509a44046f947c1b10520fec35bd0023">[PATCH v2 09/53] builtin/rev-parse: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r898ba4f5509a44046f947c1b10520fec35bd0023">(44 subsequent siblings)</a>
  <a href="#rac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This function is a caller of lookup_commit_reference_gently, which we
will convert later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/blame.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/builtin/blame.c b/builtin/blame.c
index 07506a3e4..7d644d092 100644
--- a/builtin/blame.c
+++ b/builtin/blame.c
@@ -2461,7 +2461,7 @@ static const char *dwim_reverse_initial(struct scoreboard *sb)
 	 */
 	struct object *obj;
 	struct commit *head_commit;
-	unsigned char head_sha1[20];
+	struct object_id head_oid;
 
 	if (sb-&gt;revs-&gt;pending.nr != 1)
 		return NULL;
@@ -2473,9 +2473,9 @@ static const char *dwim_reverse_initial(struct scoreboard *sb)
 		return NULL;
 
 	/* Do we have HEAD? */
-	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_sha1, NULL))
+	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_oid.hash, NULL))
 		return NULL;
-	head_commit = lookup_commit_reference_gently(head_sha1, 1);
+	head_commit = lookup_commit_reference_gently(head_oid.hash, 1);
 	if (!head_commit)
 		return NULL;
 

<a href="#mac7d1623a7bafeff0fe577e1266a73b89fc6a9e3" id="eac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-9-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">52+ messages in thread</a></pre><hr><pre><a href="#e898ba4f5509a44046f947c1b10520fec35bd0023" id="m898ba4f5509a44046f947c1b10520fec35bd0023">*</a> <b>[PATCH v2 09/53] builtin/rev-parse: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">(5 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">[PATCH v2 08/53] builtin/blame: convert static function to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">[PATCH v2 10/53] fast-import: convert internal structs to struct object_id</a> brian m. carlson
                   ` <a href="#rc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">(43 subsequent siblings)</a>
  <a href="#r898ba4f5509a44046f947c1b10520fec35bd0023">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Some of the functions converted are callers of lookup_commit_reference.
However, the changes involved in converting the entire thing are not too
large, so we might as well convert it all.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/rev-parse.c | 56 ++++++++++++++++++++++++++---------------------------
 1 file changed, 28 insertions(+), 28 deletions(-)

diff --git a/builtin/rev-parse.c b/builtin/rev-parse.c
index 051333091..272bb13a0 100644
--- a/builtin/rev-parse.c
+++ b/builtin/rev-parse.c
@@ -121,7 +121,7 @@ static void show_with_type(int type, const char *arg)
 }
 
 /* Output a revision, only if filter allows it */
-static void show_rev(int type, const unsigned char *sha1, const char *name)
+static void show_rev(int type, const struct object_id *oid, const char *name)
 {
 	if (!(filter &amp; DO_REVS))
 		return;
@@ -129,10 +129,10 @@ static void show_rev(int type, const unsigned char *sha1, const char *name)
 
 	if ((symbolic || abbrev_ref) &amp;&amp; name) {
 		if (symbolic == SHOW_SYMBOLIC_FULL || abbrev_ref) {
-			unsigned char discard[20];
+			struct object_id discard;
 			char *full;
 
-			switch (dwim_ref(name, strlen(name), discard, &amp;full)) {
+			switch (dwim_ref(name, strlen(name), discard.hash, &amp;full)) {
 			case 0:
 				/*
 				 * Not found -- not a ref.  We could
@@ -158,9 +158,9 @@ static void show_rev(int type, const unsigned char *sha1, const char *name)
 		}
 	}
 	else if (abbrev)
-		show_with_type(type, find_unique_abbrev(sha1, abbrev));
+		show_with_type(type, find_unique_abbrev(oid-&gt;hash, abbrev));
 	else
-		show_with_type(type, sha1_to_hex(sha1));
+		show_with_type(type, oid_to_hex(oid));
 }
 
 /* Output a flag, only if filter allows it. */
@@ -180,11 +180,11 @@ static int show_default(void)
 	const char *s = def;
 
 	if (s) {
-		unsigned char sha1[20];
+		struct object_id oid;
 
 		def = NULL;
-		if (!get_sha1(s, sha1)) {
-			show_rev(NORMAL, sha1, s);
+		if (!get_oid(s, &amp;oid)) {
+			show_rev(NORMAL, &amp;oid, s);
 			return 1;
 		}
 	}
@@ -195,19 +195,19 @@ static int show_reference(const char *refname, const struct object_id *oid, int
 {
 	if (ref_excluded(ref_excludes, refname))
 		return 0;
-	show_rev(NORMAL, oid-&gt;hash, refname);
+	show_rev(NORMAL, oid, refname);
 	return 0;
 }
 
 static int anti_reference(const char *refname, const struct object_id *oid, int flag, void *cb_data)
 {
-	show_rev(REVERSED, oid-&gt;hash, refname);
+	show_rev(REVERSED, oid, refname);
 	return 0;
 }
 
 static int show_abbrev(const struct object_id *oid, void *cb_data)
 {
-	show_rev(NORMAL, oid-&gt;hash, NULL);
+	show_rev(NORMAL, oid, NULL);
 	return 0;
 }
 
@@ -242,8 +242,8 @@ static int show_file(const char *arg, int output_prefix)
 static int try_difference(const char *arg)
 {
 	char *dotdot;
-	unsigned char sha1[20];
-	unsigned char end[20];
+	struct object_id oid;
+	struct object_id end;
 	const char *next;
 	const char *this;
 	int symmetric;
@@ -273,18 +273,18 @@ static int try_difference(const char *arg)
 		return 0;
 	}
 
-	if (!get_sha1_committish(this, sha1) &amp;&amp; !get_sha1_committish(next, end)) {
-		show_rev(NORMAL, end, next);
-		show_rev(symmetric ? NORMAL : REVERSED, sha1, this);
+	if (!get_sha1_committish(this, oid.hash) &amp;&amp; !get_sha1_committish(next, end.hash)) {
+		show_rev(NORMAL, &amp;end, next);
+		show_rev(symmetric ? NORMAL : REVERSED, &amp;oid, this);
 		if (symmetric) {
 			struct commit_list *exclude;
 			struct commit *a, *b;
-			a = lookup_commit_reference(sha1);
-			b = lookup_commit_reference(end);
+			a = lookup_commit_reference(oid.hash);
+			b = lookup_commit_reference(end.hash);
 			exclude = get_merge_bases(a, b);
 			while (exclude) {
 				struct commit *commit = pop_commit(&amp;exclude);
-				show_rev(REVERSED, commit-&gt;object.oid.hash, NULL);
+				show_rev(REVERSED, &amp;commit-&gt;object.oid, NULL);
 			}
 		}
 		*dotdot = '.';
@@ -297,7 +297,7 @@ static int try_difference(const char *arg)
 static int try_parent_shorthands(const char *arg)
 {
 	char *dotdot;
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct commit *commit;
 	struct commit_list *parents;
 	int parent_number;
@@ -327,12 +327,12 @@ static int try_parent_shorthands(const char *arg)
 		return 0;
 
 	*dotdot = 0;
-	if (get_sha1_committish(arg, sha1)) {
+	if (get_sha1_committish(arg, oid.hash)) {
 		*dotdot = '^';
 		return 0;
 	}
 
-	commit = lookup_commit_reference(sha1);
+	commit = lookup_commit_reference(oid.hash);
 	if (exclude_parent &amp;&amp;
 	    exclude_parent &gt; commit_list_count(commit-&gt;parents)) {
 		*dotdot = '^';
@@ -340,7 +340,7 @@ static int try_parent_shorthands(const char *arg)
 	}
 
 	if (include_rev)
-		show_rev(NORMAL, sha1, arg);
+		show_rev(NORMAL, &amp;oid, arg);
 	for (parents = commit-&gt;parents, parent_number = 1;
 	     parents;
 	     parents = parents-&gt;next, parent_number++) {
@@ -352,7 +352,7 @@ static int try_parent_shorthands(const char *arg)
 		if (symbolic)
 			name = xstrfmt("%s^%d", arg, parent_number);
 		show_rev(include_parents ? NORMAL : REVERSED,
-			 parents-&gt;item-&gt;object.oid.hash, name);
+			&amp; parents-&gt;item-&gt;object.oid, name);
 		free(name);
 	}
 
@@ -571,7 +571,7 @@ int cmd_rev_parse(int argc, const char **argv, const char *prefix)
 	int did_repo_setup = 0;
 	int has_dashdash = 0;
 	int output_prefix = 0;
-	unsigned char sha1[20];
+	struct object_id oid;
 	unsigned int flags = 0;
 	const char *name = NULL;
 	struct object_context unused;
@@ -910,11 +910,11 @@ int cmd_rev_parse(int argc, const char **argv, const char *prefix)
 			name++;
 			type = REVERSED;
 		}
-		if (!get_sha1_with_context(name, flags, sha1, &amp;unused)) {
+		if (!get_sha1_with_context(name, flags, oid.hash, &amp;unused)) {
 			if (verify)
 				revs_count++;
 			else
-				show_rev(type, sha1, name);
+				show_rev(type, &amp;oid, name);
 			continue;
 		}
 		if (verify)
@@ -929,7 +929,7 @@ int cmd_rev_parse(int argc, const char **argv, const char *prefix)
 	strbuf_release(&amp;buf);
 	if (verify) {
 		if (revs_count == 1) {
-			show_rev(type, sha1, name);
+			show_rev(type, &amp;oid, name);
 			return 0;
 		} else if (revs_count == 0 &amp;&amp; show_default())
 			return 0;

<a href="#m898ba4f5509a44046f947c1b10520fec35bd0023" id="e898ba4f5509a44046f947c1b10520fec35bd0023">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-10-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r898ba4f5509a44046f947c1b10520fec35bd0023">52+ messages in thread</a></pre><hr><pre><a href="#ec0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f" id="mc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">*</a> <b>[PATCH v2 10/53] fast-import: convert internal structs to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r898ba4f5509a44046f947c1b10520fec35bd0023">(6 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m898ba4f5509a44046f947c1b10520fec35bd0023">[PATCH v2 09/53] builtin/rev-parse: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8814834573a2c203c0ac5b61e7511c9cf7f29af8">[PATCH v2 11/53] fast-import: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r8814834573a2c203c0ac5b61e7511c9cf7f29af8">(42 subsequent siblings)</a>
  <a href="#rc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert struct tree_entry_ms, struct branch, struct tag, and struct
hash_list to use struct object_id by changing the definition and
applying the following semantic patch, plus the standard object_id
transforms:

@@
struct tree_entry_ms E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct tree_entry_ms *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

@@
struct branch E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct branch *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

@@
struct tag E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct tag *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

@@
struct hash_list E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct hash_list *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 fast-import.c | 182 +++++++++++++++++++++++++++++++---------------------------
 1 file changed, 96 insertions(+), 86 deletions(-)

diff --git a/fast-import.c b/fast-import.c
index cf58f875b..0212635dd 100644
--- a/fast-import.c
+++ b/fast-import.c
@@ -226,7 +226,7 @@ struct tree_entry {
 	struct atom_str *name;
 	struct tree_entry_ms {
 		uint16_t mode;
-		unsigned char sha1[20];
+		struct object_id oid;
 	} versions[2];
 };
 
@@ -252,19 +252,19 @@ struct branch {
 	unsigned active : 1;
 	unsigned delete : 1;
 	unsigned pack_id : PACK_ID_BITS;
-	unsigned char sha1[20];
+	struct object_id oid;
 };
 
 struct tag {
 	struct tag *next_tag;
 	const char *name;
 	unsigned int pack_id;
-	unsigned char sha1[20];
+	struct object_id oid;
 };
 
 struct hash_list {
 	struct hash_list *next;
-	unsigned char sha1[20];
+	struct object_id oid;
 };
 
 typedef enum {
@@ -386,13 +386,15 @@ static void write_branch_report(FILE *rpt, struct branch *b)
 		fputs(" active", rpt);
 	if (b-&gt;branch_tree.tree)
 		fputs(" loaded", rpt);
-	if (is_null_sha1(b-&gt;branch_tree.versions[1].sha1))
+	if (is_null_oid(&amp;b-&gt;branch_tree.versions[1].oid))
 		fputs(" dirty", rpt);
 	fputc('\n', rpt);
 
-	fprintf(rpt, "  tip commit  : %s\n", sha1_to_hex(b-&gt;sha1));
-	fprintf(rpt, "  old tree    : %s\n", sha1_to_hex(b-&gt;branch_tree.versions[0].sha1));
-	fprintf(rpt, "  cur tree    : %s\n", sha1_to_hex(b-&gt;branch_tree.versions[1].sha1));
+	fprintf(rpt, "  tip commit  : %s\n", oid_to_hex(&amp;b-&gt;oid));
+	fprintf(rpt, "  old tree    : %s\n",
+		oid_to_hex(&amp;b-&gt;branch_tree.versions[0].oid));
+	fprintf(rpt, "  cur tree    : %s\n",
+		oid_to_hex(&amp;b-&gt;branch_tree.versions[1].oid));
 	fprintf(rpt, "  commit clock: %" PRIuMAX "\n", b-&gt;last_commit);
 
 	fputs("  last pack   : ", rpt);
@@ -470,7 +472,7 @@ static void write_crash_report(const char *err)
 		fputs("Annotated Tags\n", rpt);
 		fputs("--------------\n", rpt);
 		for (tg = first_tag; tg; tg = tg-&gt;next_tag) {
-			fputs(sha1_to_hex(tg-&gt;sha1), rpt);
+			fputs(oid_to_hex(&amp;tg-&gt;oid), rpt);
 			fputc(' ', rpt);
 			fputs(tg-&gt;name, rpt);
 			fputc('\n', rpt);
@@ -876,7 +878,7 @@ static struct tree_content *dup_tree_content(struct tree_content *s)
 		a = s-&gt;entries[i];
 		b = new_tree_entry();
 		memcpy(b, a, sizeof(*a));
-		if (a-&gt;tree &amp;&amp; is_null_sha1(b-&gt;versions[1].sha1))
+		if (a-&gt;tree &amp;&amp; is_null_oid(&amp;b-&gt;versions[1].oid))
 			b-&gt;tree = dup_tree_content(a-&gt;tree);
 		else
 			b-&gt;tree = NULL;
@@ -1041,12 +1043,14 @@ static void end_packfile(void)
 			for (i = 0; i &lt; branch_table_sz; i++) {
 				for (b = branch_table[i]; b; b = b-&gt;table_next_branch) {
 					if (b-&gt;pack_id == pack_id)
-						fprintf(pack_edges, " %s", sha1_to_hex(b-&gt;sha1));
+						fprintf(pack_edges, " %s",
+							oid_to_hex(&amp;b-&gt;oid));
 				}
 			}
 			for (t = first_tag; t; t = t-&gt;next_tag) {
 				if (t-&gt;pack_id == pack_id)
-					fprintf(pack_edges, " %s", sha1_to_hex(t-&gt;sha1));
+					fprintf(pack_edges, " %s",
+						oid_to_hex(&amp;t-&gt;oid));
 			}
 			fputc('\n', pack_edges);
 			fflush(pack_edges);
@@ -1385,7 +1389,7 @@ static const char *get_mode(const char *str, uint16_t *modep)
 
 static void load_tree(struct tree_entry *root)
 {
-	unsigned char *sha1 = root-&gt;versions[1].sha1;
+	unsigned char *sha1 = root-&gt;versions[1].oid.hash;
 	struct object_entry *myoe;
 	struct tree_content *t;
 	unsigned long size;
@@ -1426,8 +1430,8 @@ static void load_tree(struct tree_entry *root)
 		e-&gt;versions[0].mode = e-&gt;versions[1].mode;
 		e-&gt;name = to_atom(c, strlen(c));
 		c += e-&gt;name-&gt;str_len + 1;
-		hashcpy(e-&gt;versions[0].sha1, (unsigned char *)c);
-		hashcpy(e-&gt;versions[1].sha1, (unsigned char *)c);
+		hashcpy(e-&gt;versions[0].oid.hash, (unsigned char *)c);
+		hashcpy(e-&gt;versions[1].oid.hash, (unsigned char *)c);
 		c += 20;
 	}
 	free(buf);
@@ -1475,7 +1479,7 @@ static void mktree(struct tree_content *t, int v, struct strbuf *b)
 		strbuf_addf(b, "%o %s%c",
 			(unsigned int)(e-&gt;versions[v].mode &amp; ~NO_DELTA),
 			e-&gt;name-&gt;str_dat, '\0');
-		strbuf_add(b, e-&gt;versions[v].sha1, 20);
+		strbuf_add(b, e-&gt;versions[v].oid.hash, 20);
 	}
 }
 
@@ -1486,7 +1490,7 @@ static void store_tree(struct tree_entry *root)
 	struct last_object lo = { STRBUF_INIT, 0, 0, /* no_swap */ 1 };
 	struct object_entry *le = NULL;
 
-	if (!is_null_sha1(root-&gt;versions[1].sha1))
+	if (!is_null_oid(&amp;root-&gt;versions[1].oid))
 		return;
 
 	if (!root-&gt;tree)
@@ -1499,7 +1503,7 @@ static void store_tree(struct tree_entry *root)
 	}
 
 	if (!(root-&gt;versions[0].mode &amp; NO_DELTA))
-		le = find_object(root-&gt;versions[0].sha1);
+		le = find_object(root-&gt;versions[0].oid.hash);
 	if (S_ISDIR(root-&gt;versions[0].mode) &amp;&amp; le &amp;&amp; le-&gt;pack_id == pack_id) {
 		mktree(t, 0, &amp;old_tree);
 		lo.data = old_tree;
@@ -1508,14 +1512,14 @@ static void store_tree(struct tree_entry *root)
 	}
 
 	mktree(t, 1, &amp;new_tree);
-	store_object(OBJ_TREE, &amp;new_tree, &amp;lo, root-&gt;versions[1].sha1, 0);
+	store_object(OBJ_TREE, &amp;new_tree, &amp;lo, root-&gt;versions[1].oid.hash, 0);
 
 	t-&gt;delta_depth = lo.depth;
 	for (i = 0, j = 0, del = 0; i &lt; t-&gt;entry_count; i++) {
 		struct tree_entry *e = t-&gt;entries[i];
 		if (e-&gt;versions[1].mode) {
 			e-&gt;versions[0].mode = e-&gt;versions[1].mode;
-			hashcpy(e-&gt;versions[0].sha1, e-&gt;versions[1].sha1);
+			oidcpy(&amp;e-&gt;versions[0].oid, &amp;e-&gt;versions[1].oid);
 			t-&gt;entries[j++] = e;
 		} else {
 			release_tree_entry(e);
@@ -1533,8 +1537,8 @@ static void tree_content_replace(
 {
 	if (!S_ISDIR(mode))
 		die("Root cannot be a non-directory");
-	hashclr(root-&gt;versions[0].sha1);
-	hashcpy(root-&gt;versions[1].sha1, sha1);
+	oidclr(&amp;root-&gt;versions[0].oid);
+	hashcpy(root-&gt;versions[1].oid.hash, sha1);
 	if (root-&gt;tree)
 		release_tree_content_recursive(root-&gt;tree);
 	root-&gt;tree = newtree;
@@ -1568,10 +1572,10 @@ static int tree_content_set(
 			if (!*slash1) {
 				if (!S_ISDIR(mode)
 						&amp;&amp; e-&gt;versions[1].mode == mode
-						&amp;&amp; !hashcmp(e-&gt;versions[1].sha1, sha1))
+						&amp;&amp; !hashcmp(e-&gt;versions[1].oid.hash, sha1))
 					return 0;
 				e-&gt;versions[1].mode = mode;
-				hashcpy(e-&gt;versions[1].sha1, sha1);
+				hashcpy(e-&gt;versions[1].oid.hash, sha1);
 				if (e-&gt;tree)
 					release_tree_content_recursive(e-&gt;tree);
 				e-&gt;tree = subtree;
@@ -1592,7 +1596,7 @@ static int tree_content_set(
 				if (S_ISDIR(e-&gt;versions[0].mode))
 					e-&gt;versions[0].mode |= NO_DELTA;
 
-				hashclr(root-&gt;versions[1].sha1);
+				oidclr(&amp;root-&gt;versions[1].oid);
 				return 1;
 			}
 			if (!S_ISDIR(e-&gt;versions[1].mode)) {
@@ -1602,7 +1606,7 @@ static int tree_content_set(
 			if (!e-&gt;tree)
 				load_tree(e);
 			if (tree_content_set(e, slash1 + 1, sha1, mode, subtree)) {
-				hashclr(root-&gt;versions[1].sha1);
+				oidclr(&amp;root-&gt;versions[1].oid);
 				return 1;
 			}
 			return 0;
@@ -1614,7 +1618,7 @@ static int tree_content_set(
 	e = new_tree_entry();
 	e-&gt;name = to_atom(p, n);
 	e-&gt;versions[0].mode = 0;
-	hashclr(e-&gt;versions[0].sha1);
+	oidclr(&amp;e-&gt;versions[0].oid);
 	t-&gt;entries[t-&gt;entry_count++] = e;
 	if (*slash1) {
 		e-&gt;tree = new_tree_content(8);
@@ -1623,9 +1627,9 @@ static int tree_content_set(
 	} else {
 		e-&gt;tree = subtree;
 		e-&gt;versions[1].mode = mode;
-		hashcpy(e-&gt;versions[1].sha1, sha1);
+		hashcpy(e-&gt;versions[1].oid.hash, sha1);
 	}
-	hashclr(root-&gt;versions[1].sha1);
+	oidclr(&amp;root-&gt;versions[1].oid);
 	return 1;
 }
 
@@ -1670,7 +1674,7 @@ static int tree_content_remove(
 			if (tree_content_remove(e, slash1 + 1, backup_leaf, 0)) {
 				for (n = 0; n &lt; e-&gt;tree-&gt;entry_count; n++) {
 					if (e-&gt;tree-&gt;entries[n]-&gt;versions[1].mode) {
-						hashclr(root-&gt;versions[1].sha1);
+						oidclr(&amp;root-&gt;versions[1].oid);
 						return 1;
 					}
 				}
@@ -1689,8 +1693,8 @@ static int tree_content_remove(
 		release_tree_content_recursive(e-&gt;tree);
 	e-&gt;tree = NULL;
 	e-&gt;versions[1].mode = 0;
-	hashclr(e-&gt;versions[1].sha1);
-	hashclr(root-&gt;versions[1].sha1);
+	oidclr(&amp;e-&gt;versions[1].oid);
+	oidclr(&amp;root-&gt;versions[1].oid);
 	return 1;
 }
 
@@ -1735,7 +1739,7 @@ static int tree_content_get(
 
 found_entry:
 	memcpy(leaf, e, sizeof(*leaf));
-	if (e-&gt;tree &amp;&amp; is_null_sha1(e-&gt;versions[1].sha1))
+	if (e-&gt;tree &amp;&amp; is_null_oid(&amp;e-&gt;versions[1].oid))
 		leaf-&gt;tree = dup_tree_content(e-&gt;tree);
 	else
 		leaf-&gt;tree = NULL;
@@ -1749,7 +1753,7 @@ static int update_branch(struct branch *b)
 	unsigned char old_sha1[20];
 	struct strbuf err = STRBUF_INIT;
 
-	if (is_null_sha1(b-&gt;sha1)) {
+	if (is_null_oid(&amp;b-&gt;oid)) {
 		if (b-&gt;delete)
 			delete_ref(NULL, b-&gt;name, NULL, 0);
 		return 0;
@@ -1760,20 +1764,21 @@ static int update_branch(struct branch *b)
 		struct commit *old_cmit, *new_cmit;
 
 		old_cmit = lookup_commit_reference_gently(old_sha1, 0);
-		new_cmit = lookup_commit_reference_gently(b-&gt;sha1, 0);
+		new_cmit = lookup_commit_reference_gently(b-&gt;oid.hash, 0);
 		if (!old_cmit || !new_cmit)
 			return error("Branch %s is missing commits.", b-&gt;name);
 
 		if (!in_merge_bases(old_cmit, new_cmit)) {
 			warning("Not updating %s"
 				" (new tip %s does not contain %s)",
-				b-&gt;name, sha1_to_hex(b-&gt;sha1), sha1_to_hex(old_sha1));
+				b-&gt;name, oid_to_hex(&amp;b-&gt;oid),
+				sha1_to_hex(old_sha1));
 			return -1;
 		}
 	}
 	transaction = ref_transaction_begin(&amp;err);
 	if (!transaction ||
-	    ref_transaction_update(transaction, b-&gt;name, b-&gt;sha1, old_sha1,
+	    ref_transaction_update(transaction, b-&gt;name, b-&gt;oid.hash, old_sha1,
 				   0, msg, &amp;err) ||
 	    ref_transaction_commit(transaction, &amp;err)) {
 		ref_transaction_free(transaction);
@@ -1815,7 +1820,7 @@ static void dump_tags(void)
 		strbuf_addf(&amp;ref_name, "refs/tags/%s", t-&gt;name);
 
 		if (ref_transaction_update(transaction, ref_name.buf,
-					   t-&gt;sha1, NULL, 0, msg, &amp;err)) {
+					   t-&gt;oid.hash, NULL, 0, msg, &amp;err)) {
 			failure |= error("%s", err.buf);
 			goto cleanup;
 		}
@@ -2274,7 +2279,7 @@ static uintmax_t do_change_note_fanout(
 			if (!tree_content_remove(orig_root, fullpath, &amp;leaf, 0))
 				die("Failed to remove path %s", fullpath);
 			tree_content_set(orig_root, realpath,
-				leaf.versions[1].sha1,
+				leaf.versions[1].oid.hash,
 				leaf.versions[1].mode,
 				leaf.tree);
 		} else if (S_ISDIR(e-&gt;versions[1].mode)) {
@@ -2504,13 +2509,13 @@ static void file_change_cr(const char *s, struct branch *b, int rename)
 		die("Path %s not in branch", s);
 	if (!*d) {	/* C "path/to/subdir" "" */
 		tree_content_replace(&amp;b-&gt;branch_tree,
-			leaf.versions[1].sha1,
+			leaf.versions[1].oid.hash,
 			leaf.versions[1].mode,
 			leaf.tree);
 		return;
 	}
 	tree_content_set(&amp;b-&gt;branch_tree, d,
-		leaf.versions[1].sha1,
+		leaf.versions[1].oid.hash,
 		leaf.versions[1].mode,
 		leaf.tree);
 }
@@ -2561,9 +2566,9 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	/* &lt;commit-ish&gt; */
 	s = lookup_branch(p);
 	if (s) {
-		if (is_null_sha1(s-&gt;sha1))
+		if (is_null_oid(&amp;s-&gt;oid))
 			die("Can't add a note on empty branch.");
-		hashcpy(commit_sha1, s-&gt;sha1);
+		hashcpy(commit_sha1, s-&gt;oid.hash);
 	} else if (*p == ':') {
 		uintmax_t commit_mark = parse_mark_ref_eol(p);
 		struct object_entry *commit_oe = find_mark(commit_mark);
@@ -2616,8 +2621,8 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 static void file_change_deleteall(struct branch *b)
 {
 	release_tree_content_recursive(b-&gt;branch_tree.tree);
-	hashclr(b-&gt;branch_tree.versions[0].sha1);
-	hashclr(b-&gt;branch_tree.versions[1].sha1);
+	oidclr(&amp;b-&gt;branch_tree.versions[0].oid);
+	oidclr(&amp;b-&gt;branch_tree.versions[1].oid);
 	load_tree(&amp;b-&gt;branch_tree);
 	b-&gt;num_notes = 0;
 }
@@ -2625,25 +2630,26 @@ static void file_change_deleteall(struct branch *b)
 static void parse_from_commit(struct branch *b, char *buf, unsigned long size)
 {
 	if (!buf || size &lt; 46)
-		die("Not a valid commit: %s", sha1_to_hex(b-&gt;sha1));
+		die("Not a valid commit: %s", oid_to_hex(&amp;b-&gt;oid));
 	if (memcmp("tree ", buf, 5)
-		|| get_sha1_hex(buf + 5, b-&gt;branch_tree.versions[1].sha1))
-		die("The commit %s is corrupt", sha1_to_hex(b-&gt;sha1));
-	hashcpy(b-&gt;branch_tree.versions[0].sha1,
-		b-&gt;branch_tree.versions[1].sha1);
+		|| get_sha1_hex(buf + 5, b-&gt;branch_tree.versions[1].oid.hash))
+		die("The commit %s is corrupt", oid_to_hex(&amp;b-&gt;oid));
+	oidcpy(&amp;b-&gt;branch_tree.versions[0].oid,
+	       &amp;b-&gt;branch_tree.versions[1].oid);
 }
 
 static void parse_from_existing(struct branch *b)
 {
-	if (is_null_sha1(b-&gt;sha1)) {
-		hashclr(b-&gt;branch_tree.versions[0].sha1);
-		hashclr(b-&gt;branch_tree.versions[1].sha1);
+	if (is_null_oid(&amp;b-&gt;oid)) {
+		oidclr(&amp;b-&gt;branch_tree.versions[0].oid);
+		oidclr(&amp;b-&gt;branch_tree.versions[1].oid);
 	} else {
 		unsigned long size;
 		char *buf;
 
-		buf = read_object_with_reference(b-&gt;sha1,
-			commit_type, &amp;size, b-&gt;sha1);
+		buf = read_object_with_reference(b-&gt;oid.hash,
+						 commit_type, &amp;size,
+						 b-&gt;oid.hash);
 		parse_from_commit(b, buf, size);
 		free(buf);
 	}
@@ -2658,23 +2664,23 @@ static int parse_from(struct branch *b)
 	if (!skip_prefix(command_buf.buf, "from ", &amp;from))
 		return 0;
 
-	hashcpy(sha1, b-&gt;branch_tree.versions[1].sha1);
+	hashcpy(sha1, b-&gt;branch_tree.versions[1].oid.hash);
 
 	s = lookup_branch(from);
 	if (b == s)
 		die("Can't create a branch from itself: %s", b-&gt;name);
 	else if (s) {
-		unsigned char *t = s-&gt;branch_tree.versions[1].sha1;
-		hashcpy(b-&gt;sha1, s-&gt;sha1);
-		hashcpy(b-&gt;branch_tree.versions[0].sha1, t);
-		hashcpy(b-&gt;branch_tree.versions[1].sha1, t);
+		unsigned char *t = s-&gt;branch_tree.versions[1].oid.hash;
+		oidcpy(&amp;b-&gt;oid, &amp;s-&gt;oid);
+		hashcpy(b-&gt;branch_tree.versions[0].oid.hash, t);
+		hashcpy(b-&gt;branch_tree.versions[1].oid.hash, t);
 	} else if (*from == ':') {
 		uintmax_t idnum = parse_mark_ref_eol(from);
 		struct object_entry *oe = find_mark(idnum);
 		if (oe-&gt;type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", idnum);
-		if (hashcmp(b-&gt;sha1, oe-&gt;idx.sha1)) {
-			hashcpy(b-&gt;sha1, oe-&gt;idx.sha1);
+		if (hashcmp(b-&gt;oid.hash, oe-&gt;idx.sha1)) {
+			hashcpy(b-&gt;oid.hash, oe-&gt;idx.sha1);
 			if (oe-&gt;pack_id != MAX_PACK_ID) {
 				unsigned long size;
 				char *buf = gfi_unpack_entry(oe, &amp;size);
@@ -2683,15 +2689,15 @@ static int parse_from(struct branch *b)
 			} else
 				parse_from_existing(b);
 		}
-	} else if (!get_sha1(from, b-&gt;sha1)) {
+	} else if (!get_sha1(from, b-&gt;oid.hash)) {
 		parse_from_existing(b);
-		if (is_null_sha1(b-&gt;sha1))
+		if (is_null_oid(&amp;b-&gt;oid))
 			b-&gt;delete = 1;
 	}
 	else
 		die("Invalid ref name or SHA1 expression: %s", from);
 
-	if (b-&gt;branch_tree.tree &amp;&amp; hashcmp(sha1, b-&gt;branch_tree.versions[1].sha1)) {
+	if (b-&gt;branch_tree.tree &amp;&amp; hashcmp(sha1, b-&gt;branch_tree.versions[1].oid.hash)) {
 		release_tree_content_recursive(b-&gt;branch_tree.tree);
 		b-&gt;branch_tree.tree = NULL;
 	}
@@ -2711,17 +2717,19 @@ static struct hash_list *parse_merge(unsigned int *count)
 		n = xmalloc(sizeof(*n));
 		s = lookup_branch(from);
 		if (s)
-			hashcpy(n-&gt;sha1, s-&gt;sha1);
+			oidcpy(&amp;n-&gt;oid, &amp;s-&gt;oid);
 		else if (*from == ':') {
 			uintmax_t idnum = parse_mark_ref_eol(from);
 			struct object_entry *oe = find_mark(idnum);
 			if (oe-&gt;type != OBJ_COMMIT)
 				die("Mark :%" PRIuMAX " not a commit", idnum);
-			hashcpy(n-&gt;sha1, oe-&gt;idx.sha1);
-		} else if (!get_sha1(from, n-&gt;sha1)) {
+			hashcpy(n-&gt;oid.hash, oe-&gt;idx.sha1);
+		} else if (!get_sha1(from, n-&gt;oid.hash)) {
 			unsigned long size;
-			char *buf = read_object_with_reference(n-&gt;sha1,
-				commit_type, &amp;size, n-&gt;sha1);
+			char *buf = read_object_with_reference(n-&gt;oid.hash,
+							       commit_type,
+							       &amp;size,
+							       n-&gt;oid.hash);
 			if (!buf || size &lt; 46)
 				die("Not a valid commit: %s", from);
 			free(buf);
@@ -2808,17 +2816,19 @@ static void parse_new_commit(const char *arg)
 
 	/* build the tree and the commit */
 	store_tree(&amp;b-&gt;branch_tree);
-	hashcpy(b-&gt;branch_tree.versions[0].sha1,
-		b-&gt;branch_tree.versions[1].sha1);
+	oidcpy(&amp;b-&gt;branch_tree.versions[0].oid,
+	       &amp;b-&gt;branch_tree.versions[1].oid);
 
 	strbuf_reset(&amp;new_data);
 	strbuf_addf(&amp;new_data, "tree %s\n",
-		sha1_to_hex(b-&gt;branch_tree.versions[1].sha1));
-	if (!is_null_sha1(b-&gt;sha1))
-		strbuf_addf(&amp;new_data, "parent %s\n", sha1_to_hex(b-&gt;sha1));
+		oid_to_hex(&amp;b-&gt;branch_tree.versions[1].oid));
+	if (!is_null_oid(&amp;b-&gt;oid))
+		strbuf_addf(&amp;new_data, "parent %s\n",
+			    oid_to_hex(&amp;b-&gt;oid));
 	while (merge_list) {
 		struct hash_list *next = merge_list-&gt;next;
-		strbuf_addf(&amp;new_data, "parent %s\n", sha1_to_hex(merge_list-&gt;sha1));
+		strbuf_addf(&amp;new_data, "parent %s\n",
+			    oid_to_hex(&amp;merge_list-&gt;oid));
 		free(merge_list);
 		merge_list = next;
 	}
@@ -2831,7 +2841,7 @@ static void parse_new_commit(const char *arg)
 	free(author);
 	free(committer);
 
-	if (!store_object(OBJ_COMMIT, &amp;new_data, NULL, b-&gt;sha1, next_mark))
+	if (!store_object(OBJ_COMMIT, &amp;new_data, NULL, b-&gt;oid.hash, next_mark))
 		b-&gt;pack_id = pack_id;
 	b-&gt;last_commit = object_count_by_type[OBJ_COMMIT];
 }
@@ -2863,9 +2873,9 @@ static void parse_new_tag(const char *arg)
 		die("Expected from command, got %s", command_buf.buf);
 	s = lookup_branch(from);
 	if (s) {
-		if (is_null_sha1(s-&gt;sha1))
+		if (is_null_oid(&amp;s-&gt;oid))
 			die("Can't tag an empty branch.");
-		hashcpy(sha1, s-&gt;sha1);
+		hashcpy(sha1, s-&gt;oid.hash);
 		type = OBJ_COMMIT;
 	} else if (*from == ':') {
 		struct object_entry *oe;
@@ -2910,7 +2920,7 @@ static void parse_new_tag(const char *arg)
 	strbuf_addbuf(&amp;new_data, &amp;msg);
 	free(tagger);
 
-	if (store_object(OBJ_TAG, &amp;new_data, NULL, t-&gt;sha1, 0))
+	if (store_object(OBJ_TAG, &amp;new_data, NULL, t-&gt;oid.hash, 0))
 		t-&gt;pack_id = MAX_PACK_ID;
 	else
 		t-&gt;pack_id = pack_id;
@@ -2922,9 +2932,9 @@ static void parse_reset_branch(const char *arg)
 
 	b = lookup_branch(arg);
 	if (b) {
-		hashclr(b-&gt;sha1);
-		hashclr(b-&gt;branch_tree.versions[0].sha1);
-		hashclr(b-&gt;branch_tree.versions[1].sha1);
+		oidclr(&amp;b-&gt;oid);
+		oidclr(&amp;b-&gt;branch_tree.versions[0].oid);
+		oidclr(&amp;b-&gt;branch_tree.versions[1].oid);
 		if (b-&gt;branch_tree.tree) {
 			release_tree_content_recursive(b-&gt;branch_tree.tree);
 			b-&gt;branch_tree.tree = NULL;
@@ -3143,8 +3153,8 @@ static void parse_ls(const char *p, struct branch *b)
 	} else {
 		struct object_entry *e = parse_treeish_dataref(&amp;p);
 		root = new_tree_entry();
-		hashcpy(root-&gt;versions[1].sha1, e-&gt;idx.sha1);
-		if (!is_null_sha1(root-&gt;versions[1].sha1))
+		hashcpy(root-&gt;versions[1].oid.hash, e-&gt;idx.sha1);
+		if (!is_null_oid(&amp;root-&gt;versions[1].oid))
 			root-&gt;versions[1].mode = S_IFDIR;
 		load_tree(root);
 	}
@@ -3166,7 +3176,7 @@ static void parse_ls(const char *p, struct branch *b)
 	if (S_ISDIR(leaf.versions[1].mode))
 		store_tree(&amp;leaf);
 
-	print_ls(leaf.versions[1].mode, leaf.versions[1].sha1, p);
+	print_ls(leaf.versions[1].mode, leaf.versions[1].oid.hash, p);
 	if (leaf.tree)
 		release_tree_content_recursive(leaf.tree);
 	if (!b || root != &amp;b-&gt;branch_tree)

<a href="#mc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f" id="ec0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-11-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">52+ messages in thread</a></pre><hr><pre><a href="#e8814834573a2c203c0ac5b61e7511c9cf7f29af8" id="m8814834573a2c203c0ac5b61e7511c9cf7f29af8">*</a> <b>[PATCH v2 11/53] fast-import: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">(7 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">[PATCH v2 10/53] fast-import: convert internal structs to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mc36780c4224c14bded80f8b7f2e7614a7bfa3126">[PATCH v2 12/53] submodule: convert merge_submodule to use struct object_id</a> brian m. carlson
                   ` <a href="#rc36780c4224c14bded80f8b7f2e7614a7bfa3126">(41 subsequent siblings)</a>
  <a href="#r8814834573a2c203c0ac5b61e7511c9cf7f29af8">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the remaining parts of fast-import.c to use struct object_id.
Convert several instances of get_sha1_hex to parse_oid_hex to avoid
needing to specify constants.  Convert other hardcoded values to named
constants.  Finally, use the is_empty_tree_oid function instead of a
direct comparison against a fixed string.

Note that the odd computation with GIT_MAX_HEXSZ is due to the insertion
of a slash between every two hex digits in the path, plus one for the
terminating NUL.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 fast-import.c | 321 +++++++++++++++++++++++++++++-----------------------------
 1 file changed, 159 insertions(+), 162 deletions(-)

diff --git a/fast-import.c b/fast-import.c
index 0212635dd..2706eb2fe 100644
--- a/fast-import.c
+++ b/fast-import.c
@@ -391,10 +391,8 @@ static void write_branch_report(FILE *rpt, struct branch *b)
 	fputc('\n', rpt);
 
 	fprintf(rpt, "  tip commit  : %s\n", oid_to_hex(&amp;b-&gt;oid));
-	fprintf(rpt, "  old tree    : %s\n",
-		oid_to_hex(&amp;b-&gt;branch_tree.versions[0].oid));
-	fprintf(rpt, "  cur tree    : %s\n",
-		oid_to_hex(&amp;b-&gt;branch_tree.versions[1].oid));
+	fprintf(rpt, "  old tree    : %s\n", oid_to_hex(&amp;b-&gt;branch_tree.versions[0].oid));
+	fprintf(rpt, "  cur tree    : %s\n", oid_to_hex(&amp;b-&gt;branch_tree.versions[1].oid));
 	fprintf(rpt, "  commit clock: %" PRIuMAX "\n", b-&gt;last_commit);
 
 	fputs("  last pack   : ", rpt);
@@ -557,7 +555,7 @@ static void alloc_objects(unsigned int cnt)
 	alloc_count += cnt;
 }
 
-static struct object_entry *new_object(unsigned char *sha1)
+static struct object_entry *new_object(struct object_id *oid)
 {
 	struct object_entry *e;
 
@@ -565,32 +563,32 @@ static struct object_entry *new_object(unsigned char *sha1)
 		alloc_objects(object_entry_alloc);
 
 	e = blocks-&gt;next_free++;
-	hashcpy(e-&gt;idx.sha1, sha1);
+	hashcpy(e-&gt;idx.sha1, oid-&gt;hash);
 	return e;
 }
 
-static struct object_entry *find_object(unsigned char *sha1)
+static struct object_entry *find_object(struct object_id *oid)
 {
-	unsigned int h = sha1[0] &lt;&lt; 8 | sha1[1];
+	unsigned int h = oid-&gt;hash[0] &lt;&lt; 8 | oid-&gt;hash[1];
 	struct object_entry *e;
 	for (e = object_table[h]; e; e = e-&gt;next)
-		if (!hashcmp(sha1, e-&gt;idx.sha1))
+		if (!hashcmp(oid-&gt;hash, e-&gt;idx.sha1))
 			return e;
 	return NULL;
 }
 
-static struct object_entry *insert_object(unsigned char *sha1)
+static struct object_entry *insert_object(struct object_id *oid)
 {
-	unsigned int h = sha1[0] &lt;&lt; 8 | sha1[1];
+	unsigned int h = oid-&gt;hash[0] &lt;&lt; 8 | oid-&gt;hash[1];
 	struct object_entry *e = object_table[h];
 
 	while (e) {
-		if (!hashcmp(sha1, e-&gt;idx.sha1))
+		if (!hashcmp(oid-&gt;hash, e-&gt;idx.sha1))
 			return e;
 		e = e-&gt;next;
 	}
 
-	e = new_object(sha1);
+	e = new_object(oid);
 	e-&gt;next = object_table[h];
 	e-&gt;idx.offset = 0;
 	object_table[h] = e;
@@ -1007,17 +1005,17 @@ static void end_packfile(void)
 	clear_delta_base_cache();
 	if (object_count) {
 		struct packed_git *new_p;
-		unsigned char cur_pack_sha1[20];
+		struct object_id cur_pack_oid;
 		char *idx_name;
 		int i;
 		struct branch *b;
 		struct tag *t;
 
 		close_pack_windows(pack_data);
-		sha1close(pack_file, cur_pack_sha1, 0);
+		sha1close(pack_file, cur_pack_oid.hash, 0);
 		fixup_pack_header_footer(pack_data-&gt;pack_fd, pack_data-&gt;sha1,
 				    pack_data-&gt;pack_name, object_count,
-				    cur_pack_sha1, pack_size);
+				    cur_pack_oid.hash, pack_size);
 
 		if (object_count &lt;= unpack_limit) {
 			if (!loosen_small_pack(pack_data)) {
@@ -1083,13 +1081,13 @@ static int store_object(
 	enum object_type type,
 	struct strbuf *dat,
 	struct last_object *last,
-	unsigned char *sha1out,
+	struct object_id *oidout,
 	uintmax_t mark)
 {
 	void *out, *delta;
 	struct object_entry *e;
 	unsigned char hdr[96];
-	unsigned char sha1[20];
+	struct object_id oid;
 	unsigned long hdrlen, deltalen;
 	git_SHA_CTX c;
 	git_zstream s;
@@ -1099,17 +1097,17 @@ static int store_object(
 	git_SHA1_Init(&amp;c);
 	git_SHA1_Update(&amp;c, hdr, hdrlen);
 	git_SHA1_Update(&amp;c, dat-&gt;buf, dat-&gt;len);
-	git_SHA1_Final(sha1, &amp;c);
-	if (sha1out)
-		hashcpy(sha1out, sha1);
+	git_SHA1_Final(oid.hash, &amp;c);
+	if (oidout)
+		oidcpy(oidout, &amp;oid);
 
-	e = insert_object(sha1);
+	e = insert_object(&amp;oid);
 	if (mark)
 		insert_mark(mark, e);
 	if (e-&gt;idx.offset) {
 		duplicate_count_by_type[type]++;
 		return 1;
-	} else if (find_sha1_pack(sha1, packed_git)) {
+	} else if (find_sha1_pack(oid.hash, packed_git)) {
 		e-&gt;type = type;
 		e-&gt;pack_id = MAX_PACK_ID;
 		e-&gt;idx.offset = 1; /* just not zero! */
@@ -1222,13 +1220,13 @@ static void truncate_pack(struct sha1file_checkpoint *checkpoint)
 	pack_size = checkpoint-&gt;offset;
 }
 
-static void stream_blob(uintmax_t len, unsigned char *sha1out, uintmax_t mark)
+static void stream_blob(uintmax_t len, struct object_id *oidout, uintmax_t mark)
 {
 	size_t in_sz = 64 * 1024, out_sz = 64 * 1024;
 	unsigned char *in_buf = xmalloc(in_sz);
 	unsigned char *out_buf = xmalloc(out_sz);
 	struct object_entry *e;
-	unsigned char sha1[20];
+	struct object_id oid;
 	unsigned long hdrlen;
 	off_t offset;
 	git_SHA_CTX c;
@@ -1291,12 +1289,12 @@ static void stream_blob(uintmax_t len, unsigned char *sha1out, uintmax_t mark)
 		}
 	}
 	git_deflate_end(&amp;s);
-	git_SHA1_Final(sha1, &amp;c);
+	git_SHA1_Final(oid.hash, &amp;c);
 
-	if (sha1out)
-		hashcpy(sha1out, sha1);
+	if (oidout)
+		oidcpy(oidout, &amp;oid);
 
-	e = insert_object(sha1);
+	e = insert_object(&amp;oid);
 
 	if (mark)
 		insert_mark(mark, e);
@@ -1305,7 +1303,7 @@ static void stream_blob(uintmax_t len, unsigned char *sha1out, uintmax_t mark)
 		duplicate_count_by_type[OBJ_BLOB]++;
 		truncate_pack(&amp;checkpoint);
 
-	} else if (find_sha1_pack(sha1, packed_git)) {
+	} else if (find_sha1_pack(oid.hash, packed_git)) {
 		e-&gt;type = OBJ_BLOB;
 		e-&gt;pack_id = MAX_PACK_ID;
 		e-&gt;idx.offset = 1; /* just not zero! */
@@ -1389,7 +1387,7 @@ static const char *get_mode(const char *str, uint16_t *modep)
 
 static void load_tree(struct tree_entry *root)
 {
-	unsigned char *sha1 = root-&gt;versions[1].oid.hash;
+	struct object_id *oid = &amp;root-&gt;versions[1].oid;
 	struct object_entry *myoe;
 	struct tree_content *t;
 	unsigned long size;
@@ -1397,22 +1395,22 @@ static void load_tree(struct tree_entry *root)
 	const char *c;
 
 	root-&gt;tree = t = new_tree_content(8);
-	if (is_null_sha1(sha1))
+	if (is_null_oid(oid))
 		return;
 
-	myoe = find_object(sha1);
+	myoe = find_object(oid);
 	if (myoe &amp;&amp; myoe-&gt;pack_id != MAX_PACK_ID) {
 		if (myoe-&gt;type != OBJ_TREE)
-			die("Not a tree: %s", sha1_to_hex(sha1));
+			die("Not a tree: %s", oid_to_hex(oid));
 		t-&gt;delta_depth = myoe-&gt;depth;
 		buf = gfi_unpack_entry(myoe, &amp;size);
 		if (!buf)
-			die("Can't load tree %s", sha1_to_hex(sha1));
+			die("Can't load tree %s", oid_to_hex(oid));
 	} else {
 		enum object_type type;
-		buf = read_sha1_file(sha1, &amp;type, &amp;size);
+		buf = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
 		if (!buf || type != OBJ_TREE)
-			die("Can't load tree %s", sha1_to_hex(sha1));
+			die("Can't load tree %s", oid_to_hex(oid));
 	}
 
 	c = buf;
@@ -1426,13 +1424,13 @@ static void load_tree(struct tree_entry *root)
 		e-&gt;tree = NULL;
 		c = get_mode(c, &amp;e-&gt;versions[1].mode);
 		if (!c)
-			die("Corrupt mode in %s", sha1_to_hex(sha1));
+			die("Corrupt mode in %s", oid_to_hex(oid));
 		e-&gt;versions[0].mode = e-&gt;versions[1].mode;
 		e-&gt;name = to_atom(c, strlen(c));
 		c += e-&gt;name-&gt;str_len + 1;
 		hashcpy(e-&gt;versions[0].oid.hash, (unsigned char *)c);
 		hashcpy(e-&gt;versions[1].oid.hash, (unsigned char *)c);
-		c += 20;
+		c += GIT_SHA1_RAWSZ;
 	}
 	free(buf);
 }
@@ -1479,7 +1477,7 @@ static void mktree(struct tree_content *t, int v, struct strbuf *b)
 		strbuf_addf(b, "%o %s%c",
 			(unsigned int)(e-&gt;versions[v].mode &amp; ~NO_DELTA),
 			e-&gt;name-&gt;str_dat, '\0');
-		strbuf_add(b, e-&gt;versions[v].oid.hash, 20);
+		strbuf_add(b, e-&gt;versions[v].oid.hash, GIT_SHA1_RAWSZ);
 	}
 }
 
@@ -1503,7 +1501,7 @@ static void store_tree(struct tree_entry *root)
 	}
 
 	if (!(root-&gt;versions[0].mode &amp; NO_DELTA))
-		le = find_object(root-&gt;versions[0].oid.hash);
+		le = find_object(&amp;root-&gt;versions[0].oid);
 	if (S_ISDIR(root-&gt;versions[0].mode) &amp;&amp; le &amp;&amp; le-&gt;pack_id == pack_id) {
 		mktree(t, 0, &amp;old_tree);
 		lo.data = old_tree;
@@ -1512,7 +1510,7 @@ static void store_tree(struct tree_entry *root)
 	}
 
 	mktree(t, 1, &amp;new_tree);
-	store_object(OBJ_TREE, &amp;new_tree, &amp;lo, root-&gt;versions[1].oid.hash, 0);
+	store_object(OBJ_TREE, &amp;new_tree, &amp;lo, &amp;root-&gt;versions[1].oid, 0);
 
 	t-&gt;delta_depth = lo.depth;
 	for (i = 0, j = 0, del = 0; i &lt; t-&gt;entry_count; i++) {
@@ -1531,14 +1529,14 @@ static void store_tree(struct tree_entry *root)
 
 static void tree_content_replace(
 	struct tree_entry *root,
-	const unsigned char *sha1,
+	const struct object_id *oid,
 	const uint16_t mode,
 	struct tree_content *newtree)
 {
 	if (!S_ISDIR(mode))
 		die("Root cannot be a non-directory");
 	oidclr(&amp;root-&gt;versions[0].oid);
-	hashcpy(root-&gt;versions[1].oid.hash, sha1);
+	oidcpy(&amp;root-&gt;versions[1].oid, oid);
 	if (root-&gt;tree)
 		release_tree_content_recursive(root-&gt;tree);
 	root-&gt;tree = newtree;
@@ -1547,7 +1545,7 @@ static void tree_content_replace(
 static int tree_content_set(
 	struct tree_entry *root,
 	const char *p,
-	const unsigned char *sha1,
+	const struct object_id *oid,
 	const uint16_t mode,
 	struct tree_content *subtree)
 {
@@ -1572,10 +1570,10 @@ static int tree_content_set(
 			if (!*slash1) {
 				if (!S_ISDIR(mode)
 						&amp;&amp; e-&gt;versions[1].mode == mode
-						&amp;&amp; !hashcmp(e-&gt;versions[1].oid.hash, sha1))
+						&amp;&amp; !oidcmp(&amp;e-&gt;versions[1].oid, oid))
 					return 0;
 				e-&gt;versions[1].mode = mode;
-				hashcpy(e-&gt;versions[1].oid.hash, sha1);
+				oidcpy(&amp;e-&gt;versions[1].oid, oid);
 				if (e-&gt;tree)
 					release_tree_content_recursive(e-&gt;tree);
 				e-&gt;tree = subtree;
@@ -1605,7 +1603,7 @@ static int tree_content_set(
 			}
 			if (!e-&gt;tree)
 				load_tree(e);
-			if (tree_content_set(e, slash1 + 1, sha1, mode, subtree)) {
+			if (tree_content_set(e, slash1 + 1, oid, mode, subtree)) {
 				oidclr(&amp;root-&gt;versions[1].oid);
 				return 1;
 			}
@@ -1623,11 +1621,11 @@ static int tree_content_set(
 	if (*slash1) {
 		e-&gt;tree = new_tree_content(8);
 		e-&gt;versions[1].mode = S_IFDIR;
-		tree_content_set(e, slash1 + 1, sha1, mode, subtree);
+		tree_content_set(e, slash1 + 1, oid, mode, subtree);
 	} else {
 		e-&gt;tree = subtree;
 		e-&gt;versions[1].mode = mode;
-		hashcpy(e-&gt;versions[1].oid.hash, sha1);
+		oidcpy(&amp;e-&gt;versions[1].oid, oid);
 	}
 	oidclr(&amp;root-&gt;versions[1].oid);
 	return 1;
@@ -1750,7 +1748,7 @@ static int update_branch(struct branch *b)
 {
 	static const char *msg = "fast-import";
 	struct ref_transaction *transaction;
-	unsigned char old_sha1[20];
+	struct object_id old_oid;
 	struct strbuf err = STRBUF_INIT;
 
 	if (is_null_oid(&amp;b-&gt;oid)) {
@@ -1758,12 +1756,12 @@ static int update_branch(struct branch *b)
 			delete_ref(NULL, b-&gt;name, NULL, 0);
 		return 0;
 	}
-	if (read_ref(b-&gt;name, old_sha1))
-		hashclr(old_sha1);
-	if (!force_update &amp;&amp; !is_null_sha1(old_sha1)) {
+	if (read_ref(b-&gt;name, old_oid.hash))
+		oidclr(&amp;old_oid);
+	if (!force_update &amp;&amp; !is_null_oid(&amp;old_oid)) {
 		struct commit *old_cmit, *new_cmit;
 
-		old_cmit = lookup_commit_reference_gently(old_sha1, 0);
+		old_cmit = lookup_commit_reference_gently(old_oid.hash, 0);
 		new_cmit = lookup_commit_reference_gently(b-&gt;oid.hash, 0);
 		if (!old_cmit || !new_cmit)
 			return error("Branch %s is missing commits.", b-&gt;name);
@@ -1772,13 +1770,13 @@ static int update_branch(struct branch *b)
 			warning("Not updating %s"
 				" (new tip %s does not contain %s)",
 				b-&gt;name, oid_to_hex(&amp;b-&gt;oid),
-				sha1_to_hex(old_sha1));
+				oid_to_hex(&amp;old_oid));
 			return -1;
 		}
 	}
 	transaction = ref_transaction_begin(&amp;err);
 	if (!transaction ||
-	    ref_transaction_update(transaction, b-&gt;name, b-&gt;oid.hash, old_sha1,
+	    ref_transaction_update(transaction, b-&gt;name, b-&gt;oid.hash, old_oid.hash,
 				   0, msg, &amp;err) ||
 	    ref_transaction_commit(transaction, &amp;err)) {
 		ref_transaction_free(transaction);
@@ -1898,7 +1896,7 @@ static void read_marks(void)
 	while (fgets(line, sizeof(line), f)) {
 		uintmax_t mark;
 		char *end;
-		unsigned char sha1[20];
+		struct object_id oid;
 		struct object_entry *e;
 
 		end = strchr(line, '\n');
@@ -1907,14 +1905,14 @@ static void read_marks(void)
 		*end = 0;
 		mark = strtoumax(line + 1, &amp;end, 10);
 		if (!mark || end == line + 1
-			|| *end != ' ' || get_sha1_hex(end + 1, sha1))
+			|| *end != ' ' || get_oid_hex(end + 1, &amp;oid))
 			die("corrupt mark line: %s", line);
-		e = find_object(sha1);
+		e = find_object(&amp;oid);
 		if (!e) {
-			enum object_type type = sha1_object_info(sha1, NULL);
+			enum object_type type = sha1_object_info(oid.hash, NULL);
 			if (type &lt; 0)
-				die("object not found: %s", sha1_to_hex(sha1));
-			e = insert_object(sha1);
+				die("object not found: %s", oid_to_hex(&amp;oid));
+			e = insert_object(&amp;oid);
 			e-&gt;type = type;
 			e-&gt;pack_id = MAX_PACK_ID;
 			e-&gt;idx.offset = 1; /* just not zero! */
@@ -2122,21 +2120,21 @@ static char *parse_ident(const char *buf)
 
 static void parse_and_store_blob(
 	struct last_object *last,
-	unsigned char *sha1out,
+	struct object_id *oidout,
 	uintmax_t mark)
 {
 	static struct strbuf buf = STRBUF_INIT;
 	uintmax_t len;
 
 	if (parse_data(&amp;buf, big_file_threshold, &amp;len))
-		store_object(OBJ_BLOB, &amp;buf, last, sha1out, mark);
+		store_object(OBJ_BLOB, &amp;buf, last, oidout, mark);
 	else {
 		if (last) {
 			strbuf_release(&amp;last-&gt;data);
 			last-&gt;offset = 0;
 			last-&gt;depth = 0;
 		}
-		stream_blob(len, sha1out, mark);
+		stream_blob(len, oidout, mark);
 		skip_optional_lf();
 	}
 }
@@ -2212,21 +2210,21 @@ static void construct_path_with_fanout(const char *hex_sha1,
 		path[i++] = '/';
 		fanout--;
 	}
-	memcpy(path + i, hex_sha1 + j, 40 - j);
-	path[i + 40 - j] = '\0';
+	memcpy(path + i, hex_sha1 + j, GIT_SHA1_HEXSZ - j);
+	path[i + GIT_SHA1_HEXSZ - j] = '\0';
 }
 
 static uintmax_t do_change_note_fanout(
 		struct tree_entry *orig_root, struct tree_entry *root,
-		char *hex_sha1, unsigned int hex_sha1_len,
+		char *hex_oid, unsigned int hex_oid_len,
 		char *fullpath, unsigned int fullpath_len,
 		unsigned char fanout)
 {
 	struct tree_content *t;
 	struct tree_entry *e, leaf;
-	unsigned int i, tmp_hex_sha1_len, tmp_fullpath_len;
+	unsigned int i, tmp_hex_oid_len, tmp_fullpath_len;
 	uintmax_t num_notes = 0;
-	unsigned char sha1[20];
+	struct object_id oid;
 	char realpath[60];
 
 	if (!root-&gt;tree)
@@ -2235,7 +2233,7 @@ static uintmax_t do_change_note_fanout(
 
 	for (i = 0; t &amp;&amp; i &lt; t-&gt;entry_count; i++) {
 		e = t-&gt;entries[i];
-		tmp_hex_sha1_len = hex_sha1_len + e-&gt;name-&gt;str_len;
+		tmp_hex_oid_len = hex_oid_len + e-&gt;name-&gt;str_len;
 		tmp_fullpath_len = fullpath_len;
 
 		/*
@@ -2247,12 +2245,12 @@ static uintmax_t do_change_note_fanout(
 		 * of 2 chars.
 		 */
 		if (!e-&gt;versions[1].mode ||
-		    tmp_hex_sha1_len &gt; 40 ||
+		    tmp_hex_oid_len &gt; GIT_SHA1_HEXSZ ||
 		    e-&gt;name-&gt;str_len % 2)
 			continue;
 
 		/* This _may_ be a note entry, or a subdir containing notes */
-		memcpy(hex_sha1 + hex_sha1_len, e-&gt;name-&gt;str_dat,
+		memcpy(hex_oid + hex_oid_len, e-&gt;name-&gt;str_dat,
 		       e-&gt;name-&gt;str_len);
 		if (tmp_fullpath_len)
 			fullpath[tmp_fullpath_len++] = '/';
@@ -2261,14 +2259,14 @@ static uintmax_t do_change_note_fanout(
 		tmp_fullpath_len += e-&gt;name-&gt;str_len;
 		fullpath[tmp_fullpath_len] = '\0';
 
-		if (tmp_hex_sha1_len == 40 &amp;&amp; !get_sha1_hex(hex_sha1, sha1)) {
+		if (tmp_hex_oid_len == GIT_SHA1_HEXSZ &amp;&amp; !get_oid_hex(hex_oid, &amp;oid)) {
 			/* This is a note entry */
 			if (fanout == 0xff) {
 				/* Counting mode, no rename */
 				num_notes++;
 				continue;
 			}
-			construct_path_with_fanout(hex_sha1, fanout, realpath);
+			construct_path_with_fanout(hex_oid, fanout, realpath);
 			if (!strcmp(fullpath, realpath)) {
 				/* Note entry is in correct location */
 				num_notes++;
@@ -2279,13 +2277,13 @@ static uintmax_t do_change_note_fanout(
 			if (!tree_content_remove(orig_root, fullpath, &amp;leaf, 0))
 				die("Failed to remove path %s", fullpath);
 			tree_content_set(orig_root, realpath,
-				leaf.versions[1].oid.hash,
+				&amp;leaf.versions[1].oid,
 				leaf.versions[1].mode,
 				leaf.tree);
 		} else if (S_ISDIR(e-&gt;versions[1].mode)) {
 			/* This is a subdir that may contain note entries */
 			num_notes += do_change_note_fanout(orig_root, e,
-				hex_sha1, tmp_hex_sha1_len,
+				hex_oid, tmp_hex_oid_len,
 				fullpath, tmp_fullpath_len, fanout);
 		}
 
@@ -2298,8 +2296,12 @@ static uintmax_t do_change_note_fanout(
 static uintmax_t change_note_fanout(struct tree_entry *root,
 		unsigned char fanout)
 {
-	char hex_sha1[40], path[60];
-	return do_change_note_fanout(root, root, hex_sha1, 0, path, 0, fanout);
+	/*
+	 * The size of path is due to one slash between every two hex digits,
+	 * plus the terminating NUL.
+	 */
+	char hex_oid[GIT_MAX_HEXSZ], path[GIT_MAX_HEXSZ * 3 / 2];
+	return do_change_note_fanout(root, root, hex_oid, 0, path, 0, fanout);
 }
 
 /*
@@ -2360,7 +2362,7 @@ static void file_change_m(const char *p, struct branch *b)
 	static struct strbuf uq = STRBUF_INIT;
 	const char *endp;
 	struct object_entry *oe;
-	unsigned char sha1[20];
+	struct object_id oid;
 	uint16_t mode, inline_data = 0;
 
 	p = get_mode(p, &amp;mode);
@@ -2383,15 +2385,14 @@ static void file_change_m(const char *p, struct branch *b)
 
 	if (*p == ':') {
 		oe = find_mark(parse_mark_ref_space(&amp;p));
-		hashcpy(sha1, oe-&gt;idx.sha1);
+		hashcpy(oid.hash, oe-&gt;idx.sha1);
 	} else if (skip_prefix(p, "inline ", &amp;p)) {
 		inline_data = 1;
 		oe = NULL; /* not used with inline_data, but makes gcc happy */
 	} else {
-		if (get_sha1_hex(p, sha1))
+		if (parse_oid_hex(p, &amp;oid, &amp;p))
 			die("Invalid dataref: %s", command_buf.buf);
-		oe = find_object(sha1);
-		p += 40;
+		oe = find_object(&amp;oid);
 		if (*p++ != ' ')
 			die("Missing space after SHA1: %s", command_buf.buf);
 	}
@@ -2404,7 +2405,7 @@ static void file_change_m(const char *p, struct branch *b)
 	}
 
 	/* Git does not track empty, non-toplevel directories. */
-	if (S_ISDIR(mode) &amp;&amp; !hashcmp(sha1, EMPTY_TREE_SHA1_BIN) &amp;&amp; *p) {
+	if (S_ISDIR(mode) &amp;&amp; is_empty_tree_oid(&amp;oid) &amp;&amp; *p) {
 		tree_content_remove(&amp;b-&gt;branch_tree, p, NULL, 0);
 		return;
 	}
@@ -2431,12 +2432,12 @@ static void file_change_m(const char *p, struct branch *b)
 			p = uq.buf;
 		}
 		read_next_command();
-		parse_and_store_blob(&amp;last_blob, sha1, 0);
+		parse_and_store_blob(&amp;last_blob, &amp;oid, 0);
 	} else {
 		enum object_type expected = S_ISDIR(mode) ?
 						OBJ_TREE: OBJ_BLOB;
 		enum object_type type = oe ? oe-&gt;type :
-					sha1_object_info(sha1, NULL);
+					sha1_object_info(oid.hash, NULL);
 		if (type &lt; 0)
 			die("%s not found: %s",
 					S_ISDIR(mode) ?  "Tree" : "Blob",
@@ -2448,10 +2449,10 @@ static void file_change_m(const char *p, struct branch *b)
 	}
 
 	if (!*p) {
-		tree_content_replace(&amp;b-&gt;branch_tree, sha1, mode, NULL);
+		tree_content_replace(&amp;b-&gt;branch_tree, &amp;oid, mode, NULL);
 		return;
 	}
-	tree_content_set(&amp;b-&gt;branch_tree, p, sha1, mode, NULL);
+	tree_content_set(&amp;b-&gt;branch_tree, p, &amp;oid, mode, NULL);
 }
 
 static void file_change_d(const char *p, struct branch *b)
@@ -2509,13 +2510,13 @@ static void file_change_cr(const char *s, struct branch *b, int rename)
 		die("Path %s not in branch", s);
 	if (!*d) {	/* C "path/to/subdir" "" */
 		tree_content_replace(&amp;b-&gt;branch_tree,
-			leaf.versions[1].oid.hash,
+			&amp;leaf.versions[1].oid,
 			leaf.versions[1].mode,
 			leaf.tree);
 		return;
 	}
 	tree_content_set(&amp;b-&gt;branch_tree, d,
-		leaf.versions[1].oid.hash,
+		&amp;leaf.versions[1].oid,
 		leaf.versions[1].mode,
 		leaf.tree);
 }
@@ -2525,7 +2526,7 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	static struct strbuf uq = STRBUF_INIT;
 	struct object_entry *oe;
 	struct branch *s;
-	unsigned char sha1[20], commit_sha1[20];
+	struct object_id oid, commit_oid;
 	char path[60];
 	uint16_t inline_data = 0;
 	unsigned char new_fanout;
@@ -2550,15 +2551,14 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	/* &lt;dataref&gt; or 'inline' */
 	if (*p == ':') {
 		oe = find_mark(parse_mark_ref_space(&amp;p));
-		hashcpy(sha1, oe-&gt;idx.sha1);
+		hashcpy(oid.hash, oe-&gt;idx.sha1);
 	} else if (skip_prefix(p, "inline ", &amp;p)) {
 		inline_data = 1;
 		oe = NULL; /* not used with inline_data, but makes gcc happy */
 	} else {
-		if (get_sha1_hex(p, sha1))
+		if (parse_oid_hex(p, &amp;oid, &amp;p))
 			die("Invalid dataref: %s", command_buf.buf);
-		oe = find_object(sha1);
-		p += 40;
+		oe = find_object(&amp;oid);
 		if (*p++ != ' ')
 			die("Missing space after SHA1: %s", command_buf.buf);
 	}
@@ -2568,17 +2568,17 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	if (s) {
 		if (is_null_oid(&amp;s-&gt;oid))
 			die("Can't add a note on empty branch.");
-		hashcpy(commit_sha1, s-&gt;oid.hash);
+		oidcpy(&amp;commit_oid, &amp;s-&gt;oid);
 	} else if (*p == ':') {
 		uintmax_t commit_mark = parse_mark_ref_eol(p);
 		struct object_entry *commit_oe = find_mark(commit_mark);
 		if (commit_oe-&gt;type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", commit_mark);
-		hashcpy(commit_sha1, commit_oe-&gt;idx.sha1);
-	} else if (!get_sha1(p, commit_sha1)) {
+		hashcpy(commit_oid.hash, commit_oe-&gt;idx.sha1);
+	} else if (!get_oid(p, &amp;commit_oid)) {
 		unsigned long size;
-		char *buf = read_object_with_reference(commit_sha1,
-			commit_type, &amp;size, commit_sha1);
+		char *buf = read_object_with_reference(commit_oid.hash,
+			commit_type, &amp;size, commit_oid.hash);
 		if (!buf || size &lt; 46)
 			die("Not a valid commit: %s", p);
 		free(buf);
@@ -2591,13 +2591,13 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 			p = uq.buf;
 		}
 		read_next_command();
-		parse_and_store_blob(&amp;last_blob, sha1, 0);
+		parse_and_store_blob(&amp;last_blob, &amp;oid, 0);
 	} else if (oe) {
 		if (oe-&gt;type != OBJ_BLOB)
 			die("Not a blob (actually a %s): %s",
 				typename(oe-&gt;type), command_buf.buf);
-	} else if (!is_null_sha1(sha1)) {
-		enum object_type type = sha1_object_info(sha1, NULL);
+	} else if (!is_null_oid(&amp;oid)) {
+		enum object_type type = sha1_object_info(oid.hash, NULL);
 		if (type &lt; 0)
 			die("Blob not found: %s", command_buf.buf);
 		if (type != OBJ_BLOB)
@@ -2605,17 +2605,17 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 			    typename(type), command_buf.buf);
 	}
 
-	construct_path_with_fanout(sha1_to_hex(commit_sha1), *old_fanout, path);
+	construct_path_with_fanout(oid_to_hex(&amp;commit_oid), *old_fanout, path);
 	if (tree_content_remove(&amp;b-&gt;branch_tree, path, NULL, 0))
 		b-&gt;num_notes--;
 
-	if (is_null_sha1(sha1))
+	if (is_null_oid(&amp;oid))
 		return; /* nothing to insert */
 
 	b-&gt;num_notes++;
 	new_fanout = convert_num_notes_to_fanout(b-&gt;num_notes);
-	construct_path_with_fanout(sha1_to_hex(commit_sha1), new_fanout, path);
-	tree_content_set(&amp;b-&gt;branch_tree, path, sha1, S_IFREG | 0644, NULL);
+	construct_path_with_fanout(oid_to_hex(&amp;commit_oid), new_fanout, path);
+	tree_content_set(&amp;b-&gt;branch_tree, path, &amp;oid, S_IFREG | 0644, NULL);
 }
 
 static void file_change_deleteall(struct branch *b)
@@ -2629,10 +2629,10 @@ static void file_change_deleteall(struct branch *b)
 
 static void parse_from_commit(struct branch *b, char *buf, unsigned long size)
 {
-	if (!buf || size &lt; 46)
+	if (!buf || size &lt; GIT_SHA1_HEXSZ + 6)
 		die("Not a valid commit: %s", oid_to_hex(&amp;b-&gt;oid));
 	if (memcmp("tree ", buf, 5)
-		|| get_sha1_hex(buf + 5, b-&gt;branch_tree.versions[1].oid.hash))
+		|| get_oid_hex(buf + 5, &amp;b-&gt;branch_tree.versions[1].oid))
 		die("The commit %s is corrupt", oid_to_hex(&amp;b-&gt;oid));
 	oidcpy(&amp;b-&gt;branch_tree.versions[0].oid,
 	       &amp;b-&gt;branch_tree.versions[1].oid);
@@ -2659,21 +2659,21 @@ static int parse_from(struct branch *b)
 {
 	const char *from;
 	struct branch *s;
-	unsigned char sha1[20];
+	struct object_id oid;
 
 	if (!skip_prefix(command_buf.buf, "from ", &amp;from))
 		return 0;
 
-	hashcpy(sha1, b-&gt;branch_tree.versions[1].oid.hash);
+	oidcpy(&amp;oid, &amp;b-&gt;branch_tree.versions[1].oid);
 
 	s = lookup_branch(from);
 	if (b == s)
 		die("Can't create a branch from itself: %s", b-&gt;name);
 	else if (s) {
-		unsigned char *t = s-&gt;branch_tree.versions[1].oid.hash;
+		struct object_id *t = &amp;s-&gt;branch_tree.versions[1].oid;
 		oidcpy(&amp;b-&gt;oid, &amp;s-&gt;oid);
-		hashcpy(b-&gt;branch_tree.versions[0].oid.hash, t);
-		hashcpy(b-&gt;branch_tree.versions[1].oid.hash, t);
+		oidcpy(&amp;b-&gt;branch_tree.versions[0].oid, t);
+		oidcpy(&amp;b-&gt;branch_tree.versions[1].oid, t);
 	} else if (*from == ':') {
 		uintmax_t idnum = parse_mark_ref_eol(from);
 		struct object_entry *oe = find_mark(idnum);
@@ -2689,7 +2689,7 @@ static int parse_from(struct branch *b)
 			} else
 				parse_from_existing(b);
 		}
-	} else if (!get_sha1(from, b-&gt;oid.hash)) {
+	} else if (!get_oid(from, &amp;b-&gt;oid)) {
 		parse_from_existing(b);
 		if (is_null_oid(&amp;b-&gt;oid))
 			b-&gt;delete = 1;
@@ -2697,7 +2697,7 @@ static int parse_from(struct branch *b)
 	else
 		die("Invalid ref name or SHA1 expression: %s", from);
 
-	if (b-&gt;branch_tree.tree &amp;&amp; hashcmp(sha1, b-&gt;branch_tree.versions[1].oid.hash)) {
+	if (b-&gt;branch_tree.tree &amp;&amp; oidcmp(&amp;oid, &amp;b-&gt;branch_tree.versions[1].oid)) {
 		release_tree_content_recursive(b-&gt;branch_tree.tree);
 		b-&gt;branch_tree.tree = NULL;
 	}
@@ -2724,12 +2724,10 @@ static struct hash_list *parse_merge(unsigned int *count)
 			if (oe-&gt;type != OBJ_COMMIT)
 				die("Mark :%" PRIuMAX " not a commit", idnum);
 			hashcpy(n-&gt;oid.hash, oe-&gt;idx.sha1);
-		} else if (!get_sha1(from, n-&gt;oid.hash)) {
+		} else if (!get_oid(from, &amp;n-&gt;oid)) {
 			unsigned long size;
 			char *buf = read_object_with_reference(n-&gt;oid.hash,
-							       commit_type,
-							       &amp;size,
-							       n-&gt;oid.hash);
+				commit_type, &amp;size, n-&gt;oid.hash);
 			if (!buf || size &lt; 46)
 				die("Not a valid commit: %s", from);
 			free(buf);
@@ -2841,7 +2839,7 @@ static void parse_new_commit(const char *arg)
 	free(author);
 	free(committer);
 
-	if (!store_object(OBJ_COMMIT, &amp;new_data, NULL, b-&gt;oid.hash, next_mark))
+	if (!store_object(OBJ_COMMIT, &amp;new_data, NULL, &amp;b-&gt;oid, next_mark))
 		b-&gt;pack_id = pack_id;
 	b-&gt;last_commit = object_count_by_type[OBJ_COMMIT];
 }
@@ -2854,7 +2852,7 @@ static void parse_new_tag(const char *arg)
 	struct branch *s;
 	struct tag *t;
 	uintmax_t from_mark = 0;
-	unsigned char sha1[20];
+	struct object_id oid;
 	enum object_type type;
 	const char *v;
 
@@ -2875,18 +2873,18 @@ static void parse_new_tag(const char *arg)
 	if (s) {
 		if (is_null_oid(&amp;s-&gt;oid))
 			die("Can't tag an empty branch.");
-		hashcpy(sha1, s-&gt;oid.hash);
+		oidcpy(&amp;oid, &amp;s-&gt;oid);
 		type = OBJ_COMMIT;
 	} else if (*from == ':') {
 		struct object_entry *oe;
 		from_mark = parse_mark_ref_eol(from);
 		oe = find_mark(from_mark);
 		type = oe-&gt;type;
-		hashcpy(sha1, oe-&gt;idx.sha1);
-	} else if (!get_sha1(from, sha1)) {
-		struct object_entry *oe = find_object(sha1);
+		hashcpy(oid.hash, oe-&gt;idx.sha1);
+	} else if (!get_oid(from, &amp;oid)) {
+		struct object_entry *oe = find_object(&amp;oid);
 		if (!oe) {
-			type = sha1_object_info(sha1, NULL);
+			type = sha1_object_info(oid.hash, NULL);
 			if (type &lt; 0)
 				die("Not a valid object: %s", from);
 		} else
@@ -2912,7 +2910,7 @@ static void parse_new_tag(const char *arg)
 		    "object %s\n"
 		    "type %s\n"
 		    "tag %s\n",
-		    sha1_to_hex(sha1), typename(type), t-&gt;name);
+		    oid_to_hex(&amp;oid), typename(type), t-&gt;name);
 	if (tagger)
 		strbuf_addf(&amp;new_data,
 			    "tagger %s\n", tagger);
@@ -2920,7 +2918,7 @@ static void parse_new_tag(const char *arg)
 	strbuf_addbuf(&amp;new_data, &amp;msg);
 	free(tagger);
 
-	if (store_object(OBJ_TAG, &amp;new_data, NULL, t-&gt;oid.hash, 0))
+	if (store_object(OBJ_TAG, &amp;new_data, NULL, &amp;t-&gt;oid, 0))
 		t-&gt;pack_id = MAX_PACK_ID;
 	else
 		t-&gt;pack_id = pack_id;
@@ -2954,7 +2952,7 @@ static void cat_blob_write(const char *buf, unsigned long size)
 		die_errno("Write to frontend failed");
 }
 
-static void cat_blob(struct object_entry *oe, unsigned char sha1[20])
+static void cat_blob(struct object_entry *oe, struct object_id *oid)
 {
 	struct strbuf line = STRBUF_INIT;
 	unsigned long size;
@@ -2962,7 +2960,7 @@ static void cat_blob(struct object_entry *oe, unsigned char sha1[20])
 	char *buf;
 
 	if (!oe || oe-&gt;pack_id == MAX_PACK_ID) {
-		buf = read_sha1_file(sha1, &amp;type, &amp;size);
+		buf = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
 	} else {
 		type = oe-&gt;type;
 		buf = gfi_unpack_entry(oe, &amp;size);
@@ -2973,19 +2971,19 @@ static void cat_blob(struct object_entry *oe, unsigned char sha1[20])
 	 */
 	if (type &lt;= 0) {
 		strbuf_reset(&amp;line);
-		strbuf_addf(&amp;line, "%s missing\n", sha1_to_hex(sha1));
+		strbuf_addf(&amp;line, "%s missing\n", oid_to_hex(oid));
 		cat_blob_write(line.buf, line.len);
 		strbuf_release(&amp;line);
 		free(buf);
 		return;
 	}
 	if (!buf)
-		die("Can't read object %s", sha1_to_hex(sha1));
+		die("Can't read object %s", oid_to_hex(oid));
 	if (type != OBJ_BLOB)
 		die("Object %s is a %s but a blob was expected.",
-		    sha1_to_hex(sha1), typename(type));
+		    oid_to_hex(oid), typename(type));
 	strbuf_reset(&amp;line);
-	strbuf_addf(&amp;line, "%s %s %lu\n", sha1_to_hex(sha1),
+	strbuf_addf(&amp;line, "%s %s %lu\n", oid_to_hex(oid),
 						typename(type), size);
 	cat_blob_write(line.buf, line.len);
 	strbuf_release(&amp;line);
@@ -3002,7 +3000,7 @@ static void cat_blob(struct object_entry *oe, unsigned char sha1[20])
 static void parse_get_mark(const char *p)
 {
 	struct object_entry *oe = oe;
-	char output[42];
+	char output[GIT_MAX_HEXSZ + 2];
 
 	/* get-mark SP &lt;object&gt; LF */
 	if (*p != ':')
@@ -3013,42 +3011,42 @@ static void parse_get_mark(const char *p)
 		die("Unknown mark: %s", command_buf.buf);
 
 	xsnprintf(output, sizeof(output), "%s\n", sha1_to_hex(oe-&gt;idx.sha1));
-	cat_blob_write(output, 41);
+	cat_blob_write(output, GIT_SHA1_HEXSZ + 1);
 }
 
 static void parse_cat_blob(const char *p)
 {
 	struct object_entry *oe = oe;
-	unsigned char sha1[20];
+	struct object_id oid;
 
 	/* cat-blob SP &lt;object&gt; LF */
 	if (*p == ':') {
 		oe = find_mark(parse_mark_ref_eol(p));
 		if (!oe)
 			die("Unknown mark: %s", command_buf.buf);
-		hashcpy(sha1, oe-&gt;idx.sha1);
+		hashcpy(oid.hash, oe-&gt;idx.sha1);
 	} else {
-		if (get_sha1_hex(p, sha1))
+		if (parse_oid_hex(p, &amp;oid, &amp;p))
 			die("Invalid dataref: %s", command_buf.buf);
-		if (p[40])
+		if (*p)
 			die("Garbage after SHA1: %s", command_buf.buf);
-		oe = find_object(sha1);
+		oe = find_object(&amp;oid);
 	}
 
-	cat_blob(oe, sha1);
+	cat_blob(oe, &amp;oid);
 }
 
 static struct object_entry *dereference(struct object_entry *oe,
-					unsigned char sha1[20])
+					struct object_id *oid)
 {
 	unsigned long size;
 	char *buf = NULL;
 	if (!oe) {
-		enum object_type type = sha1_object_info(sha1, NULL);
+		enum object_type type = sha1_object_info(oid-&gt;hash, NULL);
 		if (type &lt; 0)
-			die("object not found: %s", sha1_to_hex(sha1));
+			die("object not found: %s", oid_to_hex(oid));
 		/* cache it! */
-		oe = insert_object(sha1);
+		oe = insert_object(oid);
 		oe-&gt;type = type;
 		oe-&gt;pack_id = MAX_PACK_ID;
 		oe-&gt;idx.offset = 1;
@@ -3067,49 +3065,48 @@ static struct object_entry *dereference(struct object_entry *oe,
 		buf = gfi_unpack_entry(oe, &amp;size);
 	} else {
 		enum object_type unused;
-		buf = read_sha1_file(sha1, &amp;unused, &amp;size);
+		buf = read_sha1_file(oid-&gt;hash, &amp;unused, &amp;size);
 	}
 	if (!buf)
-		die("Can't load object %s", sha1_to_hex(sha1));
+		die("Can't load object %s", oid_to_hex(oid));
 
 	/* Peel one layer. */
 	switch (oe-&gt;type) {
 	case OBJ_TAG:
-		if (size &lt; 40 + strlen("object ") ||
-		    get_sha1_hex(buf + strlen("object "), sha1))
+		if (size &lt; GIT_SHA1_HEXSZ + strlen("object ") ||
+		    get_oid_hex(buf + strlen("object "), oid))
 			die("Invalid SHA1 in tag: %s", command_buf.buf);
 		break;
 	case OBJ_COMMIT:
-		if (size &lt; 40 + strlen("tree ") ||
-		    get_sha1_hex(buf + strlen("tree "), sha1))
+		if (size &lt; GIT_SHA1_HEXSZ + strlen("tree ") ||
+		    get_oid_hex(buf + strlen("tree "), oid))
 			die("Invalid SHA1 in commit: %s", command_buf.buf);
 	}
 
 	free(buf);
-	return find_object(sha1);
+	return find_object(oid);
 }
 
 static struct object_entry *parse_treeish_dataref(const char **p)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct object_entry *e;
 
 	if (**p == ':') {	/* &lt;mark&gt; */
 		e = find_mark(parse_mark_ref_space(p));
 		if (!e)
 			die("Unknown mark: %s", command_buf.buf);
-		hashcpy(sha1, e-&gt;idx.sha1);
+		hashcpy(oid.hash, e-&gt;idx.sha1);
 	} else {	/* &lt;sha1&gt; */
-		if (get_sha1_hex(*p, sha1))
+		if (parse_oid_hex(*p, &amp;oid, p))
 			die("Invalid dataref: %s", command_buf.buf);
-		e = find_object(sha1);
-		*p += 40;
+		e = find_object(&amp;oid);
 		if (*(*p)++ != ' ')
 			die("Missing space after tree-ish: %s", command_buf.buf);
 	}
 
 	while (!e || e-&gt;type != OBJ_TREE)
-		e = dereference(e, sha1);
+		e = dereference(e, &amp;oid);
 	return e;
 }
 

<a href="#m8814834573a2c203c0ac5b61e7511c9cf7f29af8" id="e8814834573a2c203c0ac5b61e7511c9cf7f29af8">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-12-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8814834573a2c203c0ac5b61e7511c9cf7f29af8">52+ messages in thread</a></pre><hr><pre><a href="#ec36780c4224c14bded80f8b7f2e7614a7bfa3126" id="mc36780c4224c14bded80f8b7f2e7614a7bfa3126">*</a> <b>[PATCH v2 12/53] submodule: convert merge_submodule to use struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8814834573a2c203c0ac5b61e7511c9cf7f29af8">(8 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8814834573a2c203c0ac5b61e7511c9cf7f29af8">[PATCH v2 11/53] fast-import: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mbc9f9e942bda81c08789042dcdcf43d807835ed4">[PATCH v2 13/53] notes-cache: convert to struct object_id</a> brian m. carlson
                   ` <a href="#rbc9f9e942bda81c08789042dcdcf43d807835ed4">(40 subsequent siblings)</a>
  <a href="#rc36780c4224c14bded80f8b7f2e7614a7bfa3126">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a caller of lookup_commit_reference, which we will convert
later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 merge-recursive.c |  8 ++++----
 submodule.c       | 24 ++++++++++++------------
 submodule.h       |  8 ++++----
 3 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/merge-recursive.c b/merge-recursive.c
index 9d6fd577e..1315a45b9 100644
--- a/merge-recursive.c
+++ b/merge-recursive.c
@@ -994,11 +994,11 @@ static int merge_file_1(struct merge_options *o,
 				return ret;
 			result-&gt;clean = (merge_status == 0);
 		} else if (S_ISGITLINK(a-&gt;mode)) {
-			result-&gt;clean = merge_submodule(result-&gt;oid.hash,
+			result-&gt;clean = merge_submodule(&amp;result-&gt;oid,
 						       one-&gt;path,
-						       one-&gt;oid.hash,
-						       a-&gt;oid.hash,
-						       b-&gt;oid.hash,
+						       &amp;one-&gt;oid,
+						       &amp;a-&gt;oid,
+						       &amp;b-&gt;oid,
 						       !o-&gt;call_depth);
 		} else if (S_ISLNK(a-&gt;mode)) {
 			oidcpy(&amp;result-&gt;oid, &amp;a-&gt;oid);
diff --git a/submodule.c b/submodule.c
index d3299e29c..9bdd5f605 100644
--- a/submodule.c
+++ b/submodule.c
@@ -1566,9 +1566,9 @@ static void print_commit(struct commit *commit)
 #define MERGE_WARNING(path, msg) \
 	warning("Failed to merge submodule %s (%s)", path, msg);
 
-int merge_submodule(unsigned char result[20], const char *path,
-		    const unsigned char base[20], const unsigned char a[20],
-		    const unsigned char b[20], int search)
+int merge_submodule(struct object_id *result, const char *path,
+		    const struct object_id *base, const struct object_id *a,
+		    const struct object_id *b, int search)
 {
 	struct commit *commit_base, *commit_a, *commit_b;
 	int parent_count;
@@ -1577,14 +1577,14 @@ int merge_submodule(unsigned char result[20], const char *path,
 	int i;
 
 	/* store a in result in case we fail */
-	hashcpy(result, a);
+	oidcpy(result, a);
 
 	/* we can not handle deletion conflicts */
-	if (is_null_sha1(base))
+	if (is_null_oid(base))
 		return 0;
-	if (is_null_sha1(a))
+	if (is_null_oid(a))
 		return 0;
-	if (is_null_sha1(b))
+	if (is_null_oid(b))
 		return 0;
 
 	if (add_submodule_odb(path)) {
@@ -1592,9 +1592,9 @@ int merge_submodule(unsigned char result[20], const char *path,
 		return 0;
 	}
 
-	if (!(commit_base = lookup_commit_reference(base)) ||
-	    !(commit_a = lookup_commit_reference(a)) ||
-	    !(commit_b = lookup_commit_reference(b))) {
+	if (!(commit_base = lookup_commit_reference(base-&gt;hash)) ||
+	    !(commit_a = lookup_commit_reference(a-&gt;hash)) ||
+	    !(commit_b = lookup_commit_reference(b-&gt;hash))) {
 		MERGE_WARNING(path, "commits not present");
 		return 0;
 	}
@@ -1608,11 +1608,11 @@ int merge_submodule(unsigned char result[20], const char *path,
 
 	/* Case #1: a is contained in b or vice versa */
 	if (in_merge_bases(commit_a, commit_b)) {
-		hashcpy(result, b);
+		oidcpy(result, b);
 		return 1;
 	}
 	if (in_merge_bases(commit_b, commit_a)) {
-		hashcpy(result, a);
+		oidcpy(result, a);
 		return 1;
 	}
 
diff --git a/submodule.h b/submodule.h
index 1277480ad..89c2ed219 100644
--- a/submodule.h
+++ b/submodule.h
@@ -84,10 +84,10 @@ extern int submodule_uses_gitfile(const char *path);
 #define SUBMODULE_REMOVAL_IGNORE_UNTRACKED (1&lt;&lt;1)
 #define SUBMODULE_REMOVAL_IGNORE_IGNORED_UNTRACKED (1&lt;&lt;2)
 extern int bad_to_remove_submodule(const char *path, unsigned flags);
-extern int merge_submodule(unsigned char result[20], const char *path,
-			   const unsigned char base[20],
-			   const unsigned char a[20],
-			   const unsigned char b[20], int search);
+extern int merge_submodule(struct object_id *result, const char *path,
+			   const struct object_id *base,
+			   const struct object_id *a,
+			   const struct object_id *b, int search);
 extern int find_unpushed_submodules(struct oid_array *commits,
 				    const char *remotes_name,
 				    struct string_list *needs_pushing);

<a href="#mc36780c4224c14bded80f8b7f2e7614a7bfa3126" id="ec36780c4224c14bded80f8b7f2e7614a7bfa3126">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-13-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc36780c4224c14bded80f8b7f2e7614a7bfa3126">52+ messages in thread</a></pre><hr><pre><a href="#ebc9f9e942bda81c08789042dcdcf43d807835ed4" id="mbc9f9e942bda81c08789042dcdcf43d807835ed4">*</a> <b>[PATCH v2 13/53] notes-cache: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc36780c4224c14bded80f8b7f2e7614a7bfa3126">(9 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mc36780c4224c14bded80f8b7f2e7614a7bfa3126">[PATCH v2 12/53] submodule: convert merge_submodule to use struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mc900c2480b9789e818c71dfe5d656d72a12ff11f">[PATCH v2 14/53] parse-options-cb: convert to struct object_id</a> brian m. carlson
                   ` <a href="#rc900c2480b9789e818c71dfe5d656d72a12ff11f">(39 subsequent siblings)</a>
  <a href="#rbc9f9e942bda81c08789042dcdcf43d807835ed4">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert as many instances of unsigned char [20] as possible.  Update the
callers of notes_cache_get and notes_cache_put to use the new interface.
Among the functions updated are callers of
lookup_commit_reference_gently, which we will soon convert.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 diff.c        |  4 ++--
 notes-cache.c | 29 ++++++++++++++---------------
 notes-cache.h |  4 ++--
 3 files changed, 18 insertions(+), 19 deletions(-)

diff --git a/diff.c b/diff.c
index 11eef1c85..3bd23ae4c 100644
--- a/diff.c
+++ b/diff.c
@@ -5244,7 +5244,7 @@ size_t fill_textconv(struct userdiff_driver *driver,
 
 	if (driver-&gt;textconv_cache &amp;&amp; df-&gt;oid_valid) {
 		*outbuf = notes_cache_get(driver-&gt;textconv_cache,
-					  df-&gt;oid.hash,
+					  &amp;df-&gt;oid,
 					  &amp;size);
 		if (*outbuf)
 			return size;
@@ -5256,7 +5256,7 @@ size_t fill_textconv(struct userdiff_driver *driver,
 
 	if (driver-&gt;textconv_cache &amp;&amp; df-&gt;oid_valid) {
 		/* ignore errors, as we might be in a readonly repository */
-		notes_cache_put(driver-&gt;textconv_cache, df-&gt;oid.hash, *outbuf,
+		notes_cache_put(driver-&gt;textconv_cache, &amp;df-&gt;oid, *outbuf,
 				size);
 		/*
 		 * we could save up changes and flush them all at the end,
diff --git a/notes-cache.c b/notes-cache.c
index 5dfc5cbd0..1cdd4984a 100644
--- a/notes-cache.c
+++ b/notes-cache.c
@@ -5,16 +5,16 @@
 
 static int notes_cache_match_validity(const char *ref, const char *validity)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct commit *commit;
 	struct pretty_print_context pretty_ctx;
 	struct strbuf msg = STRBUF_INIT;
 	int ret;
 
-	if (read_ref(ref, sha1) &lt; 0)
+	if (read_ref(ref, oid.hash) &lt; 0)
 		return 0;
 
-	commit = lookup_commit_reference_gently(sha1, 1);
+	commit = lookup_commit_reference_gently(oid.hash, 1);
 	if (!commit)
 		return 0;
 
@@ -46,8 +46,7 @@ void notes_cache_init(struct notes_cache *c, const char *name,
 
 int notes_cache_write(struct notes_cache *c)
 {
-	unsigned char tree_sha1[20];
-	unsigned char commit_sha1[20];
+	struct object_id tree_oid, commit_oid;
 
 	if (!c || !c-&gt;tree.initialized || !c-&gt;tree.update_ref ||
 	    !*c-&gt;tree.update_ref)
@@ -55,19 +54,19 @@ int notes_cache_write(struct notes_cache *c)
 	if (!c-&gt;tree.dirty)
 		return 0;
 
-	if (write_notes_tree(&amp;c-&gt;tree, tree_sha1))
+	if (write_notes_tree(&amp;c-&gt;tree, tree_oid.hash))
 		return -1;
-	if (commit_tree(c-&gt;validity, strlen(c-&gt;validity), tree_sha1, NULL,
-			commit_sha1, NULL, NULL) &lt; 0)
+	if (commit_tree(c-&gt;validity, strlen(c-&gt;validity), tree_oid.hash, NULL,
+			commit_oid.hash, NULL, NULL) &lt; 0)
 		return -1;
-	if (update_ref("update notes cache", c-&gt;tree.update_ref, commit_sha1,
+	if (update_ref("update notes cache", c-&gt;tree.update_ref, commit_oid.hash,
 		       NULL, 0, UPDATE_REFS_QUIET_ON_ERR) &lt; 0)
 		return -1;
 
 	return 0;
 }
 
-char *notes_cache_get(struct notes_cache *c, unsigned char key_sha1[20],
+char *notes_cache_get(struct notes_cache *c, struct object_id *key_oid,
 		      size_t *outsize)
 {
 	const unsigned char *value_sha1;
@@ -75,7 +74,7 @@ char *notes_cache_get(struct notes_cache *c, unsigned char key_sha1[20],
 	char *value;
 	unsigned long size;
 
-	value_sha1 = get_note(&amp;c-&gt;tree, key_sha1);
+	value_sha1 = get_note(&amp;c-&gt;tree, key_oid-&gt;hash);
 	if (!value_sha1)
 		return NULL;
 	value = read_sha1_file(value_sha1, &amp;type, &amp;size);
@@ -84,12 +83,12 @@ char *notes_cache_get(struct notes_cache *c, unsigned char key_sha1[20],
 	return value;
 }
 
-int notes_cache_put(struct notes_cache *c, unsigned char key_sha1[20],
+int notes_cache_put(struct notes_cache *c, struct object_id *key_oid,
 		    const char *data, size_t size)
 {
-	unsigned char value_sha1[20];
+	struct object_id value_oid;
 
-	if (write_sha1_file(data, size, "blob", value_sha1) &lt; 0)
+	if (write_sha1_file(data, size, "blob", value_oid.hash) &lt; 0)
 		return -1;
-	return add_note(&amp;c-&gt;tree, key_sha1, value_sha1, NULL);
+	return add_note(&amp;c-&gt;tree, key_oid-&gt;hash, value_oid.hash, NULL);
 }
diff --git a/notes-cache.h b/notes-cache.h
index 356f88fb3..aeeee8409 100644
--- a/notes-cache.h
+++ b/notes-cache.h
@@ -12,9 +12,9 @@ void notes_cache_init(struct notes_cache *c, const char *name,
 		     const char *validity);
 int notes_cache_write(struct notes_cache *c);
 
-char *notes_cache_get(struct notes_cache *c, unsigned char sha1[20], size_t
+char *notes_cache_get(struct notes_cache *c, struct object_id *oid, size_t
 		      *outsize);
-int notes_cache_put(struct notes_cache *c, unsigned char sha1[20],
+int notes_cache_put(struct notes_cache *c, struct object_id *oid,
 		    const char *data, size_t size);
 
 #endif /* NOTES_CACHE_H */

<a href="#mbc9f9e942bda81c08789042dcdcf43d807835ed4" id="ebc9f9e942bda81c08789042dcdcf43d807835ed4">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-14-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rbc9f9e942bda81c08789042dcdcf43d807835ed4">52+ messages in thread</a></pre><hr><pre><a href="#ec900c2480b9789e818c71dfe5d656d72a12ff11f" id="mc900c2480b9789e818c71dfe5d656d72a12ff11f">*</a> <b>[PATCH v2 14/53] parse-options-cb: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rbc9f9e942bda81c08789042dcdcf43d807835ed4">(10 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mbc9f9e942bda81c08789042dcdcf43d807835ed4">[PATCH v2 13/53] notes-cache: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mf1e5b31660971729ded825ec86b0049d0fc75b6b">[PATCH v2 15/53] reflog_expire: convert to struct object_id</a> brian m. carlson
                   ` <a href="#rf1e5b31660971729ded825ec86b0049d0fc75b6b">(38 subsequent siblings)</a>
  <a href="#rc900c2480b9789e818c71dfe5d656d72a12ff11f">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a caller of lookup_commit_reference, which we will soon convert.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 parse-options-cb.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/parse-options-cb.c b/parse-options-cb.c
index 7419780a9..35a941fdd 100644
--- a/parse-options-cb.c
+++ b/parse-options-cb.c
@@ -80,14 +80,14 @@ int parse_opt_verbosity_cb(const struct option *opt, const char *arg,
 
 int parse_opt_commits(const struct option *opt, const char *arg, int unset)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct commit *commit;
 
 	if (!arg)
 		return -1;
-	if (get_sha1(arg, sha1))
+	if (get_oid(arg, &amp;oid))
 		return error("malformed object name %s", arg);
-	commit = lookup_commit_reference(sha1);
+	commit = lookup_commit_reference(oid.hash);
 	if (!commit)
 		return error("no such commit %s", arg);
 	commit_list_insert(commit, opt-&gt;value);

<a href="#mc900c2480b9789e818c71dfe5d656d72a12ff11f" id="ec900c2480b9789e818c71dfe5d656d72a12ff11f">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-15-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc900c2480b9789e818c71dfe5d656d72a12ff11f">52+ messages in thread</a></pre><hr><pre><a href="#ef1e5b31660971729ded825ec86b0049d0fc75b6b" id="mf1e5b31660971729ded825ec86b0049d0fc75b6b">*</a> <b>[PATCH v2 15/53] reflog_expire: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc900c2480b9789e818c71dfe5d656d72a12ff11f">(11 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mc900c2480b9789e818c71dfe5d656d72a12ff11f">[PATCH v2 14/53] parse-options-cb: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m9c9208a9abcd097978a370d97042d904a47dc0d9">[PATCH v2 16/53] builtin/verify-commit: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r9c9208a9abcd097978a370d97042d904a47dc0d9">(37 subsequent siblings)</a>
  <a href="#rf1e5b31660971729ded825ec86b0049d0fc75b6b">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Adjust the callback functions to take struct object_id * instead of
unsigned char *, and modify related static functions accordingly.

Introduce a temporary object_id instance into files_reflog_expire and
copy the SHA-1 value passed in.  This is necessary because the sha1
parameter can come indirectly from get_sha1.  Without the temporary, it
would require much more refactoring to be able to convert this function.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/reflog.c     | 22 +++++++++++-----------
 refs.h               |  6 +++---
 refs/files-backend.c |  7 +++++--
 3 files changed, 19 insertions(+), 16 deletions(-)

diff --git a/builtin/reflog.c b/builtin/reflog.c
index 747277577..d6718d326 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -186,13 +186,13 @@ static int commit_is_complete(struct commit *commit)
 	return !is_incomplete;
 }
 
-static int keep_entry(struct commit **it, unsigned char *sha1)
+static int keep_entry(struct commit **it, struct object_id *oid)
 {
 	struct commit *commit;
 
-	if (is_null_sha1(sha1))
+	if (is_null_oid(oid))
 		return 1;
-	commit = lookup_commit_reference_gently(sha1, 1);
+	commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
 	if (!commit)
 		return 0;
 
@@ -251,17 +251,17 @@ static void mark_reachable(struct expire_reflog_policy_cb *cb)
 	cb-&gt;mark_list = leftover;
 }
 
-static int unreachable(struct expire_reflog_policy_cb *cb, struct commit *commit, unsigned char *sha1)
+static int unreachable(struct expire_reflog_policy_cb *cb, struct commit *commit, struct object_id *oid)
 {
 	/*
 	 * We may or may not have the commit yet - if not, look it
 	 * up using the supplied sha1.
 	 */
 	if (!commit) {
-		if (is_null_sha1(sha1))
+		if (is_null_oid(oid))
 			return 0;
 
-		commit = lookup_commit_reference_gently(sha1, 1);
+		commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
 
 		/* Not a commit -- keep it */
 		if (!commit)
@@ -283,7 +283,7 @@ static int unreachable(struct expire_reflog_policy_cb *cb, struct commit *commit
 /*
  * Return true iff the specified reflog entry should be expired.
  */
-static int should_expire_reflog_ent(unsigned char *osha1, unsigned char *nsha1,
+static int should_expire_reflog_ent(struct object_id *ooid, struct object_id *noid,
 				    const char *email, unsigned long timestamp, int tz,
 				    const char *message, void *cb_data)
 {
@@ -295,13 +295,13 @@ static int should_expire_reflog_ent(unsigned char *osha1, unsigned char *nsha1,
 
 	old = new = NULL;
 	if (cb-&gt;cmd.stalefix &amp;&amp;
-	    (!keep_entry(&amp;old, osha1) || !keep_entry(&amp;new, nsha1)))
+	    (!keep_entry(&amp;old, ooid) || !keep_entry(&amp;new, noid)))
 		return 1;
 
 	if (timestamp &lt; cb-&gt;cmd.expire_unreachable) {
 		if (cb-&gt;unreachable_expire_kind == UE_ALWAYS)
 			return 1;
-		if (unreachable(cb, old, osha1) || unreachable(cb, new, nsha1))
+		if (unreachable(cb, old, ooid) || unreachable(cb, new, noid))
 			return 1;
 	}
 
@@ -326,7 +326,7 @@ static int push_tip_to_list(const char *refname, const struct object_id *oid,
 }
 
 static void reflog_expiry_prepare(const char *refname,
-				  const unsigned char *sha1,
+				  const struct object_id *oid,
 				  void *cb_data)
 {
 	struct expire_reflog_policy_cb *cb = cb_data;
@@ -335,7 +335,7 @@ static void reflog_expiry_prepare(const char *refname,
 		cb-&gt;tip_commit = NULL;
 		cb-&gt;unreachable_expire_kind = UE_HEAD;
 	} else {
-		cb-&gt;tip_commit = lookup_commit_reference_gently(sha1, 1);
+		cb-&gt;tip_commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
 		if (!cb-&gt;tip_commit)
 			cb-&gt;unreachable_expire_kind = UE_ALWAYS;
 		else
diff --git a/refs.h b/refs.h
index 07cf4cd41..a22f696dd 100644
--- a/refs.h
+++ b/refs.h
@@ -611,10 +611,10 @@ enum expire_reflog_flags {
  *     unlocked again.
  */
 typedef void reflog_expiry_prepare_fn(const char *refname,
-				      const unsigned char *sha1,
+				      const struct object_id *oid,
 				      void *cb_data);
-typedef int reflog_expiry_should_prune_fn(unsigned char *osha1,
-					  unsigned char *nsha1,
+typedef int reflog_expiry_should_prune_fn(struct object_id *ooid,
+					  struct object_id *noid,
 					  const char *email,
 					  unsigned long timestamp, int tz,
 					  const char *message, void *cb_data);
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 83ea080e0..298a838c5 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -3207,7 +3207,7 @@ static int expire_reflog_ent(struct object_id *ooid, struct object_id *noid,
 	if (cb-&gt;flags &amp; EXPIRE_REFLOGS_REWRITE)
 		ooid = &amp;cb-&gt;last_kept_oid;
 
-	if ((*cb-&gt;should_prune_fn)(ooid-&gt;hash, noid-&gt;hash, email, timestamp, tz,
+	if ((*cb-&gt;should_prune_fn)(ooid, noid, email, timestamp, tz,
 				   message, policy_cb)) {
 		if (!cb-&gt;newlog)
 			printf("would prune %s", message);
@@ -3244,6 +3244,7 @@ static int files_reflog_expire(struct ref_store *ref_store,
 	int status = 0;
 	int type;
 	struct strbuf err = STRBUF_INIT;
+	struct object_id oid;
 
 	memset(&amp;cb, 0, sizeof(cb));
 	cb.flags = flags;
@@ -3293,7 +3294,9 @@ static int files_reflog_expire(struct ref_store *ref_store,
 		}
 	}
 
-	(*prepare_fn)(refname, sha1, cb.policy_cb);
+	hashcpy(oid.hash, sha1);
+
+	(*prepare_fn)(refname, &amp;oid, cb.policy_cb);
 	refs_for_each_reflog_ent(ref_store, refname, expire_reflog_ent, &amp;cb);
 	(*cleanup_fn)(cb.policy_cb);
 

<a href="#mf1e5b31660971729ded825ec86b0049d0fc75b6b" id="ef1e5b31660971729ded825ec86b0049d0fc75b6b">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-16-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rf1e5b31660971729ded825ec86b0049d0fc75b6b">52+ messages in thread</a></pre><hr><pre><a href="#e9c9208a9abcd097978a370d97042d904a47dc0d9" id="m9c9208a9abcd097978a370d97042d904a47dc0d9">*</a> <b>[PATCH v2 16/53] builtin/verify-commit: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rf1e5b31660971729ded825ec86b0049d0fc75b6b">(12 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mf1e5b31660971729ded825ec86b0049d0fc75b6b">[PATCH v2 15/53] reflog_expire: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">[PATCH v2 17/53] tag: convert parse_tag_buffer to struct object_id</a> brian m. carlson
                   ` <a href="#r8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">(36 subsequent siblings)</a>
  <a href="#r9c9208a9abcd097978a370d97042d904a47dc0d9">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a prerequisite to convert to lookup_commit, which we will
convert later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/verify-commit.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/builtin/verify-commit.c b/builtin/verify-commit.c
index 38bedf8f9..a5db1c427 100644
--- a/builtin/verify-commit.c
+++ b/builtin/verify-commit.c
@@ -18,14 +18,14 @@ static const char * const verify_commit_usage[] = {
 		NULL
 };
 
-static int run_gpg_verify(const unsigned char *sha1, const char *buf, unsigned long size, unsigned flags)
+static int run_gpg_verify(const struct object_id *oid, const char *buf, unsigned long size, unsigned flags)
 {
 	struct signature_check signature_check;
 	int ret;
 
 	memset(&amp;signature_check, 0, sizeof(signature_check));
 
-	ret = check_commit_signature(lookup_commit(sha1), &amp;signature_check);
+	ret = check_commit_signature(lookup_commit(oid-&gt;hash), &amp;signature_check);
 	print_signature_buffer(&amp;signature_check, flags);
 
 	signature_check_clear(&amp;signature_check);
@@ -35,22 +35,22 @@ static int run_gpg_verify(const unsigned char *sha1, const char *buf, unsigned l
 static int verify_commit(const char *name, unsigned flags)
 {
 	enum object_type type;
-	unsigned char sha1[20];
+	struct object_id oid;
 	char *buf;
 	unsigned long size;
 	int ret;
 
-	if (get_sha1(name, sha1))
+	if (get_oid(name, &amp;oid))
 		return error("commit '%s' not found.", name);
 
-	buf = read_sha1_file(sha1, &amp;type, &amp;size);
+	buf = read_sha1_file(oid.hash, &amp;type, &amp;size);
 	if (!buf)
 		return error("%s: unable to read file.", name);
 	if (type != OBJ_COMMIT)
 		return error("%s: cannot verify a non-commit object of type %s.",
 				name, typename(type));
 
-	ret = run_gpg_verify(sha1, buf, size, flags);
+	ret = run_gpg_verify(&amp;oid, buf, size, flags);
 
 	free(buf);
 	return ret;

<a href="#m9c9208a9abcd097978a370d97042d904a47dc0d9" id="e9c9208a9abcd097978a370d97042d904a47dc0d9">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-17-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r9c9208a9abcd097978a370d97042d904a47dc0d9">52+ messages in thread</a></pre><hr><pre><a href="#e8c869cf6099f85b733a5fd4e03a4c6cfd384c80f" id="m8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">*</a> <b>[PATCH v2 17/53] tag: convert parse_tag_buffer to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r9c9208a9abcd097978a370d97042d904a47dc0d9">(13 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m9c9208a9abcd097978a370d97042d904a47dc0d9">[PATCH v2 16/53] builtin/verify-commit: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mef1151106d4c86a080bd2d3e9b34d2967d6cc7ef">[PATCH v2 18/53] http-push: convert some static functions to struct object_id</a> brian m. carlson
                   ` <a href="#ref1151106d4c86a080bd2d3e9b34d2967d6cc7ef">(35 subsequent siblings)</a>
  <a href="#r8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Specify some constants in terms of GIT_SHA1_HEXSZ, and convert a
get_sha1_hex into parse_oid_hex to avoid needing to specify additional
constants.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 tag.c | 15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/tag.c b/tag.c
index 243d1fdbb..625f5cd71 100644
--- a/tag.c
+++ b/tag.c
@@ -116,7 +116,7 @@ static unsigned long parse_tag_date(const char *buf, const char *tail)
 
 int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	char type[20];
 	const char *bufptr = data;
 	const char *tail = bufptr + size;
@@ -126,11 +126,10 @@ int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 		return 0;
 	item-&gt;object.parsed = 1;
 
-	if (size &lt; 64)
+	if (size &lt; GIT_SHA1_HEXSZ + 24)
 		return -1;
-	if (memcmp("object ", bufptr, 7) || get_sha1_hex(bufptr + 7, sha1) || bufptr[47] != '\n')
+	if (memcmp("object ", bufptr, 7) || parse_oid_hex(bufptr + 7, &amp;oid, &amp;bufptr) || *bufptr++ != '\n')
 		return -1;
-	bufptr += 48; /* "object " + sha1 + "\n" */
 
 	if (!starts_with(bufptr, "type "))
 		return -1;
@@ -143,13 +142,13 @@ int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 	bufptr = nl + 1;
 
 	if (!strcmp(type, blob_type)) {
-		item-&gt;tagged = &amp;lookup_blob(sha1)-&gt;object;
+		item-&gt;tagged = &amp;lookup_blob(oid.hash)-&gt;object;
 	} else if (!strcmp(type, tree_type)) {
-		item-&gt;tagged = &amp;lookup_tree(sha1)-&gt;object;
+		item-&gt;tagged = &amp;lookup_tree(oid.hash)-&gt;object;
 	} else if (!strcmp(type, commit_type)) {
-		item-&gt;tagged = &amp;lookup_commit(sha1)-&gt;object;
+		item-&gt;tagged = &amp;lookup_commit(oid.hash)-&gt;object;
 	} else if (!strcmp(type, tag_type)) {
-		item-&gt;tagged = &amp;lookup_tag(sha1)-&gt;object;
+		item-&gt;tagged = &amp;lookup_tag(oid.hash)-&gt;object;
 	} else {
 		error("Unknown type %s", type);
 		item-&gt;tagged = NULL;

<a href="#m8c869cf6099f85b733a5fd4e03a4c6cfd384c80f" id="e8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-18-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">52+ messages in thread</a></pre><hr><pre><a href="#eef1151106d4c86a080bd2d3e9b34d2967d6cc7ef" id="mef1151106d4c86a080bd2d3e9b34d2967d6cc7ef">*</a> <b>[PATCH v2 18/53] http-push: convert some static functions to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">(14 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">[PATCH v2 17/53] tag: convert parse_tag_buffer to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mc2e019a6a423c74691c07980be20b395f185a1c0">[PATCH v2 19/53] notes-utils: convert internals to struct object_id</a> brian m. carlson
                   ` <a href="#rc2e019a6a423c74691c07980be20b395f185a1c0">(34 subsequent siblings)</a>
  <a href="#ref1151106d4c86a080bd2d3e9b34d2967d6cc7ef">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái 
Ngọc Duy

Among the functions converted is a caller of lookup_commit_or_die, which
we will convert later on.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 http-push.c | 24 ++++++++++++------------
 1 file changed, 12 insertions(+), 12 deletions(-)

diff --git a/http-push.c b/http-push.c
index f0e3108f7..f3dd0a560 100644
--- a/http-push.c
+++ b/http-push.c
@@ -1536,7 +1536,7 @@ static int remote_exists(const char *path)
 	return ret;
 }
 
-static void fetch_symref(const char *path, char **symref, unsigned char
 *sha1)
+static void fetch_symref(const char *path, char **symref, struct 
object_id *oid)
 {
 	char *url = xstrfmt("%s%s", repo-&gt;url, path);
 	struct strbuf buffer = STRBUF_INIT;
@@ -1549,7 +1549,7 @@ static void fetch_symref(const char *path, char 
**symref, unsigned char *sha1)
 
 	free(*symref);
 	*symref = NULL;
-	hashclr(sha1);
+	oidclr(oid);
 
 	if (buffer.len == 0)
 		return;
@@ -1561,15 +1561,15 @@ static void fetch_symref(const char *path, char 
**symref, unsigned char *sha1)
 	if (skip_prefix(buffer.buf, "ref: ", &amp;name)) {
 		*symref = xmemdupz(name, buffer.len - (name - buffer.buf));
 	} else {
-		get_sha1_hex(buffer.buf, sha1);
+		get_oid_hex(buffer.buf, oid);
 	}
 
 	strbuf_release(&amp;buffer);
 }
 
-static int verify_merge_base(unsigned char *head_sha1, struct ref 
*remote)
+static int verify_merge_base(struct object_id *head_oid, struct ref 
*remote)
 {
-	struct commit *head = lookup_commit_or_die(head_sha1, "HEAD");
+	struct commit *head = lookup_commit_or_die(head_oid-&gt;hash, "HEAD");
 	struct commit *branch = lookup_commit_or_die(remote-&gt;old_oid.hash, 
remote-&gt;name);
 
 	return in_merge_bases(branch, head);
@@ -1579,7 +1579,7 @@ static int delete_remote_branch(const char 
*pattern, int force)
 {
 	struct ref *refs = remote_refs;
 	struct ref *remote_ref = NULL;
-	unsigned char head_sha1[20];
+	struct object_id head_oid;
 	char *symref = NULL;
 	int match;
 	int patlen = strlen(pattern);
@@ -1610,7 +1610,7 @@ static int delete_remote_branch(const char 
*pattern, int force)
 	 * Remote HEAD must be a symref (not exactly foolproof; a remote
 	 * symlink to a symref will look like a symref)
 	 */
-	fetch_symref("HEAD", &amp;symref, head_sha1);
+	fetch_symref("HEAD", &amp;symref, &amp;head_oid);
 	if (!symref)
 		return error("Remote HEAD is not a symref");
 
@@ -1619,7 +1619,7 @@ static int delete_remote_branch(const char 
*pattern, int force)
 		if (!strcmp(remote_ref-&gt;name, symref))
 			return error("Remote branch %s is the current HEAD",
 				     remote_ref-&gt;name);
-		fetch_symref(symref, &amp;symref, head_sha1);
+		fetch_symref(symref, &amp;symref, &amp;head_oid);
 	}
 
 	/* Run extra sanity checks if delete is not forced */
@@ -1627,10 +1627,10 @@ static int delete_remote_branch(const char 
*pattern, int force)
 		/* Remote HEAD must resolve to a known object */
 		if (symref)
 			return error("Remote HEAD symrefs too deep");
-		if (is_null_sha1(head_sha1))
+		if (is_null_oid(&amp;head_oid))
 			return error("Unable to resolve remote HEAD");
-		if (!has_sha1_file(head_sha1))
-			return error("Remote HEAD resolves to object %s\nwhich does not 
exist locally, perhaps you need to fetch?", sha1_to_hex(head_sha1));
+		if (!has_object_file(&amp;head_oid))
+			return error("Remote HEAD resolves to object %s\nwhich does not 
exist locally, perhaps you need to fetch?", oid_to_hex(&amp;head_oid));
 
 		/* Remote branch must resolve to a known object */
 		if (is_null_oid(&amp;remote_ref-&gt;old_oid))
@@ -1640,7 +1640,7 @@ static int delete_remote_branch(const char 
*pattern, int force)
 			return error("Remote branch %s resolves to object %s\nwhich does not
 exist locally, perhaps you need to fetch?", remote_ref-&gt;name, 
oid_to_hex(&amp;remote_ref-&gt;old_oid));
 
 		/* Remote branch must be an ancestor of remote HEAD */
-		if (!verify_merge_base(head_sha1, remote_ref)) {
+		if (!verify_merge_base(&amp;head_oid, remote_ref)) {
 			return error("The branch '%s' is not an ancestor "
 				     "of your current HEAD.\n"
 				     "If you are sure you want to delete it,"

<a href="#mef1151106d4c86a080bd2d3e9b34d2967d6cc7ef" id="eef1151106d4c86a080bd2d3e9b34d2967d6cc7ef">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-19-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#ref1151106d4c86a080bd2d3e9b34d2967d6cc7ef">52+ messages in thread</a></pre><hr><pre><a href="#ec2e019a6a423c74691c07980be20b395f185a1c0" id="mc2e019a6a423c74691c07980be20b395f185a1c0">*</a> <b>[PATCH v2 19/53] notes-utils: convert internals to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#ref1151106d4c86a080bd2d3e9b34d2967d6cc7ef">(15 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mef1151106d4c86a080bd2d3e9b34d2967d6cc7ef">[PATCH v2 18/53] http-push: convert some static functions to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8f91994e5bedfddc142fed1122e6854d6855af5a">[PATCH v2 20/53] revision: convert prepare_show_merge to struct object_id</a> brian m. carlson
                   ` <a href="#r8f91994e5bedfddc142fed1122e6854d6855af5a">(33 subsequent siblings)</a>
  <a href="#rc2e019a6a423c74691c07980be20b395f185a1c0">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the internals of create_notes_comit and commit_notes to use
struct object_id.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 notes-utils.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/notes-utils.c b/notes-utils.c
index 24a33616a..36c1490aa 100644
--- a/notes-utils.c
+++ b/notes-utils.c
@@ -7,18 +7,18 @@ void create_notes_commit(struct notes_tree *t, struct commit_list *parents,
 			 const char *msg, size_t msg_len,
 			 unsigned char *result_sha1)
 {
-	unsigned char tree_sha1[20];
+	struct object_id tree_oid;
 
 	assert(t-&gt;initialized);
 
-	if (write_notes_tree(t, tree_sha1))
+	if (write_notes_tree(t, tree_oid.hash))
 		die("Failed to write notes tree to database");
 
 	if (!parents) {
 		/* Deduce parent commit from t-&gt;ref */
-		unsigned char parent_sha1[20];
-		if (!read_ref(t-&gt;ref, parent_sha1)) {
-			struct commit *parent = lookup_commit(parent_sha1);
+		struct object_id parent_oid;
+		if (!read_ref(t-&gt;ref, parent_oid.hash)) {
+			struct commit *parent = lookup_commit(parent_oid.hash);
 			if (parse_commit(parent))
 				die("Failed to find/parse commit %s", t-&gt;ref);
 			commit_list_insert(parent, &amp;parents);
@@ -26,14 +26,14 @@ void create_notes_commit(struct notes_tree *t, struct commit_list *parents,
 		/* else: t-&gt;ref points to nothing, assume root/orphan commit */
 	}
 
-	if (commit_tree(msg, msg_len, tree_sha1, parents, result_sha1, NULL, NULL))
+	if (commit_tree(msg, msg_len, tree_oid.hash, parents, result_sha1, NULL, NULL))
 		die("Failed to commit notes tree to database");
 }
 
 void commit_notes(struct notes_tree *t, const char *msg)
 {
 	struct strbuf buf = STRBUF_INIT;
-	unsigned char commit_sha1[20];
+	struct object_id commit_oid;
 
 	if (!t)
 		t = &amp;default_notes_tree;
@@ -46,9 +46,9 @@ void commit_notes(struct notes_tree *t, const char *msg)
 	strbuf_addstr(&amp;buf, msg);
 	strbuf_complete_line(&amp;buf);
 
-	create_notes_commit(t, NULL, buf.buf, buf.len, commit_sha1);
+	create_notes_commit(t, NULL, buf.buf, buf.len, commit_oid.hash);
 	strbuf_insert(&amp;buf, 0, "notes: ", 7); /* commit message starts at index 7 */
-	update_ref(buf.buf, t-&gt;update_ref, commit_sha1, NULL, 0,
+	update_ref(buf.buf, t-&gt;update_ref, commit_oid.hash, NULL, 0,
 		   UPDATE_REFS_DIE_ON_ERR);
 
 	strbuf_release(&amp;buf);

<a href="#mc2e019a6a423c74691c07980be20b395f185a1c0" id="ec2e019a6a423c74691c07980be20b395f185a1c0">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-20-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc2e019a6a423c74691c07980be20b395f185a1c0">52+ messages in thread</a></pre><hr><pre><a href="#e8f91994e5bedfddc142fed1122e6854d6855af5a" id="m8f91994e5bedfddc142fed1122e6854d6855af5a">*</a> <b>[PATCH v2 20/53] revision: convert prepare_show_merge to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc2e019a6a423c74691c07980be20b395f185a1c0">(16 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mc2e019a6a423c74691c07980be20b395f185a1c0">[PATCH v2 19/53] notes-utils: convert internals to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">[PATCH v2 21/53] shallow: convert shallow registration functions to object_id</a> brian m. carlson
                   ` <a href="#r2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">(32 subsequent siblings)</a>
  <a href="#r8f91994e5bedfddc142fed1122e6854d6855af5a">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a caller of lookup_commit_or_die, which we will convert later
on.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 revision.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/revision.c b/revision.c
index 2b56c3baf..945367034 100644
--- a/revision.c
+++ b/revision.c
@@ -1389,16 +1389,16 @@ static void prepare_show_merge(struct rev_info *revs)
 {
 	struct commit_list *bases;
 	struct commit *head, *other;
-	unsigned char sha1[20];
+	struct object_id oid;
 	const char **prune = NULL;
 	int i, prune_num = 1; /* counting terminating NULL */
 
-	if (get_sha1("HEAD", sha1))
+	if (get_oid("HEAD", &amp;oid))
 		die("--merge without HEAD?");
-	head = lookup_commit_or_die(sha1, "HEAD");
-	if (get_sha1("MERGE_HEAD", sha1))
+	head = lookup_commit_or_die(oid.hash, "HEAD");
+	if (get_oid("MERGE_HEAD", &amp;oid))
 		die("--merge without MERGE_HEAD?");
-	other = lookup_commit_or_die(sha1, "MERGE_HEAD");
+	other = lookup_commit_or_die(oid.hash, "MERGE_HEAD");
 	add_pending_object(revs, &amp;head-&gt;object, "HEAD");
 	add_pending_object(revs, &amp;other-&gt;object, "MERGE_HEAD");
 	bases = get_merge_bases(head, other);

<a href="#m8f91994e5bedfddc142fed1122e6854d6855af5a" id="e8f91994e5bedfddc142fed1122e6854d6855af5a">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-21-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8f91994e5bedfddc142fed1122e6854d6855af5a">52+ messages in thread</a></pre><hr><pre><a href="#e2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3" id="m2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">*</a> <b>[PATCH v2 21/53] shallow: convert shallow registration functions to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8f91994e5bedfddc142fed1122e6854d6855af5a">(17 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8f91994e5bedfddc142fed1122e6854d6855af5a">[PATCH v2 20/53] revision: convert prepare_show_merge to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m646b705faf5339ed8feb874743febcb15228488f">[PATCH v2 22/53] sequencer: convert some functions to struct object_id</a> brian m. carlson
                   ` <a href="#r646b705faf5339ed8feb874743febcb15228488f">(31 subsequent siblings)</a>
  <a href="#r2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert register_shallow and unregister_shallow to take struct
object_id.  register_shallow is a caller of lookup_commit, which we will
convert later.  It doesn't make sense for the registration and
unregistration functions to have incompatible interfaces, so convert
them both.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/pack-objects.c |  6 +++---
 builtin/receive-pack.c |  2 +-
 commit.c               |  4 ++--
 commit.h               |  4 ++--
 fetch-pack.c           |  4 ++--
 shallow.c              | 12 ++++++------
 upload-pack.c          |  8 ++++----
 7 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index 0fe35d1b5..477070806 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -2777,10 +2777,10 @@ static void get_object_list(int ac, const char **av)
 				continue;
 			}
 			if (starts_with(line, "--shallow ")) {
-				unsigned char sha1[20];
-				if (get_sha1_hex(line + 10, sha1))
+				struct object_id oid;
+				if (get_oid_hex(line + 10, &amp;oid))
 					die("not an SHA-1 '%s'", line + 10);
-				register_shallow(sha1);
+				register_shallow(&amp;oid);
 				use_bitmap_index = 0;
 				continue;
 			}
diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index f96834f42..6f0f788b0 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -858,7 +858,7 @@ static int update_shallow_ref(struct command *cmd, struct shallow_info *si)
 	 * not lose these new roots..
 	 */
 	for (i = 0; i &lt; extra.nr; i++)
-		register_shallow(extra.oid[i].hash);
+		register_shallow(&amp;extra.oid[i]);
 
 	si-&gt;shallow_ref[cmd-&gt;index] = 0;
 	oid_array_clear(&amp;extra);
diff --git a/commit.c b/commit.c
index 73c78c2b8..ec41ba5e0 100644
--- a/commit.c
+++ b/commit.c
@@ -216,9 +216,9 @@ int for_each_commit_graft(each_commit_graft_fn fn, void *cb_data)
 	return ret;
 }
 
-int unregister_shallow(const unsigned char *sha1)
+int unregister_shallow(const struct object_id *oid)
 {
-	int pos = commit_graft_pos(sha1);
+	int pos = commit_graft_pos(oid-&gt;hash);
 	if (pos &lt; 0)
 		return -1;
 	if (pos + 1 &lt; commit_graft_nr)
diff --git a/commit.h b/commit.h
index 7b1986d5c..884177b8f 100644
--- a/commit.h
+++ b/commit.h
@@ -263,8 +263,8 @@ extern struct commit_list *get_merge_bases_many_dirty(struct commit *one, int n,
 
 struct oid_array;
 struct ref;
-extern int register_shallow(const unsigned char *sha1);
-extern int unregister_shallow(const unsigned char *sha1);
+extern int register_shallow(const struct object_id *oid);
+extern int unregister_shallow(const struct object_id *oid);
 extern int for_each_commit_graft(each_commit_graft_fn, void *);
 extern int is_repository_shallow(void);
 extern struct commit_list *get_shallow_commits(struct object_array *heads,
diff --git a/fetch-pack.c b/fetch-pack.c
index b42d01f42..d455ef97a 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
@@ -417,7 +417,7 @@ static int find_common(struct fetch_pack_args *args,
 			if (skip_prefix(line, "shallow ", &amp;arg)) {
 				if (get_oid_hex(arg, &amp;oid))
 					die(_("invalid shallow line: %s"), line);
-				register_shallow(oid.hash);
+				register_shallow(&amp;oid);
 				continue;
 			}
 			if (skip_prefix(line, "unshallow ", &amp;arg)) {
@@ -428,7 +428,7 @@ static int find_common(struct fetch_pack_args *args,
 				/* make sure that it is parsed as shallow */
 				if (!parse_object(oid.hash))
 					die(_("error in object: %s"), line);
-				if (unregister_shallow(oid.hash))
+				if (unregister_shallow(&amp;oid))
 					die(_("no shallow found: %s"), line);
 				continue;
 			}
diff --git a/shallow.c b/shallow.c
index 25b6db989..c520ae3ae 100644
--- a/shallow.c
+++ b/shallow.c
@@ -27,13 +27,13 @@ void set_alternate_shallow_file(const char *path, int override)
 	alternate_shallow_file = xstrdup_or_null(path);
 }
 
-int register_shallow(const unsigned char *sha1)
+int register_shallow(const struct object_id *oid)
 {
 	struct commit_graft *graft =
 		xmalloc(sizeof(struct commit_graft));
-	struct commit *commit = lookup_commit(sha1);
+	struct commit *commit = lookup_commit(oid-&gt;hash);
 
-	hashcpy(graft-&gt;oid.hash, sha1);
+	oidcpy(&amp;graft-&gt;oid, oid);
 	graft-&gt;nr_parent = -1;
 	if (commit &amp;&amp; commit-&gt;object.parsed)
 		commit-&gt;parents = NULL;
@@ -65,10 +65,10 @@ int is_repository_shallow(void)
 	is_shallow = 1;
 
 	while (fgets(buf, sizeof(buf), fp)) {
-		unsigned char sha1[20];
-		if (get_sha1_hex(buf, sha1))
+		struct object_id oid;
+		if (get_oid_hex(buf, &amp;oid))
 			die("bad shallow line: %s", buf);
-		register_shallow(sha1);
+		register_shallow(&amp;oid);
 	}
 	fclose(fp);
 	return is_shallow;
diff --git a/upload-pack.c b/upload-pack.c
index ffb028d62..20f87cd38 100644
--- a/upload-pack.c
+++ b/upload-pack.c
@@ -642,7 +642,7 @@ static void send_shallow(struct commit_list *result)
 		if (!(object-&gt;flags &amp; (CLIENT_SHALLOW|NOT_SHALLOW))) {
 			packet_write_fmt(1, "shallow %s",
 					 oid_to_hex(&amp;object-&gt;oid));
-			register_shallow(object-&gt;oid.hash);
+			register_shallow(&amp;object-&gt;oid);
 			shallow_nr++;
 		}
 		result = result-&gt;next;
@@ -667,7 +667,7 @@ static void send_unshallow(const struct object_array *shallows)
 			 * parse and add the parents to the want list, then
 			 * re-register it.
 			 */
-			unregister_shallow(object-&gt;oid.hash);
+			unregister_shallow(&amp;object-&gt;oid);
 			object-&gt;parsed = 0;
 			parse_commit_or_die((struct commit *)object);
 			parents = ((struct commit *)object)-&gt;parents;
@@ -679,7 +679,7 @@ static void send_unshallow(const struct object_array *shallows)
 			add_object_array(object, NULL, &amp;extra_edge_obj);
 		}
 		/* make sure commit traversal conforms to client */
-		register_shallow(object-&gt;oid.hash);
+		register_shallow(&amp;object-&gt;oid);
 	}
 }
 
@@ -883,7 +883,7 @@ static void receive_needs(void)
 		if (shallows.nr &gt; 0) {
 			int i;
 			for (i = 0; i &lt; shallows.nr; i++)
-				register_shallow(shallows.objects[i].item-&gt;oid.hash);
+				register_shallow(&amp;shallows.objects[i].item-&gt;oid);
 		}
 
 	shallow_nr += shallows.nr;

<a href="#m2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3" id="e2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-22-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">52+ messages in thread</a></pre><hr><pre><a href="#e646b705faf5339ed8feb874743febcb15228488f" id="m646b705faf5339ed8feb874743febcb15228488f">*</a> <b>[PATCH v2 22/53] sequencer: convert some functions to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">(18 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">[PATCH v2 21/53] shallow: convert shallow registration functions to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m7aa9bb0875f3aefd5a7b992675a7c718f653ea61">[PATCH v2 23/53] builtin/tag: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r7aa9bb0875f3aefd5a7b992675a7c718f653ea61">(30 subsequent siblings)</a>
  <a href="#r646b705faf5339ed8feb874743febcb15228488f">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert update_squash_messages and is_index_unchanged to struct
object_id.  These are callers of lookup_commit and
lookup_commit_reference, which we want to convert.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 sequencer.c | 12 ++++++------
 1 file changed, 6 insertions(+), 6 deletions(-)

diff --git a/sequencer.c b/sequencer.c
index d119baa51..1a4729d9d 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -482,13 +482,13 @@ static int do_recursive_merge(struct commit *base, struct commit *next,
 
 static int is_index_unchanged(void)
 {
-	unsigned char head_sha1[20];
+	struct object_id head_oid;
 	struct commit *head_commit;
 
-	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_sha1, NULL))
+	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_oid.hash, NULL))
 		return error(_("could not resolve HEAD commit\n"));
 
-	head_commit = lookup_commit(head_sha1);
+	head_commit = lookup_commit(head_oid.hash);
 
 	/*
 	 * If head_commit is NULL, check_commit, called from
@@ -835,13 +835,13 @@ static int update_squash_messages(enum todo_command command,
 		strbuf_splice(&amp;buf, 0, eol - buf.buf, header.buf, header.len);
 		strbuf_release(&amp;header);
 	} else {
-		unsigned char head[20];
+		struct object_id head;
 		struct commit *head_commit;
 		const char *head_message, *body;
 
-		if (get_sha1("HEAD", head))
+		if (get_oid("HEAD", &amp;head))
 			return error(_("need a HEAD to fixup"));
-		if (!(head_commit = lookup_commit_reference(head)))
+		if (!(head_commit = lookup_commit_reference(head.hash)))
 			return error(_("could not read HEAD"));
 		if (!(head_message = get_commit_buffer(head_commit, NULL)))
 			return error(_("could not read HEAD's commit message"));

<a href="#m646b705faf5339ed8feb874743febcb15228488f" id="e646b705faf5339ed8feb874743febcb15228488f">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-23-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r646b705faf5339ed8feb874743febcb15228488f">52+ messages in thread</a></pre><hr><pre><a href="#e7aa9bb0875f3aefd5a7b992675a7c718f653ea61" id="m7aa9bb0875f3aefd5a7b992675a7c718f653ea61">*</a> <b>[PATCH v2 23/53] builtin/tag: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r646b705faf5339ed8feb874743febcb15228488f">(19 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m646b705faf5339ed8feb874743febcb15228488f">[PATCH v2 22/53] sequencer: convert some functions to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mfbb146bb18b5cbedc5e48356e1458a77bba0af11">[PATCH v2 24/53] Convert remaining callers of lookup_commit_reference* to object_id</a> brian m. carlson
                   ` <a href="#rfbb146bb18b5cbedc5e48356e1458a77bba0af11">(29 subsequent siblings)</a>
  <a href="#r7aa9bb0875f3aefd5a7b992675a7c718f653ea61">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Parts of this module call lookup_commit_reference, which we want to
convert.  The module is small and mostly self-contained, so convert the
rest of it while we're at it.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/tag.c | 66 +++++++++++++++++++++++++++++------------------------------
 1 file changed, 33 insertions(+), 33 deletions(-)

diff --git a/builtin/tag.c b/builtin/tag.c
index 222404522..597c925e3 100644
--- a/builtin/tag.c
+++ b/builtin/tag.c
@@ -66,7 +66,7 @@ static int list_tags(struct ref_filter *filter, struct ref_sorting *sorting, con
 }
 
 typedef int (*each_tag_name_fn)(const char *name, const char *ref,
-				const unsigned char *sha1, const void *cb_data);
+				const struct object_id *oid, const void *cb_data);
 
 static int for_each_tag_name(const char **argv, each_tag_name_fn fn,
 			     const void *cb_data)
@@ -74,17 +74,17 @@ static int for_each_tag_name(const char **argv, each_tag_name_fn fn,
 	const char **p;
 	struct strbuf ref = STRBUF_INIT;
 	int had_error = 0;
-	unsigned char sha1[20];
+	struct object_id oid;
 
 	for (p = argv; *p; p++) {
 		strbuf_reset(&amp;ref);
 		strbuf_addf(&amp;ref, "refs/tags/%s", *p);
-		if (read_ref(ref.buf, sha1)) {
+		if (read_ref(ref.buf, oid.hash)) {
 			error(_("tag '%s' not found."), *p);
 			had_error = 1;
 			continue;
 		}
-		if (fn(*p, ref.buf, sha1, cb_data))
+		if (fn(*p, ref.buf, &amp;oid, cb_data))
 			had_error = 1;
 	}
 	strbuf_release(&amp;ref);
@@ -92,16 +92,16 @@ static int for_each_tag_name(const char **argv, each_tag_name_fn fn,
 }
 
 static int delete_tag(const char *name, const char *ref,
-		      const unsigned char *sha1, const void *cb_data)
+		      const struct object_id *oid, const void *cb_data)
 {
-	if (delete_ref(NULL, ref, sha1, 0))
+	if (delete_ref(NULL, ref, oid-&gt;hash, 0))
 		return 1;
-	printf(_("Deleted tag '%s' (was %s)\n"), name, find_unique_abbrev(sha1, DEFAULT_ABBREV));
+	printf(_("Deleted tag '%s' (was %s)\n"), name, find_unique_abbrev(oid-&gt;hash, DEFAULT_ABBREV));
 	return 0;
 }
 
 static int verify_tag(const char *name, const char *ref,
-		      const unsigned char *sha1, const void *cb_data)
+		      const struct object_id *oid, const void *cb_data)
 {
 	int flags;
 	const char *fmt_pretty = cb_data;
@@ -110,11 +110,11 @@ static int verify_tag(const char *name, const char *ref,
 	if (fmt_pretty)
 		flags = GPG_VERIFY_OMIT_STATUS;
 
-	if (gpg_verify_tag(sha1, name, flags))
+	if (gpg_verify_tag(oid-&gt;hash, name, flags))
 		return -1;
 
 	if (fmt_pretty)
-		pretty_print_ref(name, sha1, fmt_pretty);
+		pretty_print_ref(name, oid-&gt;hash, fmt_pretty);
 
 	return 0;
 }
@@ -182,13 +182,13 @@ static int git_tag_config(const char *var, const char *value, void *cb)
 	return git_default_config(var, value, cb);
 }
 
-static void write_tag_body(int fd, const unsigned char *sha1)
+static void write_tag_body(int fd, const struct object_id *oid)
 {
 	unsigned long size;
 	enum object_type type;
 	char *buf, *sp;
 
-	buf = read_sha1_file(sha1, &amp;type, &amp;size);
+	buf = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
 	if (!buf)
 		return;
 	/* skip header */
@@ -204,11 +204,11 @@ static void write_tag_body(int fd, const unsigned char *sha1)
 	free(buf);
 }
 
-static int build_tag_object(struct strbuf *buf, int sign, unsigned char *result)
+static int build_tag_object(struct strbuf *buf, int sign, struct object_id *result)
 {
 	if (sign &amp;&amp; do_sign(buf) &lt; 0)
 		return error(_("unable to sign the tag"));
-	if (write_sha1_file(buf-&gt;buf, buf-&gt;len, tag_type, result) &lt; 0)
+	if (write_sha1_file(buf-&gt;buf, buf-&gt;len, tag_type, result-&gt;hash) &lt; 0)
 		return error(_("unable to write tag file"));
 	return 0;
 }
@@ -223,15 +223,15 @@ struct create_tag_options {
 	} cleanup_mode;
 };
 
-static void create_tag(const unsigned char *object, const char *tag,
+static void create_tag(const struct object_id *object, const char *tag,
 		       struct strbuf *buf, struct create_tag_options *opt,
-		       unsigned char *prev, unsigned char *result)
+		       struct object_id *prev, struct object_id *result)
 {
 	enum object_type type;
 	struct strbuf header = STRBUF_INIT;
 	char *path = NULL;
 
-	type = sha1_object_info(object, NULL);
+	type = sha1_object_info(object-&gt;hash, NULL);
 	if (type &lt;= OBJ_NONE)
 	    die(_("bad object type."));
 
@@ -240,7 +240,7 @@ static void create_tag(const unsigned char *object, const char *tag,
 		    "type %s\n"
 		    "tag %s\n"
 		    "tagger %s\n\n",
-		    sha1_to_hex(object),
+		    oid_to_hex(object),
 		    typename(type),
 		    tag,
 		    git_committer_info(IDENT_STRICT));
@@ -254,7 +254,7 @@ static void create_tag(const unsigned char *object, const char *tag,
 		if (fd &lt; 0)
 			die_errno(_("could not create file '%s'"), path);
 
-		if (!is_null_sha1(prev)) {
+		if (!is_null_oid(prev)) {
 			write_tag_body(fd, prev);
 		} else {
 			struct strbuf buf = STRBUF_INIT;
@@ -296,7 +296,7 @@ static void create_tag(const unsigned char *object, const char *tag,
 	}
 }
 
-static void create_reflog_msg(const unsigned char *sha1, struct strbuf *sb)
+static void create_reflog_msg(const struct object_id *oid, struct strbuf *sb)
 {
 	enum object_type type;
 	struct commit *c;
@@ -310,17 +310,17 @@ static void create_reflog_msg(const unsigned char *sha1, struct strbuf *sb)
 		strbuf_addstr(sb, rla);
 	} else {
 		strbuf_addstr(sb, _("tag: tagging "));
-		strbuf_add_unique_abbrev(sb, sha1, DEFAULT_ABBREV);
+		strbuf_add_unique_abbrev(sb, oid-&gt;hash, DEFAULT_ABBREV);
 	}
 
 	strbuf_addstr(sb, " (");
-	type = sha1_object_info(sha1, NULL);
+	type = sha1_object_info(oid-&gt;hash, NULL);
 	switch (type) {
 	default:
 		strbuf_addstr(sb, _("object of unknown type"));
 		break;
 	case OBJ_COMMIT:
-		if ((buf = read_sha1_file(sha1, &amp;type, &amp;size)) != NULL) {
+		if ((buf = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size)) != NULL) {
 			subject_len = find_commit_subject(buf, &amp;subject_start);
 			strbuf_insert(sb, sb-&gt;len, subject_start, subject_len);
 		} else {
@@ -328,7 +328,7 @@ static void create_reflog_msg(const unsigned char *sha1, struct strbuf *sb)
 		}
 		free(buf);
 
-		if ((c = lookup_commit_reference(sha1)) != NULL)
+		if ((c = lookup_commit_reference(oid-&gt;hash)) != NULL)
 			strbuf_addf(sb, ", %s", show_date(c-&gt;date, 0, DATE_MODE(SHORT)));
 		break;
 	case OBJ_TREE:
@@ -378,7 +378,7 @@ int cmd_tag(int argc, const char **argv, const char *prefix)
 	struct strbuf buf = STRBUF_INIT;
 	struct strbuf ref = STRBUF_INIT;
 	struct strbuf reflog_msg = STRBUF_INIT;
-	unsigned char object[20], prev[20];
+	struct object_id object, prev;
 	const char *object_ref, *tag;
 	struct create_tag_options opt;
 	char *cleanup_arg = NULL;
@@ -528,14 +528,14 @@ int cmd_tag(int argc, const char **argv, const char *prefix)
 	if (argc &gt; 2)
 		die(_("too many params"));
 
-	if (get_sha1(object_ref, object))
+	if (get_oid(object_ref, &amp;object))
 		die(_("Failed to resolve '%s' as a valid ref."), object_ref);
 
 	if (strbuf_check_tag_ref(&amp;ref, tag))
 		die(_("'%s' is not a valid tag name."), tag);
 
-	if (read_ref(ref.buf, prev))
-		hashclr(prev);
+	if (read_ref(ref.buf, prev.hash))
+		oidclr(&amp;prev);
 	else if (!force)
 		die(_("tag '%s' already exists"), tag);
 
@@ -550,24 +550,24 @@ int cmd_tag(int argc, const char **argv, const char *prefix)
 	else
 		die(_("Invalid cleanup mode %s"), cleanup_arg);
 
-	create_reflog_msg(object, &amp;reflog_msg);
+	create_reflog_msg(&amp;object, &amp;reflog_msg);
 
 	if (create_tag_object) {
 		if (force_sign_annotate &amp;&amp; !annotate)
 			opt.sign = 1;
-		create_tag(object, tag, &amp;buf, &amp;opt, prev, object);
+		create_tag(&amp;object, tag, &amp;buf, &amp;opt, &amp;prev, &amp;object);
 	}
 
 	transaction = ref_transaction_begin(&amp;err);
 	if (!transaction ||
-	    ref_transaction_update(transaction, ref.buf, object, prev,
+	    ref_transaction_update(transaction, ref.buf, object.hash, prev.hash,
 				   create_reflog ? REF_FORCE_CREATE_REFLOG : 0,
 				   reflog_msg.buf, &amp;err) ||
 	    ref_transaction_commit(transaction, &amp;err))
 		die("%s", err.buf);
 	ref_transaction_free(transaction);
-	if (force &amp;&amp; !is_null_sha1(prev) &amp;&amp; hashcmp(prev, object))
-		printf(_("Updated tag '%s' (was %s)\n"), tag, find_unique_abbrev(prev, DEFAULT_ABBREV));
+	if (force &amp;&amp; !is_null_oid(&amp;prev) &amp;&amp; oidcmp(&amp;prev, &amp;object))
+		printf(_("Updated tag '%s' (was %s)\n"), tag, find_unique_abbrev(prev.hash, DEFAULT_ABBREV));
 
 	strbuf_release(&amp;err);
 	strbuf_release(&amp;buf);

<a href="#m7aa9bb0875f3aefd5a7b992675a7c718f653ea61" id="e7aa9bb0875f3aefd5a7b992675a7c718f653ea61">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-24-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r7aa9bb0875f3aefd5a7b992675a7c718f653ea61">52+ messages in thread</a></pre><hr><pre><a href="#efbb146bb18b5cbedc5e48356e1458a77bba0af11" id="mfbb146bb18b5cbedc5e48356e1458a77bba0af11">*</a> <b>[PATCH v2 24/53] Convert remaining callers of lookup_commit_reference* to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r7aa9bb0875f3aefd5a7b992675a7c718f653ea61">(20 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m7aa9bb0875f3aefd5a7b992675a7c718f653ea61">[PATCH v2 23/53] builtin/tag: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">[PATCH v2 25/53] Convert lookup_commit* to struct object_id</a> brian m. carlson
                   ` <a href="#r2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">(28 subsequent siblings)</a>
  <a href="#rfbb146bb18b5cbedc5e48356e1458a77bba0af11">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

There are a small number of remaining callers of lookup_commit_reference
and lookup_commit_reference_gently that still need to be converted to
struct object_id.  Convert these.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 notes-merge.c | 26 +++++++++++++-------------
 ref-filter.c  |  6 +++---
 sequencer.c   | 20 ++++++++++----------
 sha1_name.c   | 12 ++++++------
 shallow.c     |  6 +++---
 submodule.c   |  8 ++++----
 6 files changed, 39 insertions(+), 39 deletions(-)

diff --git a/notes-merge.c b/notes-merge.c
index 32caaaff7..06d8be9cb 100644
--- a/notes-merge.c
+++ b/notes-merge.c
@@ -535,7 +535,7 @@ int notes_merge(struct notes_merge_options *o,
 		struct notes_tree *local_tree,
 		unsigned char *result_sha1)
 {
-	unsigned char local_sha1[20], remote_sha1[20];
+	struct object_id local_oid, remote_oid;
 	struct commit *local, *remote;
 	struct commit_list *bases = NULL;
 	const unsigned char *base_sha1, *base_tree_sha1;
@@ -549,46 +549,46 @@ int notes_merge(struct notes_merge_options *o,
 	       o-&gt;local_ref, o-&gt;remote_ref);
 
 	/* Dereference o-&gt;local_ref into local_sha1 */
-	if (read_ref_full(o-&gt;local_ref, 0, local_sha1, NULL))
+	if (read_ref_full(o-&gt;local_ref, 0, local_oid.hash, NULL))
 		die("Failed to resolve local notes ref '%s'", o-&gt;local_ref);
 	else if (!check_refname_format(o-&gt;local_ref, 0) &amp;&amp;
-		is_null_sha1(local_sha1))
+		is_null_oid(&amp;local_oid))
 		local = NULL; /* local_sha1 == null_sha1 indicates unborn ref */
-	else if (!(local = lookup_commit_reference(local_sha1)))
+	else if (!(local = lookup_commit_reference(local_oid.hash)))
 		die("Could not parse local commit %s (%s)",
-		    sha1_to_hex(local_sha1), o-&gt;local_ref);
-	trace_printf("\tlocal commit: %.7s\n", sha1_to_hex(local_sha1));
+		    oid_to_hex(&amp;local_oid), o-&gt;local_ref);
+	trace_printf("\tlocal commit: %.7s\n", oid_to_hex(&amp;local_oid));
 
 	/* Dereference o-&gt;remote_ref into remote_sha1 */
-	if (get_sha1(o-&gt;remote_ref, remote_sha1)) {
+	if (get_oid(o-&gt;remote_ref, &amp;remote_oid)) {
 		/*
 		 * Failed to get remote_sha1. If o-&gt;remote_ref looks like an
 		 * unborn ref, perform the merge using an empty notes tree.
 		 */
 		if (!check_refname_format(o-&gt;remote_ref, 0)) {
-			hashclr(remote_sha1);
+			oidclr(&amp;remote_oid);
 			remote = NULL;
 		} else {
 			die("Failed to resolve remote notes ref '%s'",
 			    o-&gt;remote_ref);
 		}
-	} else if (!(remote = lookup_commit_reference(remote_sha1))) {
+	} else if (!(remote = lookup_commit_reference(remote_oid.hash))) {
 		die("Could not parse remote commit %s (%s)",
-		    sha1_to_hex(remote_sha1), o-&gt;remote_ref);
+		    oid_to_hex(&amp;remote_oid), o-&gt;remote_ref);
 	}
-	trace_printf("\tremote commit: %.7s\n", sha1_to_hex(remote_sha1));
+	trace_printf("\tremote commit: %.7s\n", oid_to_hex(&amp;remote_oid));
 
 	if (!local &amp;&amp; !remote)
 		die("Cannot merge empty notes ref (%s) into empty notes ref "
 		    "(%s)", o-&gt;remote_ref, o-&gt;local_ref);
 	if (!local) {
 		/* result == remote commit */
-		hashcpy(result_sha1, remote_sha1);
+		hashcpy(result_sha1, remote_oid.hash);
 		goto found_result;
 	}
 	if (!remote) {
 		/* result == local commit */
-		hashcpy(result_sha1, local_sha1);
+		hashcpy(result_sha1, local_oid.hash);
 		goto found_result;
 	}
 	assert(local &amp;&amp; remote);
diff --git a/ref-filter.c b/ref-filter.c
index 3a640448f..47cce0a18 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -2090,7 +2090,7 @@ int parse_opt_ref_sorting(const struct option *opt, const char *arg, int unset)
 int parse_opt_merge_filter(const struct option *opt, const char *arg, int unset)
 {
 	struct ref_filter *rf = opt-&gt;value;
-	unsigned char sha1[20];
+	struct object_id oid;
 	int no_merged = starts_with(opt-&gt;long_name, "no");
 
 	if (rf-&gt;merge) {
@@ -2105,10 +2105,10 @@ int parse_opt_merge_filter(const struct option *opt, const char *arg, int unset)
 		? REF_FILTER_MERGED_OMIT
 		: REF_FILTER_MERGED_INCLUDE;
 
-	if (get_sha1(arg, sha1))
+	if (get_oid(arg, &amp;oid))
 		die(_("malformed object name %s"), arg);
 
-	rf-&gt;merge_commit = lookup_commit_reference_gently(sha1, 0);
+	rf-&gt;merge_commit = lookup_commit_reference_gently(oid.hash, 0);
 	if (!rf-&gt;merge_commit)
 		return opterror(opt, "must point to a commit", 0);
 
diff --git a/sequencer.c b/sequencer.c
index 1a4729d9d..e0d0e98a4 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -1221,7 +1221,7 @@ static struct todo_item *append_new_todo(struct todo_list *todo_list)
 
 static int parse_insn_line(struct todo_item *item, const char *bol, char *eol)
 {
-	unsigned char commit_sha1[20];
+	struct object_id commit_oid;
 	char *end_of_object_name;
 	int i, saved, status, padding;
 
@@ -1270,7 +1270,7 @@ static int parse_insn_line(struct todo_item *item, const char *bol, char *eol)
 	end_of_object_name = (char *) bol + strcspn(bol, " \t\n");
 	saved = *end_of_object_name;
 	*end_of_object_name = '\0';
-	status = get_sha1(bol, commit_sha1);
+	status = get_oid(bol, &amp;commit_oid);
 	*end_of_object_name = saved;
 
 	item-&gt;arg = end_of_object_name + strspn(end_of_object_name, " \t");
@@ -1279,7 +1279,7 @@ static int parse_insn_line(struct todo_item *item, const char *bol, char *eol)
 	if (status &lt; 0)
 		return -1;
 
-	item-&gt;commit = lookup_commit_reference(commit_sha1);
+	item-&gt;commit = lookup_commit_reference(commit_oid.hash);
 	return !item-&gt;commit;
 }
 
@@ -2259,7 +2259,7 @@ static int single_pick(struct commit *cmit, struct replay_opts *opts)
 int sequencer_pick_revisions(struct replay_opts *opts)
 {
 	struct todo_list todo_list = TODO_LIST_INIT;
-	unsigned char sha1[20];
+	struct object_id oid;
 	int i, res;
 
 	assert(opts-&gt;revs);
@@ -2267,16 +2267,16 @@ int sequencer_pick_revisions(struct replay_opts *opts)
 		return -1;
 
 	for (i = 0; i &lt; opts-&gt;revs-&gt;pending.nr; i++) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		const char *name = opts-&gt;revs-&gt;pending.objects[i].name;
 
 		/* This happens when using --stdin. */
 		if (!strlen(name))
 			continue;
 
-		if (!get_sha1(name, sha1)) {
-			if (!lookup_commit_reference_gently(sha1, 1)) {
-				enum object_type type = sha1_object_info(sha1, NULL);
+		if (!get_oid(name, &amp;oid)) {
+			if (!lookup_commit_reference_gently(oid.hash, 1)) {
+				enum object_type type = sha1_object_info(oid.hash, NULL);
 				return error(_("%s: can't cherry-pick a %s"),
 					name, typename(type));
 			}
@@ -2313,9 +2313,9 @@ int sequencer_pick_revisions(struct replay_opts *opts)
 	if (walk_revs_populate_todo(&amp;todo_list, opts) ||
 			create_seq_dir() &lt; 0)
 		return -1;
-	if (get_sha1("HEAD", sha1) &amp;&amp; (opts-&gt;action == REPLAY_REVERT))
+	if (get_oid("HEAD", &amp;oid) &amp;&amp; (opts-&gt;action == REPLAY_REVERT))
 		return error(_("can't revert as initial commit"));
-	if (save_head(sha1_to_hex(sha1)))
+	if (save_head(oid_to_hex(&amp;oid)))
 		return -1;
 	if (save_opts(opts))
 		return -1;
diff --git a/sha1_name.c b/sha1_name.c
index 8eec9f7c1..8889190a9 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -722,14 +722,14 @@ static int get_sha1_basic(const char *str, int len, unsigned char *sha1,
 static int get_parent(const char *name, int len,
 		      unsigned char *result, int idx)
 {
-	unsigned char sha1[20];
-	int ret = get_sha1_1(name, len, sha1, GET_SHA1_COMMITTISH);
+	struct object_id oid;
+	int ret = get_sha1_1(name, len, oid.hash, GET_SHA1_COMMITTISH);
 	struct commit *commit;
 	struct commit_list *p;
 
 	if (ret)
 		return ret;
-	commit = lookup_commit_reference(sha1);
+	commit = lookup_commit_reference(oid.hash);
 	if (parse_commit(commit))
 		return -1;
 	if (!idx) {
@@ -750,14 +750,14 @@ static int get_parent(const char *name, int len,
 static int get_nth_ancestor(const char *name, int len,
 			    unsigned char *result, int generation)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct commit *commit;
 	int ret;
 
-	ret = get_sha1_1(name, len, sha1, GET_SHA1_COMMITTISH);
+	ret = get_sha1_1(name, len, oid.hash, GET_SHA1_COMMITTISH);
 	if (ret)
 		return ret;
-	commit = lookup_commit_reference(sha1);
+	commit = lookup_commit_reference(oid.hash);
 	if (!commit)
 		return -1;
 
diff --git a/shallow.c b/shallow.c
index c520ae3ae..1327ee16f 100644
--- a/shallow.c
+++ b/shallow.c
@@ -466,7 +466,7 @@ static uint32_t *paint_alloc(struct paint_info *info)
  * UNINTERESTING or BOTTOM is hit. Set the id-th bit in ref_bitmap for
  * all walked commits.
  */
-static void paint_down(struct paint_info *info, const unsigned char *sha1,
+static void paint_down(struct paint_info *info, const struct object_id *oid,
 		       unsigned int id)
 {
 	unsigned int i, nr;
@@ -475,7 +475,7 @@ static void paint_down(struct paint_info *info, const unsigned char *sha1,
 	size_t bitmap_size = st_mult(sizeof(uint32_t), bitmap_nr);
 	uint32_t *tmp = xmalloc(bitmap_size); /* to be freed before return */
 	uint32_t *bitmap = paint_alloc(info);
-	struct commit *c = lookup_commit_reference_gently(sha1, 1);
+	struct commit *c = lookup_commit_reference_gently(oid-&gt;hash, 1);
 	if (!c)
 		return;
 	memset(bitmap, 0, bitmap_size);
@@ -604,7 +604,7 @@ void assign_shallow_commits_to_refs(struct shallow_info *info,
 	}
 
 	for (i = 0; i &lt; ref-&gt;nr; i++)
-		paint_down(&amp;pi, ref-&gt;oid[i].hash, i);
+		paint_down(&amp;pi, ref-&gt;oid + i, i);
 
 	if (used) {
 		int bitmap_size = ((pi.nr_bits + 31) / 32) * sizeof(uint32_t);
diff --git a/submodule.c b/submodule.c
index 9bdd5f605..d5c28b9f1 100644
--- a/submodule.c
+++ b/submodule.c
@@ -896,17 +896,17 @@ int push_unpushed_submodules(struct oid_array *commits,
 	return ret;
 }
 
-static int is_submodule_commit_present(const char *path, unsigned char sha1[20])
+static int is_submodule_commit_present(const char *path, struct object_id *oid)
 {
 	int is_present = 0;
-	if (!add_submodule_odb(path) &amp;&amp; lookup_commit_reference(sha1)) {
+	if (!add_submodule_odb(path) &amp;&amp; lookup_commit_reference(oid-&gt;hash)) {
 		/* Even if the submodule is checked out and the commit is
 		 * present, make sure it is reachable from a ref. */
 		struct child_process cp = CHILD_PROCESS_INIT;
 		const char *argv[] = {"rev-list", "-n", "1", NULL, "--not", "--all", NULL};
 		struct strbuf buf = STRBUF_INIT;
 
-		argv[3] = sha1_to_hex(sha1);
+		argv[3] = oid_to_hex(oid);
 		cp.argv = argv;
 		prepare_submodule_repo_env(&amp;cp.env_array);
 		cp.git_cmd = 1;
@@ -937,7 +937,7 @@ static void submodule_collect_changed_cb(struct diff_queue_struct *q,
 			 * being moved around. */
 			struct string_list_item *path;
 			path = unsorted_string_list_lookup(&amp;changed_submodule_paths, p-&gt;two-&gt;path);
-			if (!path &amp;&amp; !is_submodule_commit_present(p-&gt;two-&gt;path, p-&gt;two-&gt;oid.hash))
+			if (!path &amp;&amp; !is_submodule_commit_present(p-&gt;two-&gt;path, &amp;p-&gt;two-&gt;oid))
 				string_list_append(&amp;changed_submodule_paths, xstrdup(p-&gt;two-&gt;path));
 		} else {
 			/* Submodule is new or was moved here */

<a href="#mfbb146bb18b5cbedc5e48356e1458a77bba0af11" id="efbb146bb18b5cbedc5e48356e1458a77bba0af11">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-25-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rfbb146bb18b5cbedc5e48356e1458a77bba0af11">52+ messages in thread</a></pre><hr><pre><a href="#e2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952" id="m2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">*</a> <b>[PATCH v2 25/53] Convert lookup_commit* to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rfbb146bb18b5cbedc5e48356e1458a77bba0af11">(21 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mfbb146bb18b5cbedc5e48356e1458a77bba0af11">[PATCH v2 24/53] Convert remaining callers of lookup_commit_reference* to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m891b1840f7953004bf78a2705362287ba2ff8e22">[PATCH v2 26/53] pack: convert struct pack_idx_entry to struct object_id</a> brian m. carlson
                   ` <a href="#r891b1840f7953004bf78a2705362287ba2ff8e22">(27 subsequent siblings)</a>
  <a href="#r2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái 
Ngọc Duy

Convert lookup_commit, lookup_commit_or_die,
lookup_commit_reference, and lookup_commit_reference_gently to take
struct object_id arguments.

Introduce a temporary in parse_object buffer in order to convert this
function.  This is required since in order to convert parse_object and
parse_object_buffer, lookup_commit_reference_gently and
lookup_commit_or_die would need to be converted.  Not introducing a
temporary would therefore require that lookup_commit_or_die take a
struct object_id *, but lookup_commit would take unsigned char *,
leaving a confusing and hard-to-use interface.

parse_object_buffer will lose this temporary in a later patch.

This commit was created with manual changes to commit.c, commit.h, and
object.c, plus the following semantic patch:

@@
expression E1, E2;
@@
- lookup_commit_reference_gently(E1.hash, E2)
+ lookup_commit_reference_gently(&amp;E1, E2)

@@
expression E1, E2;
@@
- lookup_commit_reference_gently(E1-&gt;hash, E2)
+ lookup_commit_reference_gently(E1, E2)

@@
expression E1;
@@
- lookup_commit_reference(E1.hash)
+ lookup_commit_reference(&amp;E1)

@@
expression E1;
@@
- lookup_commit_reference(E1-&gt;hash)
+ lookup_commit_reference(E1)

@@
expression E1;
@@
- lookup_commit(E1.hash)
+ lookup_commit(&amp;E1)

@@
expression E1;
@@
- lookup_commit(E1-&gt;hash)
+ lookup_commit(E1)

@@
expression E1, E2;
@@
- lookup_commit_or_die(E1.hash, E2)
+ lookup_commit_or_die(&amp;E1, E2)

@@
expression E1, E2;
@@
- lookup_commit_or_die(E1-&gt;hash, E2)
+ lookup_commit_or_die(E1, E2)

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 archive.c               |  2 +-
 bisect.c                |  2 +-
 branch.c                |  2 +-
 builtin/am.c            |  4 ++--
 builtin/blame.c         |  4 ++--
 builtin/branch.c        |  6 +++---
 builtin/checkout.c      |  6 +++---
 builtin/clone.c         |  2 +-
 builtin/commit-tree.c   |  2 +-
 builtin/commit.c        |  4 ++--
 builtin/describe.c      |  4 ++--
 builtin/diff-tree.c     |  4 ++--
 builtin/fast-export.c   |  2 +-
 builtin/fetch.c         |  7 ++++---
 builtin/fmt-merge-msg.c |  4 ++--
 builtin/log.c           |  8 ++++----
 builtin/merge-base.c    |  6 +++---
 builtin/merge.c         |  2 +-
 builtin/notes.c         |  2 +-
 builtin/pull.c          | 10 +++++-----
 builtin/reflog.c        |  8 ++++----
 builtin/replace.c       |  4 ++--
 builtin/reset.c         |  4 ++--
 builtin/rev-parse.c     |  6 +++---
 builtin/show-branch.c   |  4 ++--
 builtin/tag.c           |  2 +-
 builtin/verify-commit.c |  2 +-
 bundle.c                |  2 +-
 commit.c                | 30 +++++++++++++++---------------
 commit.h                | 12 ++++++------
 fast-import.c           |  4 ++--
 fetch-pack.c            |  2 +-
 http-push.c             |  5 +++--
 log-tree.c              |  2 +-
 notes-cache.c           |  2 +-
 notes-merge.c           |  4 ++--
 notes-utils.c           |  2 +-
 object.c                |  5 ++++-
 parse-options-cb.c      |  2 +-
 ref-filter.c            |  4 ++--
 remote.c                | 13 +++++++------
 revision.c              |  8 ++++----
 sequencer.c             |  8 ++++----
 sha1_name.c             | 10 +++++-----
 shallow.c               | 20 ++++++++++----------
 submodule.c             | 14 +++++++-------
 tag.c                   |  2 +-
 tree.c                  |  2 +-
 walker.c                |  2 +-
 wt-status.c             |  2 +-
 50 files changed, 138 insertions(+), 132 deletions(-)

diff --git a/archive.c b/archive.c
index 60b889198..54701e8bb 100644
--- a/archive.c
+++ b/archive.c
@@ -360,7 +360,7 @@ static void parse_treeish_arg(const char **argv,
 	if (get_sha1(name, oid.hash))
 		die("Not a valid object name");
 
-	commit = lookup_commit_reference_gently(oid.hash, 1);
+	commit = lookup_commit_reference_gently(&amp;oid, 1);
 	if (commit) {
 		commit_sha1 = commit-&gt;object.oid.hash;
 		archive_time = commit-&gt;date;
diff --git a/bisect.c b/bisect.c
index 08c9fb726..bb5af3ea3 100644
--- a/bisect.c
+++ b/bisect.c
@@ -705,7 +705,7 @@ static int bisect_checkout(const unsigned char 
*bisect_rev, int no_checkout)
 
 static struct commit *get_commit_reference(const struct object_id *oid)
 {
-	struct commit *r = lookup_commit_reference(oid-&gt;hash);
+	struct commit *r = lookup_commit_reference(oid);
 	if (!r)
 		die(_("Not a valid commit name %s"), oid_to_hex(oid));
 	return r;
diff --git a/branch.c b/branch.c
index 1758c9708..4899144f5 100644
--- a/branch.c
+++ b/branch.c
@@ -286,7 +286,7 @@ void create_branch(const char *name, const char 
*start_name,
 		break;
 	}
 
-	if ((commit = lookup_commit_reference(oid.hash)) == NULL)
+	if ((commit = lookup_commit_reference(&amp;oid)) == NULL)
 		die(_("Not a valid branch point: '%s'."), start_name);
 	oidcpy(&amp;oid, &amp;commit-&gt;object.oid);
 
diff --git a/builtin/am.c b/builtin/am.c
index a95dd8b4e..650269ac5 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -1488,7 +1488,7 @@ static int parse_mail_rebase(struct am_state 
*state, const char *mail)
 	if (get_mail_commit_oid(&amp;commit_oid, mail) &lt; 0)
 		die(_("could not parse %s"), mail);
 
-	commit = lookup_commit_or_die(commit_oid.hash, mail);
+	commit = lookup_commit_or_die(&amp;commit_oid, mail);
 
 	get_commit_info(state, commit);
 
@@ -1683,7 +1683,7 @@ static void do_commit(const struct am_state 
*state)
 
 	if (!get_sha1_commit("HEAD", parent.hash)) {
 		old_oid = &amp;parent;
-		commit_list_insert(lookup_commit(parent.hash), &amp;parents);
+		commit_list_insert(lookup_commit(&amp;parent), &amp;parents);
 	} else {
 		old_oid = NULL;
 		say(state, stderr, _("applying to an empty history"));
diff --git a/builtin/blame.c b/builtin/blame.c
index 7d644d092..58bb274d0 100644
--- a/builtin/blame.c
+++ b/builtin/blame.c
@@ -2253,7 +2253,7 @@ static struct commit_list **append_parent(struct 
commit_list **tail, const struc
 {
 	struct commit *parent;
 
-	parent = lookup_commit_reference(oid-&gt;hash);
+	parent = lookup_commit_reference(oid);
 	if (!parent)
 		die("no such commit %s", oid_to_hex(oid));
 	return &amp;commit_list_insert(parent, tail)-&gt;next;
@@ -2475,7 +2475,7 @@ static const char *dwim_reverse_initial(struct 
scoreboard *sb)
 	/* Do we have HEAD? */
 	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_oid.hash, 
NULL))
 		return NULL;
-	head_commit = lookup_commit_reference_gently(head_oid.hash, 1);
+	head_commit = lookup_commit_reference_gently(&amp;head_oid, 1);
 	if (!head_commit)
 		return NULL;
 
diff --git a/builtin/branch.c b/builtin/branch.c
index 48a513a84..83fcda43d 100644
--- a/builtin/branch.c
+++ b/builtin/branch.c
@@ -124,7 +124,7 @@ static int branch_merged(int kind, const char *name,
 		    (reference_name = reference_name_to_free =
 		     resolve_refdup(upstream, RESOLVE_REF_READING,
 				    oid.hash, NULL)) != NULL)
-			reference_rev = lookup_commit_reference(oid.hash);
+			reference_rev = lookup_commit_reference(&amp;oid);
 	}
 	if (!reference_rev)
 		reference_rev = head_rev;
@@ -157,7 +157,7 @@ static int check_branch_commit(const char 
*branchname, const char *refname,
 			       const struct object_id *oid, struct commit *head_rev,
 			       int kinds, int force)
 {
-	struct commit *rev = lookup_commit_reference(oid-&gt;hash);
+	struct commit *rev = lookup_commit_reference(oid);
 	if (!rev) {
 		error(_("Couldn't look up commit object for '%s'"), refname);
 		return -1;
@@ -211,7 +211,7 @@ static int delete_branches(int argc, const char 
**argv, int force, int kinds,
 	}
 
 	if (!force) {
-		head_rev = lookup_commit_reference(head_oid.hash);
+		head_rev = lookup_commit_reference(&amp;head_oid);
 		if (!head_rev)
 			die(_("Couldn't look up commit object for HEAD"));
 	}
diff --git a/builtin/checkout.c b/builtin/checkout.c
index bfa5419f3..afa99fb8a 100644
--- a/builtin/checkout.c
+++ b/builtin/checkout.c
@@ -393,7 +393,7 @@ static int checkout_paths(const struct checkout_opts
 *opts,
 		die(_("unable to write new index file"));
 
 	read_ref_full("HEAD", 0, rev.hash, NULL);
-	head = lookup_commit_reference_gently(rev.hash, 1);
+	head = lookup_commit_reference_gently(&amp;rev, 1);
 
 	errs |= post_checkout_hook(head, head, 0);
 	return errs;
@@ -833,7 +833,7 @@ static int switch_branches(const struct 
checkout_opts *opts,
 	int flag, writeout_error = 0;
 	memset(&amp;old, 0, sizeof(old));
 	old.path = path_to_free = resolve_refdup("HEAD", 0, rev.hash, 
&amp;flag);
-	old.commit = lookup_commit_reference_gently(rev.hash, 1);
+	old.commit = lookup_commit_reference_gently(&amp;rev, 1);
 	if (!(flag &amp; REF_ISSYMREF))
 		old.path = NULL;
 
@@ -1047,7 +1047,7 @@ static int parse_branchname_arg(int argc, const 
char **argv,
 	else
 		new-&gt;path = NULL; /* not an existing branch */
 
-	new-&gt;commit = lookup_commit_reference_gently(rev-&gt;hash, 1);
+	new-&gt;commit = lookup_commit_reference_gently(rev, 1);
 	if (!new-&gt;commit) {
 		/* not a commit */
 		*source_tree = parse_tree_indirect(rev-&gt;hash);
diff --git a/builtin/clone.c b/builtin/clone.c
index de85b8525..646f28792 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
@@ -682,7 +682,7 @@ static void update_head(const struct ref *our, const
 struct ref *remote,
 			install_branch_config(0, head, option_origin, our-&gt;name);
 		}
 	} else if (our) {
-		struct commit *c = lookup_commit_reference(our-&gt;old_oid.hash);
+		struct commit *c = lookup_commit_reference(&amp;our-&gt;old_oid);
 		/* --branch specifies a non-branch (i.e. tags), detach HEAD */
 		update_ref(msg, "HEAD", c-&gt;object.oid.hash,
 			   NULL, REF_NODEREF, UPDATE_REFS_DIE_ON_ERR);
diff --git a/builtin/commit-tree.c b/builtin/commit-tree.c
index 605017261..f39c2b273 100644
--- a/builtin/commit-tree.c
+++ b/builtin/commit-tree.c
@@ -58,7 +58,7 @@ int cmd_commit_tree(int argc, const char **argv, const
 char *prefix)
 			if (get_sha1_commit(argv[i], oid.hash))
 				die("Not a valid object name %s", argv[i]);
 			assert_sha1_type(oid.hash, OBJ_COMMIT);
-			new_parent(lookup_commit(oid.hash), &amp;parents);
+			new_parent(lookup_commit(&amp;oid), &amp;parents);
 			continue;
 		}
 
diff --git a/builtin/commit.c b/builtin/commit.c
index 8685c888f..e69f466d5 100644
--- a/builtin/commit.c
+++ b/builtin/commit.c
@@ -1430,7 +1430,7 @@ static void print_summary(const char *prefix, 
const struct object_id *oid,
 	struct strbuf author_ident = STRBUF_INIT;
 	struct strbuf committer_ident = STRBUF_INIT;
 
-	commit = lookup_commit(oid-&gt;hash);
+	commit = lookup_commit(oid);
 	if (!commit)
 		die(_("couldn't look up newly created commit"));
 	if (parse_commit(commit))
@@ -1654,7 +1654,7 @@ int cmd_commit(int argc, const char **argv, const 
char *prefix)
 	if (get_sha1("HEAD", oid.hash))
 		current_head = NULL;
 	else {
-		current_head = lookup_commit_or_die(oid.hash, "HEAD");
+		current_head = lookup_commit_or_die(&amp;oid, "HEAD");
 		if (parse_commit(current_head))
 			die(_("could not parse HEAD commit"));
 	}
diff --git a/builtin/describe.c b/builtin/describe.c
index a5cd8c513..f6032f593 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
@@ -281,7 +281,7 @@ static void describe(const char *arg, int last_one)
 
 	if (get_oid(arg, &amp;oid))
 		die(_("Not a valid object name %s"), arg);
-	cmit = lookup_commit_reference(oid.hash);
+	cmit = lookup_commit_reference(&amp;oid);
 	if (!cmit)
 		die(_("%s is not a valid '%s' object"), arg, commit_type);
 
@@ -309,7 +309,7 @@ static void describe(const char *arg, int last_one)
 		struct commit *c;
 		struct commit_name *n = hashmap_iter_first(&amp;names, &amp;iter);
 		for (; n; n = hashmap_iter_next(&amp;iter)) {
-			c = lookup_commit_reference_gently(n-&gt;peeled.hash, 1);
+			c = lookup_commit_reference_gently(&amp;n-&gt;peeled, 1);
 			if (c)
 				c-&gt;util = n;
 		}
diff --git a/builtin/diff-tree.c b/builtin/diff-tree.c
index 326f88b65..e85a449df 100644
--- a/builtin/diff-tree.c
+++ b/builtin/diff-tree.c
@@ -9,7 +9,7 @@ static struct rev_info log_tree_opt;
 
 static int diff_tree_commit_sha1(const struct object_id *oid)
 {
-	struct commit *commit = lookup_commit_reference(oid-&gt;hash);
+	struct commit *commit = lookup_commit_reference(oid);
 	if (!commit)
 		return -1;
 	return log_tree_commit(&amp;log_tree_opt, commit);
@@ -23,7 +23,7 @@ static int stdin_diff_commit(struct commit *commit, 
const char *p)
 
 	/* Graft the fake parents locally to the commit */
 	while (isspace(*p++) &amp;&amp; !parse_oid_hex(p, &amp;oid, &amp;p)) {
-		struct commit *parent = lookup_commit(oid.hash);
+		struct commit *parent = lookup_commit(&amp;oid);
 		if (!pptr) {
 			/* Free the real parent list */
 			free_commit_list(commit-&gt;parents);
diff --git a/builtin/fast-export.c b/builtin/fast-export.c
index e0220630d..b4521cb62 100644
--- a/builtin/fast-export.c
+++ b/builtin/fast-export.c
@@ -938,7 +938,7 @@ static void import_marks(char *input_file)
 			/* only commits */
 			continue;
 
-		commit = lookup_commit(oid.hash);
+		commit = lookup_commit(&amp;oid);
 		if (!commit)
 			die("not a commit? can't happen: %s", oid_to_hex(&amp;oid));
 
diff --git a/builtin/fetch.c b/builtin/fetch.c
index 5f2c2ab23..d4d573b98 100644
--- a/builtin/fetch.c
+++ b/builtin/fetch.c
@@ -636,8 +636,8 @@ static int update_local_ref(struct ref *ref,
 		return r;
 	}
 
-	current = lookup_commit_reference_gently(ref-&gt;old_oid.hash, 1);
-	updated = lookup_commit_reference_gently(ref-&gt;new_oid.hash, 1);
+	current = lookup_commit_reference_gently(&amp;ref-&gt;old_oid, 1);
+	updated = lookup_commit_reference_gently(&amp;ref-&gt;new_oid, 1);
 	if (!current || !updated) {
 		const char *msg;
 		const char *what;
@@ -770,7 +770,8 @@ static int store_updated_refs(const char *raw_url, 
const char *remote_name,
 				continue;
 			}
 
-			commit = lookup_commit_reference_gently(rm-&gt;old_oid.hash, 1);
+			commit = lookup_commit_reference_gently(&amp;rm-&gt;old_oid,
+								1);
 			if (!commit)
 				rm-&gt;fetch_head_status = FETCH_HEAD_NOT_FOR_MERGE;
 
diff --git a/builtin/fmt-merge-msg.c b/builtin/fmt-merge-msg.c
index 6faa3c0d2..91dd753dd 100644
--- a/builtin/fmt-merge-msg.c
+++ b/builtin/fmt-merge-msg.c
@@ -566,7 +566,7 @@ static void find_merge_parents(struct merge_parents 
*result,
 		commit_list_insert(parent, &amp;parents);
 		add_merge_parent(result, &amp;obj-&gt;oid, 
&amp;parent-&gt;object.oid);
 	}
-	head_commit = lookup_commit(head-&gt;hash);
+	head_commit = lookup_commit(head);
 	if (head_commit)
 		commit_list_insert(head_commit, &amp;parents);
 	parents = reduce_heads(parents);
@@ -633,7 +633,7 @@ int fmt_merge_msg(struct strbuf *in, struct strbuf 
*out,
 		struct commit *head;
 		struct rev_info rev;
 
-		head = lookup_commit_or_die(head_oid.hash, "HEAD");
+		head = lookup_commit_or_die(&amp;head_oid, "HEAD");
 		init_revisions(&amp;rev, NULL);
 		rev.commit_format = CMIT_FMT_ONELINE;
 		rev.ignore_merges = 1;
diff --git a/builtin/log.c b/builtin/log.c
index b3b10cc1e..d8b56ea41 100644
--- a/builtin/log.c
+++ b/builtin/log.c
@@ -878,8 +878,8 @@ static void get_patch_ids(struct rev_info *rev, 
struct patch_ids *ids)
 	o2 = rev-&gt;pending.objects[1].item;
 	flags1 = o1-&gt;flags;
 	flags2 = o2-&gt;flags;
-	c1 = lookup_commit_reference(o1-&gt;oid.hash);
-	c2 = lookup_commit_reference(o2-&gt;oid.hash);
+	c1 = lookup_commit_reference(&amp;o1-&gt;oid);
+	c2 = lookup_commit_reference(&amp;o2-&gt;oid);
 
 	if ((flags1 &amp; UNINTERESTING) == (flags2 &amp; UNINTERESTING))
 		die(_("Not a range."));
@@ -1263,7 +1263,7 @@ static struct commit *get_base_commit(const char 
*base_commit,
 
 			if (get_oid(upstream, &amp;oid))
 				die(_("Failed to resolve '%s' as a valid ref."), upstream);
-			commit = lookup_commit_or_die(oid.hash, "upstream base");
+			commit = lookup_commit_or_die(&amp;oid, "upstream base");
 			base_list = get_merge_bases_many(commit, total, list);
 			/* There should be one and only one merge base. */
 			if (!base_list || base_list-&gt;next)
@@ -1819,7 +1819,7 @@ static int add_pending_commit(const char *arg, 
struct rev_info *revs, int flags)
 {
 	struct object_id oid;
 	if (get_oid(arg, &amp;oid) == 0) {
-		struct commit *commit = lookup_commit_reference(oid.hash);
+		struct commit *commit = lookup_commit_reference(&amp;oid);
 		if (commit) {
 			commit-&gt;object.flags |= flags;
 			add_pending_object(revs, &amp;commit-&gt;object, arg);
diff --git a/builtin/merge-base.c b/builtin/merge-base.c
index cfe2a796f..5c74ce249 100644
--- a/builtin/merge-base.c
+++ b/builtin/merge-base.c
@@ -41,7 +41,7 @@ static struct commit *get_commit_reference(const char 
*arg)
 
 	if (get_oid(arg, &amp;revkey))
 		die("Not a valid object name %s", arg);
-	r = lookup_commit_reference(revkey.hash);
+	r = lookup_commit_reference(&amp;revkey);
 	if (!r)
 		die("Not a valid commit name %s", arg);
 
@@ -120,7 +120,7 @@ static void add_one_commit(struct object_id *oid, 
struct rev_collect *revs)
 	if (is_null_oid(oid))
 		return;
 
-	commit = lookup_commit(oid-&gt;hash);
+	commit = lookup_commit(oid);
 	if (!commit ||
 	    (commit-&gt;object.flags &amp; TMP_MARK) ||
 	    parse_commit(commit))
@@ -168,7 +168,7 @@ static int handle_fork_point(int argc, const char 
**argv)
 	if (get_oid(commitname, &amp;oid))
 		die("Not a valid object name: '%s'", commitname);
 
-	derived = lookup_commit_reference(oid.hash);
+	derived = lookup_commit_reference(&amp;oid);
 	memset(&amp;revs, 0, sizeof(revs));
 	revs.initial = 1;
 	for_each_reflog_ent(refname, collect_one_reflog_ent, &amp;revs);
diff --git a/builtin/merge.c b/builtin/merge.c
index 703827f00..f11b5f3de 100644
--- a/builtin/merge.c
+++ b/builtin/merge.c
@@ -1123,7 +1123,7 @@ int cmd_merge(int argc, const char **argv, const 
char *prefix)
 	if (!branch || is_null_oid(&amp;head_oid))
 		head_commit = NULL;
 	else
-		head_commit = lookup_commit_or_die(head_oid.hash, "HEAD");
+		head_commit = lookup_commit_or_die(&amp;head_oid, "HEAD");
 
 	init_diff_ui_defaults();
 	git_config(git_merge_config, NULL);
diff --git a/builtin/notes.c b/builtin/notes.c
index 7b891471c..f2847c41e 100644
--- a/builtin/notes.c
+++ b/builtin/notes.c
@@ -706,7 +706,7 @@ static int merge_commit(struct notes_merge_options 
*o)
 
 	if (get_oid("NOTES_MERGE_PARTIAL", &amp;oid))
 		die(_("failed to read ref NOTES_MERGE_PARTIAL"));
-	else if (!(partial = lookup_commit_reference(oid.hash)))
+	else if (!(partial = lookup_commit_reference(&amp;oid)))
 		die(_("could not find commit from NOTES_MERGE_PARTIAL."));
 	else if (parse_commit(partial))
 		die(_("could not parse commit from NOTES_MERGE_PARTIAL."));
diff --git a/builtin/pull.c b/builtin/pull.c
index dd1a4a94e..2ffb6569a 100644
--- a/builtin/pull.c
+++ b/builtin/pull.c
@@ -698,10 +698,10 @@ static int get_octopus_merge_base(struct object_id
 *merge_base,
 {
 	struct commit_list *revs = NULL, *result;
 
-	commit_list_insert(lookup_commit_reference(curr_head-&gt;hash), 
&amp;revs);
-	commit_list_insert(lookup_commit_reference(merge_head-&gt;hash), 
&amp;revs);
+	commit_list_insert(lookup_commit_reference(curr_head), &amp;revs);
+	commit_list_insert(lookup_commit_reference(merge_head), &amp;revs);
 	if (!is_null_oid(fork_point))
-		commit_list_insert(lookup_commit_reference(fork_point-&gt;hash), 
&amp;revs);
+		commit_list_insert(lookup_commit_reference(fork_point), &amp;revs);
 
 	result = reduce_heads(get_octopus_merge_bases(revs));
 	free_commit_list(revs);
@@ -865,9 +865,9 @@ int cmd_pull(int argc, const char **argv, const char
 *prefix)
 		struct commit_list *list = NULL;
 		struct commit *merge_head, *head;
 
-		head = lookup_commit_reference(orig_head.hash);
+		head = lookup_commit_reference(&amp;orig_head);
 		commit_list_insert(head, &amp;list);
-		merge_head = lookup_commit_reference(merge_heads.oid[0].hash);
+		merge_head = lookup_commit_reference(&amp;merge_heads.oid[0]);
 		if (is_descendant_of(merge_head, list)) {
 			/* we can fast-forward this without invoking rebase */
 			opt_ff = "--ff-only";
diff --git a/builtin/reflog.c b/builtin/reflog.c
index d6718d326..4831116ea 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -192,7 +192,7 @@ static int keep_entry(struct commit **it, struct 
object_id *oid)
 
 	if (is_null_oid(oid))
 		return 1;
-	commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+	commit = lookup_commit_reference_gently(oid, 1);
 	if (!commit)
 		return 0;
 
@@ -261,7 +261,7 @@ static int unreachable(struct 
expire_reflog_policy_cb *cb, struct commit *commit
 		if (is_null_oid(oid))
 			return 0;
 
-		commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+		commit = lookup_commit_reference_gently(oid, 1);
 
 		/* Not a commit -- keep it */
 		if (!commit)
@@ -318,7 +318,7 @@ static int push_tip_to_list(const char *refname, 
const struct object_id *oid,
 	struct commit *tip_commit;
 	if (flags &amp; REF_ISSYMREF)
 		return 0;
-	tip_commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+	tip_commit = lookup_commit_reference_gently(oid, 1);
 	if (!tip_commit)
 		return 0;
 	commit_list_insert(tip_commit, list);
@@ -335,7 +335,7 @@ static void reflog_expiry_prepare(const char 
*refname,
 		cb-&gt;tip_commit = NULL;
 		cb-&gt;unreachable_expire_kind = UE_HEAD;
 	} else {
-		cb-&gt;tip_commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+		cb-&gt;tip_commit = lookup_commit_reference_gently(oid, 1);
 		if (!cb-&gt;tip_commit)
 			cb-&gt;unreachable_expire_kind = UE_ALWAYS;
 		else
diff --git a/builtin/replace.c b/builtin/replace.c
index ab17668f4..3c44ef750 100644
--- a/builtin/replace.c
+++ b/builtin/replace.c
@@ -328,7 +328,7 @@ static void replace_parents(struct strbuf *buf, int 
argc, const char **argv)
 		struct object_id oid;
 		if (get_oid(argv[i], &amp;oid) &lt; 0)
 			die(_("Not a valid object name: '%s'"), argv[i]);
-		lookup_commit_or_die(oid.hash, argv[i]);
+		lookup_commit_or_die(&amp;oid, argv[i]);
 		strbuf_addf(&amp;new_parents, "parent %s\n", oid_to_hex(&amp;oid));
 	}
 
@@ -394,7 +394,7 @@ static int create_graft(int argc, const char **argv,
 int force)
 
 	if (get_oid(old_ref, &amp;old) &lt; 0)
 		die(_("Not a valid object name: '%s'"), old_ref);
-	commit = lookup_commit_or_die(old.hash, old_ref);
+	commit = lookup_commit_or_die(&amp;old, old_ref);
 
 	buffer = get_commit_buffer(commit, &amp;size);
 	strbuf_add(&amp;buf, buffer, size);
diff --git a/builtin/reset.c b/builtin/reset.c
index fc3b906c4..0be52fa36 100644
--- a/builtin/reset.c
+++ b/builtin/reset.c
@@ -303,7 +303,7 @@ int cmd_reset(int argc, const char **argv, const 
char *prefix)
 		struct commit *commit;
 		if (get_sha1_committish(rev, oid.hash))
 			die(_("Failed to resolve '%s' as a valid revision."), rev);
-		commit = lookup_commit_reference(oid.hash);
+		commit = lookup_commit_reference(&amp;oid);
 		if (!commit)
 			die(_("Could not parse object '%s'."), rev);
 		oidcpy(&amp;oid, &amp;commit-&gt;object.oid);
@@ -380,7 +380,7 @@ int cmd_reset(int argc, const char **argv, const 
char *prefix)
 		update_ref_status = reset_refs(rev, &amp;oid);
 
 		if (reset_type == HARD &amp;&amp; !update_ref_status &amp;&amp; 
!quiet)
-			print_new_head_line(lookup_commit_reference(oid.hash));
+			print_new_head_line(lookup_commit_reference(&amp;oid));
 	}
 	if (!pathspec.nr)
 		remove_branch_state();
diff --git a/builtin/rev-parse.c b/builtin/rev-parse.c
index 272bb13a0..01c67a1f1 100644
--- a/builtin/rev-parse.c
+++ b/builtin/rev-parse.c
@@ -279,8 +279,8 @@ static int try_difference(const char *arg)
 		if (symmetric) {
 			struct commit_list *exclude;
 			struct commit *a, *b;
-			a = lookup_commit_reference(oid.hash);
-			b = lookup_commit_reference(end.hash);
+			a = lookup_commit_reference(&amp;oid);
+			b = lookup_commit_reference(&amp;end);
 			exclude = get_merge_bases(a, b);
 			while (exclude) {
 				struct commit *commit = pop_commit(&amp;exclude);
@@ -332,7 +332,7 @@ static int try_parent_shorthands(const char *arg)
 		return 0;
 	}
 
-	commit = lookup_commit_reference(oid.hash);
+	commit = lookup_commit_reference(&amp;oid);
 	if (exclude_parent &amp;&amp;
 	    exclude_parent &gt; commit_list_count(commit-&gt;parents)) {
 		*dotdot = '^';
diff --git a/builtin/show-branch.c b/builtin/show-branch.c
index 19756595d..71b6f3c17 100644
--- a/builtin/show-branch.c
+++ b/builtin/show-branch.c
@@ -358,7 +358,7 @@ static void sort_ref_range(int bottom, int top)
 static int append_ref(const char *refname, const struct object_id *oid,
 		      int allow_dups)
 {
-	struct commit *commit = lookup_commit_reference_gently(oid-&gt;hash, 
1);
+	struct commit *commit = lookup_commit_reference_gently(oid, 1);
 	int i;
 
 	if (!commit)
@@ -816,7 +816,7 @@ int cmd_show_branch(int ac, const char **av, const 
char *prefix)
 			       MAX_REVS), MAX_REVS);
 		if (get_sha1(ref_name[num_rev], revkey.hash))
 			die(_("'%s' is not a valid ref."), ref_name[num_rev]);
-		commit = lookup_commit_reference(revkey.hash);
+		commit = lookup_commit_reference(&amp;revkey);
 		if (!commit)
 			die(_("cannot find commit %s (%s)"),
 			    ref_name[num_rev], oid_to_hex(&amp;revkey));
diff --git a/builtin/tag.c b/builtin/tag.c
index 597c925e3..d0070b37c 100644
--- a/builtin/tag.c
+++ b/builtin/tag.c
@@ -328,7 +328,7 @@ static void create_reflog_msg(const struct object_id
 *oid, struct strbuf *sb)
 		}
 		free(buf);
 
-		if ((c = lookup_commit_reference(oid-&gt;hash)) != NULL)
+		if ((c = lookup_commit_reference(oid)) != NULL)
 			strbuf_addf(sb, ", %s", show_date(c-&gt;date, 0, DATE_MODE(SHORT)));
 		break;
 	case OBJ_TREE:
diff --git a/builtin/verify-commit.c b/builtin/verify-commit.c
index a5db1c427..05b734e6d 100644
--- a/builtin/verify-commit.c
+++ b/builtin/verify-commit.c
@@ -25,7 +25,7 @@ static int run_gpg_verify(const struct object_id *oid,
 const char *buf, unsigned
 
 	memset(&amp;signature_check, 0, sizeof(signature_check));
 
-	ret = check_commit_signature(lookup_commit(oid-&gt;hash), 
&amp;signature_check);
+	ret = check_commit_signature(lookup_commit(oid), 
&amp;signature_check);
 	print_signature_buffer(&amp;signature_check, flags);
 
 	signature_check_clear(&amp;signature_check);
diff --git a/bundle.c b/bundle.c
index 6e181bb3d..3386dba3b 100644
--- a/bundle.c
+++ b/bundle.c
@@ -367,7 +367,7 @@ static int write_bundle_refs(int bundle_fd, struct 
rev_info *revs)
 			 * in terms of a tag (e.g. v2.0 from the range
 			 * "v1.0..v2.0")?
 			 */
-			struct commit *one = lookup_commit_reference(oid.hash);
+			struct commit *one = lookup_commit_reference(&amp;oid);
 			struct object *obj;
 
 			if (e-&gt;item == &amp;(one-&gt;object)) {
diff --git a/commit.c b/commit.c
index ec41ba5e0..0f6c9b6bf 100644
--- a/commit.c
+++ b/commit.c
@@ -18,38 +18,38 @@ int save_commit_buffer = 1;
 
 const char *commit_type = "commit";
 
-struct commit *lookup_commit_reference_gently(const unsigned char 
*sha1,
+struct commit *lookup_commit_reference_gently(const struct object_id 
*oid,
 					      int quiet)
 {
-	struct object *obj = deref_tag(parse_object(sha1), NULL, 0);
+	struct object *obj = deref_tag(parse_object(oid-&gt;hash), NULL, 0);
 
 	if (!obj)
 		return NULL;
 	return object_as_type(obj, OBJ_COMMIT, quiet);
 }
 
-struct commit *lookup_commit_reference(const unsigned char *sha1)
+struct commit *lookup_commit_reference(const struct object_id *oid)
 {
-	return lookup_commit_reference_gently(sha1, 0);
+	return lookup_commit_reference_gently(oid, 0);
 }
 
-struct commit *lookup_commit_or_die(const unsigned char *sha1, const 
char *ref_name)
+struct commit *lookup_commit_or_die(const struct object_id *oid, const 
char *ref_name)
 {
-	struct commit *c = lookup_commit_reference(sha1);
+	struct commit *c = lookup_commit_reference(oid);
 	if (!c)
 		die(_("could not parse %s"), ref_name);
-	if (hashcmp(sha1, c-&gt;object.oid.hash)) {
+	if (oidcmp(oid, &amp;c-&gt;object.oid)) {
 		warning(_("%s %s is not a commit!"),
-			ref_name, sha1_to_hex(sha1));
+			ref_name, oid_to_hex(oid));
 	}
 	return c;
 }
 
-struct commit *lookup_commit(const unsigned char *sha1)
+struct commit *lookup_commit(const struct object_id *oid)
 {
-	struct object *obj = lookup_object(sha1);
+	struct object *obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		return create_object(sha1, alloc_commit_node());
+		return create_object(oid-&gt;hash, alloc_commit_node());
 	return object_as_type(obj, OBJ_COMMIT, 0);
 }
 
@@ -60,7 +60,7 @@ struct commit *lookup_commit_reference_by_name(const 
char *name)
 
 	if (get_sha1_committish(name, oid.hash))
 		return NULL;
-	commit = lookup_commit_reference(oid.hash);
+	commit = lookup_commit_reference(&amp;oid);
 	if (parse_commit(commit))
 		return NULL;
 	return commit;
@@ -350,7 +350,7 @@ int parse_commit_buffer(struct commit *item, const 
void *buffer, unsigned long s
 		 */
 		if (graft &amp;&amp; (graft-&gt;nr_parent &lt; 0 || 
grafts_replace_parents))
 			continue;
-		new_parent = lookup_commit(parent.hash);
+		new_parent = lookup_commit(&amp;parent);
 		if (new_parent)
 			pptr = &amp;commit_list_insert(new_parent, pptr)-&gt;next;
 	}
@@ -358,7 +358,7 @@ int parse_commit_buffer(struct commit *item, const 
void *buffer, unsigned long s
 		int i;
 		struct commit *new_parent;
 		for (i = 0; i &lt; graft-&gt;nr_parent; i++) {
-			new_parent = lookup_commit(graft-&gt;parent[i].hash);
+			new_parent = lookup_commit(&amp;graft-&gt;parent[i]);
 			if (!new_parent)
 				continue;
 			pptr = &amp;commit_list_insert(new_parent, pptr)-&gt;next;
@@ -562,7 +562,7 @@ void clear_commit_marks_for_object_array(struct 
object_array *a, unsigned mark)
 
 	for (i = 0; i &lt; a-&gt;nr; i++) {
 		object = a-&gt;objects[i].item;
-		commit = lookup_commit_reference_gently(object-&gt;oid.hash, 1);
+		commit = lookup_commit_reference_gently(&amp;object-&gt;oid, 1);
 		if (commit)
 			clear_commit_marks(commit, mark);
 	}
diff --git a/commit.h b/commit.h
index 884177b8f..3488a285b 100644
--- a/commit.h
+++ b/commit.h
@@ -45,18 +45,18 @@ enum decoration_type {
 void add_name_decoration(enum decoration_type type, const char *name, 
struct object *obj);
 const struct name_decoration *get_name_decoration(const struct object 
*obj);
 
-struct commit *lookup_commit(const unsigned char *sha1);
-struct commit *lookup_commit_reference(const unsigned char *sha1);
-struct commit *lookup_commit_reference_gently(const unsigned char 
*sha1,
+struct commit *lookup_commit(const struct object_id *oid);
+struct commit *lookup_commit_reference(const struct object_id *oid);
+struct commit *lookup_commit_reference_gently(const struct object_id 
*oid,
 					      int quiet);
 struct commit *lookup_commit_reference_by_name(const char *name);
 
 /*
- * Look up object named by "sha1", dereference tag as necessary,
- * get a commit and return it. If "sha1" does not dereference to
+ * Look up object named by "oid", dereference tag as necessary,
+ * get a commit and return it. If "oid" does not dereference to
  * a commit, use ref_name to report an error and die.
  */
-struct commit *lookup_commit_or_die(const unsigned char *sha1, const 
char *ref_name);
+struct commit *lookup_commit_or_die(const struct object_id *oid, const 
char *ref_name);
 
 int parse_commit_buffer(struct commit *item, const void *buffer, 
unsigned long size);
 int parse_commit_gently(struct commit *item, int quiet_on_missing);
diff --git a/fast-import.c b/fast-import.c
index 2706eb2fe..d5de1545b 100644
--- a/fast-import.c
+++ b/fast-import.c
@@ -1761,8 +1761,8 @@ static int update_branch(struct branch *b)
 	if (!force_update &amp;&amp; !is_null_oid(&amp;old_oid)) {
 		struct commit *old_cmit, *new_cmit;
 
-		old_cmit = lookup_commit_reference_gently(old_oid.hash, 0);
-		new_cmit = lookup_commit_reference_gently(b-&gt;oid.hash, 0);
+		old_cmit = lookup_commit_reference_gently(&amp;old_oid, 0);
+		new_cmit = lookup_commit_reference_gently(&amp;b-&gt;oid, 0);
 		if (!old_cmit || !new_cmit)
 			return error("Branch %s is missing commits.", b-&gt;name);
 
diff --git a/fetch-pack.c b/fetch-pack.c
index d455ef97a..7ec75f278 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
@@ -483,7 +483,7 @@ static int find_common(struct fetch_pack_args *args,
 				case ACK_ready:
 				case ACK_continue: {
 					struct commit *commit =
-						lookup_commit(result_oid-&gt;hash);
+						lookup_commit(result_oid);
 					if (!commit)
 						die(_("invalid commit %s"), oid_to_hex(result_oid));
 					if (args-&gt;stateless_rpc
diff --git a/http-push.c b/http-push.c
index f3dd0a560..04568e4fb 100644
--- a/http-push.c
+++ b/http-push.c
@@ -1569,8 +1569,9 @@ static void fetch_symref(const char *path, char 
**symref, struct object_id *oid)
 
 static int verify_merge_base(struct object_id *head_oid, struct ref 
*remote)
 {
-	struct commit *head = lookup_commit_or_die(head_oid-&gt;hash, "HEAD");
-	struct commit *branch = lookup_commit_or_die(remote-&gt;old_oid.hash, 
remote-&gt;name);
+	struct commit *head = lookup_commit_or_die(head_oid, "HEAD");
+	struct commit *branch = lookup_commit_or_die(&amp;remote-&gt;old_oid,
+						     remote-&gt;name);
 
 	return in_merge_bases(branch, head);
 }
diff --git a/log-tree.c b/log-tree.c
index 4618dd04c..7fb1a85d2 100644
--- a/log-tree.c
+++ b/log-tree.c
@@ -140,7 +140,7 @@ static int add_ref_decoration(const char *refname, 
const struct object_id *oid,
 
 static int add_graft_decoration(const struct commit_graft *graft, void 
*cb_data)
 {
-	struct commit *commit = lookup_commit(graft-&gt;oid.hash);
+	struct commit *commit = lookup_commit(&amp;graft-&gt;oid);
 	if (!commit)
 		return 0;
 	add_name_decoration(DECORATION_GRAFTED, "grafted", 
&amp;commit-&gt;object);
diff --git a/notes-cache.c b/notes-cache.c
index 1cdd4984a..2843e9857 100644
--- a/notes-cache.c
+++ b/notes-cache.c
@@ -14,7 +14,7 @@ static int notes_cache_match_validity(const char *ref,
 const char *validity)
 	if (read_ref(ref, oid.hash) &lt; 0)
 		return 0;
 
-	commit = lookup_commit_reference_gently(oid.hash, 1);
+	commit = lookup_commit_reference_gently(&amp;oid, 1);
 	if (!commit)
 		return 0;
 
diff --git a/notes-merge.c b/notes-merge.c
index 06d8be9cb..6244f6af9 100644
--- a/notes-merge.c
+++ b/notes-merge.c
@@ -554,7 +554,7 @@ int notes_merge(struct notes_merge_options *o,
 	else if (!check_refname_format(o-&gt;local_ref, 0) &amp;&amp;
 		is_null_oid(&amp;local_oid))
 		local = NULL; /* local_sha1 == null_sha1 indicates unborn ref */
-	else if (!(local = lookup_commit_reference(local_oid.hash)))
+	else if (!(local = lookup_commit_reference(&amp;local_oid)))
 		die("Could not parse local commit %s (%s)",
 		    oid_to_hex(&amp;local_oid), o-&gt;local_ref);
 	trace_printf("\tlocal commit: %.7s\n", oid_to_hex(&amp;local_oid));
@@ -572,7 +572,7 @@ int notes_merge(struct notes_merge_options *o,
 			die("Failed to resolve remote notes ref '%s'",
 			    o-&gt;remote_ref);
 		}
-	} else if (!(remote = lookup_commit_reference(remote_oid.hash))) {
+	} else if (!(remote = lookup_commit_reference(&amp;remote_oid))) {
 		die("Could not parse remote commit %s (%s)",
 		    oid_to_hex(&amp;remote_oid), o-&gt;remote_ref);
 	}
diff --git a/notes-utils.c b/notes-utils.c
index 36c1490aa..325ff3daa 100644
--- a/notes-utils.c
+++ b/notes-utils.c
@@ -18,7 +18,7 @@ void create_notes_commit(struct notes_tree *t, struct 
commit_list *parents,
 		/* Deduce parent commit from t-&gt;ref */
 		struct object_id parent_oid;
 		if (!read_ref(t-&gt;ref, parent_oid.hash)) {
-			struct commit *parent = lookup_commit(parent_oid.hash);
+			struct commit *parent = lookup_commit(&amp;parent_oid);
 			if (parse_commit(parent))
 				die("Failed to find/parse commit %s", t-&gt;ref);
 			commit_list_insert(parent, &amp;parents);
diff --git a/object.c b/object.c
index e680d881a..fe2222356 100644
--- a/object.c
+++ b/object.c
@@ -182,9 +182,12 @@ struct object *lookup_unknown_object(const unsigned
 char *sha1)
 
 struct object *parse_object_buffer(const unsigned char *sha1, enum 
object_type type, unsigned long size, void *buffer, int *eaten_p)
 {
+	struct object_id oid;
 	struct object *obj;
 	*eaten_p = 0;
 
+	hashcpy(oid.hash, sha1);
+
 	obj = NULL;
 	if (type == OBJ_BLOB) {
 		struct blob *blob = lookup_blob(sha1);
@@ -206,7 +209,7 @@ struct object *parse_object_buffer(const unsigned 
char *sha1, enum object_type t
 			}
 		}
 	} else if (type == OBJ_COMMIT) {
-		struct commit *commit = lookup_commit(sha1);
+		struct commit *commit = lookup_commit(&amp;oid);
 		if (commit) {
 			if (parse_commit_buffer(commit, buffer, size))
 				return NULL;
diff --git a/parse-options-cb.c b/parse-options-cb.c
index 35a941fdd..8dd57cf6e 100644
--- a/parse-options-cb.c
+++ b/parse-options-cb.c
@@ -87,7 +87,7 @@ int parse_opt_commits(const struct option *opt, const 
char *arg, int unset)
 		return -1;
 	if (get_oid(arg, &amp;oid))
 		return error("malformed object name %s", arg);
-	commit = lookup_commit_reference(oid.hash);
+	commit = lookup_commit_reference(&amp;oid);
 	if (!commit)
 		return error("no such commit %s", arg);
 	commit_list_insert(commit, opt-&gt;value);
diff --git a/ref-filter.c b/ref-filter.c
index 47cce0a18..e1d18ac0d 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -1782,7 +1782,7 @@ static int ref_filter_handler(const char *refname,
 const struct object_id *oid,
 	 * non-commits early. The actual filtering is done later.
 	 */
 	if (filter-&gt;merge_commit || filter-&gt;with_commit || 
filter-&gt;no_commit || filter-&gt;verbose) {
-		commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+		commit = lookup_commit_reference_gently(oid, 1);
 		if (!commit)
 			return 0;
 		/* We perform the filtering for the '--contains' option... */
@@ -2108,7 +2108,7 @@ int parse_opt_merge_filter(const struct option 
*opt, const char *arg, int unset)
 	if (get_oid(arg, &amp;oid))
 		die(_("malformed object name %s"), arg);
 
-	rf-&gt;merge_commit = lookup_commit_reference_gently(oid.hash, 0);
+	rf-&gt;merge_commit = lookup_commit_reference_gently(&amp;oid, 0);
 	if (!rf-&gt;merge_commit)
 		return opterror(opt, "must point to a commit", 0);
 
diff --git a/remote.c b/remote.c
index 801137c72..bf9a47d95 100644
--- a/remote.c
+++ b/remote.c
@@ -1296,7 +1296,7 @@ static void add_to_tips(struct tips *tips, const 
struct object_id *oid)
 
 	if (is_null_oid(oid))
 		return;
-	commit = lookup_commit_reference_gently(oid-&gt;hash, 1);
+	commit = lookup_commit_reference_gently(oid, 1);
 	if (!commit || (commit-&gt;object.flags &amp; TMP_MARK))
 		return;
 	commit-&gt;object.flags |= TMP_MARK;
@@ -1358,7 +1358,8 @@ static void add_missing_tags(struct ref *src, 
struct ref **dst, struct ref ***ds
 
 			if (is_null_oid(&amp;ref-&gt;new_oid))
 				continue;
-			commit = lookup_commit_reference_gently(ref-&gt;new_oid.hash, 1);
+			commit = lookup_commit_reference_gently(&amp;ref-&gt;new_oid,
+								1);
 			if (!commit)
 				/* not pushing a commit, which is not an error */
 				continue;
@@ -1585,8 +1586,8 @@ void set_ref_status_for_push(struct ref 
*remote_refs, int send_mirror,
 				reject_reason = REF_STATUS_REJECT_ALREADY_EXISTS;
 			else if (!has_object_file(&amp;ref-&gt;old_oid))
 				reject_reason = REF_STATUS_REJECT_FETCH_FIRST;
-			else if (!lookup_commit_reference_gently(ref-&gt;old_oid.hash, 1) ||
-				 !lookup_commit_reference_gently(ref-&gt;new_oid.hash, 1))
+			else if (!lookup_commit_reference_gently(&amp;ref-&gt;old_oid, 1) ||
+				 !lookup_commit_reference_gently(&amp;ref-&gt;new_oid, 1))
 				reject_reason = REF_STATUS_REJECT_NEEDS_FORCE;
 			else if (!ref_newer(&amp;ref-&gt;new_oid, &amp;ref-&gt;old_oid))
 				reject_reason = REF_STATUS_REJECT_NONFASTFORWARD;
@@ -2009,13 +2010,13 @@ int stat_tracking_info(struct branch *branch, 
int *num_ours, int *num_theirs,
 	/* Cannot stat if what we used to build on no longer exists */
 	if (read_ref(base, oid.hash))
 		return -1;
-	theirs = lookup_commit_reference(oid.hash);
+	theirs = lookup_commit_reference(&amp;oid);
 	if (!theirs)
 		return -1;
 
 	if (read_ref(branch-&gt;refname, oid.hash))
 		return -1;
-	ours = lookup_commit_reference(oid.hash);
+	ours = lookup_commit_reference(&amp;oid);
 	if (!ours)
 		return -1;
 
diff --git a/revision.c b/revision.c
index 945367034..f8e0dee6d 100644
--- a/revision.c
+++ b/revision.c
@@ -1395,10 +1395,10 @@ static void prepare_show_merge(struct rev_info 
*revs)
 
 	if (get_oid("HEAD", &amp;oid))
 		die("--merge without HEAD?");
-	head = lookup_commit_or_die(oid.hash, "HEAD");
+	head = lookup_commit_or_die(&amp;oid, "HEAD");
 	if (get_oid("MERGE_HEAD", &amp;oid))
 		die("--merge without MERGE_HEAD?");
-	other = lookup_commit_or_die(oid.hash, "MERGE_HEAD");
+	other = lookup_commit_or_die(&amp;oid, "MERGE_HEAD");
 	add_pending_object(revs, &amp;head-&gt;object, "HEAD");
 	add_pending_object(revs, &amp;other-&gt;object, "MERGE_HEAD");
 	bases = get_merge_bases(head, other);
@@ -1500,10 +1500,10 @@ int handle_revision_arg(const char *arg_, struct
 rev_info *revs, int flags, unsi
 
 				a = (a_obj-&gt;type == OBJ_COMMIT
 				     ? (struct commit *)a_obj
-				     : lookup_commit_reference(a_obj-&gt;oid.hash));
+				     : lookup_commit_reference(&amp;a_obj-&gt;oid));
 				b = (b_obj-&gt;type == OBJ_COMMIT
 				     ? (struct commit *)b_obj
-				     : lookup_commit_reference(b_obj-&gt;oid.hash));
+				     : lookup_commit_reference(&amp;b_obj-&gt;oid));
 				if (!a || !b)
 					goto missing;
 				exclude = get_merge_bases(a, b);
diff --git a/sequencer.c b/sequencer.c
index e0d0e98a4..e98a896d7 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -488,7 +488,7 @@ static int is_index_unchanged(void)
 	if (!resolve_ref_unsafe("HEAD", RESOLVE_REF_READING, head_oid.hash, 
NULL))
 		return error(_("could not resolve HEAD commit\n"));
 
-	head_commit = lookup_commit(head_oid.hash);
+	head_commit = lookup_commit(&amp;head_oid);
 
 	/*
 	 * If head_commit is NULL, check_commit, called from
@@ -841,7 +841,7 @@ static int update_squash_messages(enum todo_command 
command,
 
 		if (get_oid("HEAD", &amp;head))
 			return error(_("need a HEAD to fixup"));
-		if (!(head_commit = lookup_commit_reference(head.hash)))
+		if (!(head_commit = lookup_commit_reference(&amp;head)))
 			return error(_("could not read HEAD"));
 		if (!(head_message = get_commit_buffer(head_commit, NULL)))
 			return error(_("could not read HEAD's commit message"));
@@ -1279,7 +1279,7 @@ static int parse_insn_line(struct todo_item *item,
 const char *bol, char *eol)
 	if (status &lt; 0)
 		return -1;
 
-	item-&gt;commit = lookup_commit_reference(commit_oid.hash);
+	item-&gt;commit = lookup_commit_reference(&amp;commit_oid);
 	return !item-&gt;commit;
 }
 
@@ -2275,7 +2275,7 @@ int sequencer_pick_revisions(struct replay_opts 
*opts)
 			continue;
 
 		if (!get_oid(name, &amp;oid)) {
-			if (!lookup_commit_reference_gently(oid.hash, 1)) {
+			if (!lookup_commit_reference_gently(&amp;oid, 1)) {
 				enum object_type type = sha1_object_info(oid.hash, NULL);
 				return error(_("%s: can't cherry-pick a %s"),
 					name, typename(type));
diff --git a/sha1_name.c b/sha1_name.c
index 8889190a9..390a09c41 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -354,7 +354,7 @@ static int show_ambiguous_object(const struct 
object_id *oid, void *data)
 
 	type = sha1_object_info(oid-&gt;hash, NULL);
 	if (type == OBJ_COMMIT) {
-		struct commit *commit = lookup_commit(oid-&gt;hash);
+		struct commit *commit = lookup_commit(oid);
 		if (commit) {
 			struct pretty_print_context pp = {0};
 			pp.date_mode.type = DATE_SHORT;
@@ -729,7 +729,7 @@ static int get_parent(const char *name, int len,
 
 	if (ret)
 		return ret;
-	commit = lookup_commit_reference(oid.hash);
+	commit = lookup_commit_reference(&amp;oid);
 	if (parse_commit(commit))
 		return -1;
 	if (!idx) {
@@ -757,7 +757,7 @@ static int get_nth_ancestor(const char *name, int 
len,
 	ret = get_sha1_1(name, len, oid.hash, GET_SHA1_COMMITTISH);
 	if (ret)
 		return ret;
-	commit = lookup_commit_reference(oid.hash);
+	commit = lookup_commit_reference(&amp;oid);
 	if (!commit)
 		return -1;
 
@@ -1136,13 +1136,13 @@ int get_oid_mb(const char *name, struct 
object_id *oid)
 	}
 	if (st)
 		return st;
-	one = lookup_commit_reference_gently(oid_tmp.hash, 0);
+	one = lookup_commit_reference_gently(&amp;oid_tmp, 0);
 	if (!one)
 		return -1;
 
 	if (get_sha1_committish(dots[3] ? (dots + 3) : "HEAD", oid_tmp.hash))
 		return -1;
-	two = lookup_commit_reference_gently(oid_tmp.hash, 0);
+	two = lookup_commit_reference_gently(&amp;oid_tmp, 0);
 	if (!two)
 		return -1;
 	mbs = get_merge_bases(one, two);
diff --git a/shallow.c b/shallow.c
index 1327ee16f..6950cc24f 100644
--- a/shallow.c
+++ b/shallow.c
@@ -31,7 +31,7 @@ int register_shallow(const struct object_id *oid)
 {
 	struct commit_graft *graft =
 		xmalloc(sizeof(struct commit_graft));
-	struct commit *commit = lookup_commit(oid-&gt;hash);
+	struct commit *commit = lookup_commit(oid);
 
 	oidcpy(&amp;graft-&gt;oid, oid);
 	graft-&gt;nr_parent = -1;
@@ -241,7 +241,7 @@ static int write_one_shallow(const struct 
commit_graft *graft, void *cb_data)
 	if (graft-&gt;nr_parent != -1)
 		return 0;
 	if (data-&gt;flags &amp; SEEN_ONLY) {
-		struct commit *c = lookup_commit(graft-&gt;oid.hash);
+		struct commit *c = lookup_commit(&amp;graft-&gt;oid);
 		if (!c || !(c-&gt;object.flags &amp; SEEN)) {
 			if (data-&gt;flags &amp; VERBOSE)
 				printf("Removing %s from .git/shallow\n",
@@ -475,7 +475,7 @@ static void paint_down(struct paint_info *info, 
const struct object_id *oid,
 	size_t bitmap_size = st_mult(sizeof(uint32_t), bitmap_nr);
 	uint32_t *tmp = xmalloc(bitmap_size); /* to be freed before return */
 	uint32_t *bitmap = paint_alloc(info);
-	struct commit *c = lookup_commit_reference_gently(oid-&gt;hash, 1);
+	struct commit *c = lookup_commit_reference_gently(oid, 1);
 	if (!c)
 		return;
 	memset(bitmap, 0, bitmap_size);
@@ -531,7 +531,7 @@ static void paint_down(struct paint_info *info, 
const struct object_id *oid,
 static int mark_uninteresting(const char *refname, const struct 
object_id *oid,
 			      int flags, void *cb_data)
 {
-	struct commit *commit = lookup_commit_reference_gently(oid-&gt;hash, 
1);
+	struct commit *commit = lookup_commit_reference_gently(oid, 1);
 	if (!commit)
 		return 0;
 	commit-&gt;object.flags |= UNINTERESTING;
@@ -599,7 +599,7 @@ void assign_shallow_commits_to_refs(struct 
shallow_info *info,
 
 	/* Mark potential bottoms so we won't go out of bound */
 	for (i = 0; i &lt; nr_shallow; i++) {
-		struct commit *c = lookup_commit(oid[shallow[i]].hash);
+		struct commit *c = lookup_commit(&amp;oid[shallow[i]]);
 		c-&gt;object.flags |= BOTTOM;
 	}
 
@@ -610,7 +610,7 @@ void assign_shallow_commits_to_refs(struct 
shallow_info *info,
 		int bitmap_size = ((pi.nr_bits + 31) / 32) * sizeof(uint32_t);
 		memset(used, 0, sizeof(*used) * info-&gt;shallow-&gt;nr);
 		for (i = 0; i &lt; nr_shallow; i++) {
-			const struct commit *c = lookup_commit(oid[shallow[i]].hash);
+			const struct commit *c = lookup_commit(&amp;oid[shallow[i]]);
 			uint32_t **map = ref_bitmap_at(&amp;pi.ref_bitmap, c);
 			if (*map)
 				used[shallow[i]] = xmemdupz(*map, bitmap_size);
@@ -641,7 +641,7 @@ static int add_ref(const char *refname, const struct
 object_id *oid,
 {
 	struct commit_array *ca = cb_data;
 	ALLOC_GROW(ca-&gt;commits, ca-&gt;nr + 1, ca-&gt;alloc);
-	ca-&gt;commits[ca-&gt;nr] = 
lookup_commit_reference_gently(oid-&gt;hash, 1);
+	ca-&gt;commits[ca-&gt;nr] = lookup_commit_reference_gently(oid, 1);
 	if (ca-&gt;commits[ca-&gt;nr])
 		ca-&gt;nr++;
 	return 0;
@@ -679,7 +679,7 @@ static void post_assign_shallow(struct shallow_info 
*info,
 	for (i = dst = 0; i &lt; info-&gt;nr_theirs; i++) {
 		if (i != dst)
 			info-&gt;theirs[dst] = info-&gt;theirs[i];
-		c = lookup_commit(oid[info-&gt;theirs[i]].hash);
+		c = lookup_commit(&amp;oid[info-&gt;theirs[i]]);
 		bitmap = ref_bitmap_at(ref_bitmap, c);
 		if (!*bitmap)
 			continue;
@@ -700,7 +700,7 @@ static void post_assign_shallow(struct shallow_info 
*info,
 	for (i = dst = 0; i &lt; info-&gt;nr_ours; i++) {
 		if (i != dst)
 			info-&gt;ours[dst] = info-&gt;ours[i];
-		c = lookup_commit(oid[info-&gt;ours[i]].hash);
+		c = lookup_commit(&amp;oid[info-&gt;ours[i]]);
 		bitmap = ref_bitmap_at(ref_bitmap, c);
 		if (!*bitmap)
 			continue;
@@ -722,7 +722,7 @@ static void post_assign_shallow(struct shallow_info 
*info,
 int delayed_reachability_test(struct shallow_info *si, int c)
 {
 	if (si-&gt;need_reachability_test[c]) {
-		struct commit *commit = 
lookup_commit(si-&gt;shallow-&gt;oid[c].hash);
+		struct commit *commit = 
lookup_commit(&amp;si-&gt;shallow-&gt;oid[c]);
 
 		if (!si-&gt;commits) {
 			struct commit_array ca;
diff --git a/submodule.c b/submodule.c
index d5c28b9f1..ba5429be1 100644
--- a/submodule.c
+++ b/submodule.c
@@ -447,8 +447,8 @@ static void show_submodule_header(FILE *f, const 
char *path,
 	 * Attempt to lookup the commit references, and determine if this is
 	 * a fast forward or fast backwards update.
 	 */
-	*left = lookup_commit_reference(one-&gt;hash);
-	*right = lookup_commit_reference(two-&gt;hash);
+	*left = lookup_commit_reference(one);
+	*right = lookup_commit_reference(two);
 
 	/*
 	 * Warn about missing commits in the submodule project, but only if
@@ -634,7 +634,7 @@ static int check_has_commit(const struct object_id 
*oid, void *data)
 {
 	int *has_commit = data;
 
-	if (!lookup_commit_reference(oid-&gt;hash))
+	if (!lookup_commit_reference(oid))
 		*has_commit = 0;
 
 	return 0;
@@ -899,7 +899,7 @@ int push_unpushed_submodules(struct oid_array 
*commits,
 static int is_submodule_commit_present(const char *path, struct 
object_id *oid)
 {
 	int is_present = 0;
-	if (!add_submodule_odb(path) &amp;&amp; 
lookup_commit_reference(oid-&gt;hash)) {
+	if (!add_submodule_odb(path) &amp;&amp; lookup_commit_reference(oid)) {
 		/* Even if the submodule is checked out and the commit is
 		 * present, make sure it is reachable from a ref. */
 		struct child_process cp = CHILD_PROCESS_INIT;
@@ -1592,9 +1592,9 @@ int merge_submodule(struct object_id *result, 
const char *path,
 		return 0;
 	}
 
-	if (!(commit_base = lookup_commit_reference(base-&gt;hash)) ||
-	    !(commit_a = lookup_commit_reference(a-&gt;hash)) ||
-	    !(commit_b = lookup_commit_reference(b-&gt;hash))) {
+	if (!(commit_base = lookup_commit_reference(base)) ||
+	    !(commit_a = lookup_commit_reference(a)) ||
+	    !(commit_b = lookup_commit_reference(b))) {
 		MERGE_WARNING(path, "commits not present");
 		return 0;
 	}
diff --git a/tag.c b/tag.c
index 625f5cd71..79b78d358 100644
--- a/tag.c
+++ b/tag.c
@@ -146,7 +146,7 @@ int parse_tag_buffer(struct tag *item, const void 
*data, unsigned long size)
 	} else if (!strcmp(type, tree_type)) {
 		item-&gt;tagged = &amp;lookup_tree(oid.hash)-&gt;object;
 	} else if (!strcmp(type, commit_type)) {
-		item-&gt;tagged = &amp;lookup_commit(oid.hash)-&gt;object;
+		item-&gt;tagged = &amp;lookup_commit(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, tag_type)) {
 		item-&gt;tagged = &amp;lookup_tag(oid.hash)-&gt;object;
 	} else {
diff --git a/tree.c b/tree.c
index ce345c551..33fa7ee71 100644
--- a/tree.c
+++ b/tree.c
@@ -91,7 +91,7 @@ static int read_tree_1(struct tree *tree, struct 
strbuf *base,
 		else if (S_ISGITLINK(entry.mode)) {
 			struct commit *commit;
 
-			commit = lookup_commit(entry.oid-&gt;hash);
+			commit = lookup_commit(entry.oid);
 			if (!commit)
 				die("Commit %s in submodule path %s%s not found",
 				    oid_to_hex(entry.oid),
diff --git a/walker.c b/walker.c
index 2c86e406f..b499fcb72 100644
--- a/walker.c
+++ b/walker.c
@@ -206,7 +206,7 @@ static int interpret_target(struct walker *walker, 
char *target, unsigned char *
 static int mark_complete(const char *path, const struct object_id *oid,
 			 int flag, void *cb_data)
 {
-	struct commit *commit = lookup_commit_reference_gently(oid-&gt;hash, 
1);
+	struct commit *commit = lookup_commit_reference_gently(oid, 1);
 
 	if (commit) {
 		commit-&gt;object.flags |= COMPLETE;
diff --git a/wt-status.c b/wt-status.c
index 037548496..e5854ba6f 100644
--- a/wt-status.c
+++ b/wt-status.c
@@ -1428,7 +1428,7 @@ static void wt_status_get_detached_from(struct 
wt_status_state *state)
 	    /* sha1 is a commit? match without further lookup */
 	    (!oidcmp(&amp;cb.noid, &amp;oid) ||
 	     /* perhaps sha1 is a tag, try to dereference to a commit */
-	     ((commit = lookup_commit_reference_gently(oid.hash, 1)) != NULL 
&amp;&amp;
+	     ((commit = lookup_commit_reference_gently(&amp;oid, 1)) != NULL 
&amp;&amp;
 	      !oidcmp(&amp;cb.noid, &amp;commit-&gt;object.oid)))) {
 		const char *from = ref;
 		if (!skip_prefix(from, "refs/tags/", &amp;from))

<a href="#m2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952" id="e2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-26-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">52+ messages in thread</a></pre><hr><pre><a href="#e891b1840f7953004bf78a2705362287ba2ff8e22" id="m891b1840f7953004bf78a2705362287ba2ff8e22">*</a> <b>[PATCH v2 26/53] pack: convert struct pack_idx_entry to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">(22 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">[PATCH v2 25/53] Convert lookup_commit* to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m76defffb3dd7d6d7027beed4ec6a0db95d866870">[PATCH v2 27/53] builtin/unpack-objects: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r76defffb3dd7d6d7027beed4ec6a0db95d866870">(26 subsequent siblings)</a>
  <a href="#r891b1840f7953004bf78a2705362287ba2ff8e22">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert struct pack_idx_entry to use struct object_id by changing the
definition and applying the following semantic patch, plus the standard
object_id transforms:

@@
struct pack_idx_entry E1;
@@
- E1.sha1
+ E1.oid.hash

@@
struct pack_idx_entry *E1;
@@
- E1-&gt;sha1
+ E1-&gt;oid.hash

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/index-pack.c   | 33 +++++++++++++++-----------
 builtin/pack-objects.c | 63 +++++++++++++++++++++++++++++---------------------
 bulk-checkin.c         |  4 ++--
 fast-import.c          | 30 ++++++++++++------------
 pack-bitmap-write.c    |  8 ++++---
 pack-objects.c         |  8 ++++---
 pack-write.c           | 10 ++++----
 pack.h                 |  2 +-
 8 files changed, 89 insertions(+), 69 deletions(-)

diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index 4ff567db4..fef0025e4 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -747,13 +747,13 @@ static int compare_objects(const unsigned char *buf, unsigned long size,
 		ssize_t len = read_istream(data-&gt;st, data-&gt;buf, size);
 		if (len == 0)
 			die(_("SHA1 COLLISION FOUND WITH %s !"),
-			    sha1_to_hex(data-&gt;entry-&gt;idx.sha1));
+			    oid_to_hex(&amp;data-&gt;entry-&gt;idx.oid));
 		if (len &lt; 0)
 			die(_("unable to read %s"),
-			    sha1_to_hex(data-&gt;entry-&gt;idx.sha1));
+			    oid_to_hex(&amp;data-&gt;entry-&gt;idx.oid));
 		if (memcmp(buf, data-&gt;buf, len))
 			die(_("SHA1 COLLISION FOUND WITH %s !"),
-			    sha1_to_hex(data-&gt;entry-&gt;idx.sha1));
+			    oid_to_hex(&amp;data-&gt;entry-&gt;idx.oid));
 		size -= len;
 		buf += len;
 	}
@@ -771,12 +771,12 @@ static int check_collison(struct object_entry *entry)
 
 	memset(&amp;data, 0, sizeof(data));
 	data.entry = entry;
-	data.st = open_istream(entry-&gt;idx.sha1, &amp;type, &amp;size, NULL);
+	data.st = open_istream(entry-&gt;idx.oid.hash, &amp;type, &amp;size, NULL);
 	if (!data.st)
 		return -1;
 	if (size != entry-&gt;size || type != entry-&gt;type)
 		die(_("SHA1 COLLISION FOUND WITH %s !"),
-		    sha1_to_hex(entry-&gt;idx.sha1));
+		    oid_to_hex(&amp;entry-&gt;idx.oid));
 	unpack_data(entry, compare_objects, &amp;data);
 	close_istream(data.st);
 	free(data.buf);
@@ -957,9 +957,10 @@ static void resolve_delta(struct object_entry *delta_obj,
 	if (!result-&gt;data)
 		bad_object(delta_obj-&gt;idx.offset, _("failed to apply delta"));
 	hash_sha1_file(result-&gt;data, result-&gt;size,
-		       typename(delta_obj-&gt;real_type), delta_obj-&gt;idx.sha1);
+		       typename(delta_obj-&gt;real_type),
+		       delta_obj-&gt;idx.oid.hash);
 	sha1_object(result-&gt;data, NULL, result-&gt;size, delta_obj-&gt;real_type,
-		    delta_obj-&gt;idx.sha1);
+		    delta_obj-&gt;idx.oid.hash);
 	counter_lock();
 	nr_resolved_deltas++;
 	counter_unlock();
@@ -989,7 +990,7 @@ static struct base_data *find_unresolved_deltas_1(struct base_data *base,
 						  struct base_data *prev_base)
 {
 	if (base-&gt;ref_last == -1 &amp;&amp; base-&gt;ofs_last == -1) {
-		find_ref_delta_children(base-&gt;obj-&gt;idx.sha1,
+		find_ref_delta_children(base-&gt;obj-&gt;idx.oid.hash,
 					&amp;base-&gt;ref_first, &amp;base-&gt;ref_last,
 					OBJ_REF_DELTA);
 
@@ -1130,7 +1131,8 @@ static void parse_pack_objects(unsigned char *sha1)
 	for (i = 0; i &lt; nr_objects; i++) {
 		struct object_entry *obj = &amp;objects[i];
 		void *data = unpack_raw_entry(obj, &amp;ofs_delta-&gt;offset,
-					      ref_delta_sha1, obj-&gt;idx.sha1);
+					      ref_delta_sha1,
+					      obj-&gt;idx.oid.hash);
 		obj-&gt;real_type = obj-&gt;type;
 		if (obj-&gt;type == OBJ_OFS_DELTA) {
 			nr_ofs_deltas++;
@@ -1146,7 +1148,8 @@ static void parse_pack_objects(unsigned char *sha1)
 			obj-&gt;real_type = OBJ_BAD;
 			nr_delays++;
 		} else
-			sha1_object(data, NULL, obj-&gt;size, obj-&gt;type, obj-&gt;idx.sha1);
+			sha1_object(data, NULL, obj-&gt;size, obj-&gt;type,
+				    obj-&gt;idx.oid.hash);
 		free(data);
 		display_progress(progress, i+1);
 	}
@@ -1172,7 +1175,8 @@ static void parse_pack_objects(unsigned char *sha1)
 		if (obj-&gt;real_type != OBJ_BAD)
 			continue;
 		obj-&gt;real_type = obj-&gt;type;
-		sha1_object(NULL, obj, obj-&gt;size, obj-&gt;type, obj-&gt;idx.sha1);
+		sha1_object(NULL, obj, obj-&gt;size, obj-&gt;type,
+			    obj-&gt;idx.oid.hash);
 		nr_delays--;
 	}
 	if (nr_delays)
@@ -1330,7 +1334,7 @@ static struct object_entry *append_obj_to_pack(struct sha1file *f,
 	obj[1].idx.offset += write_compressed(f, buf, size);
 	obj[0].idx.crc32 = crc32_end(f);
 	sha1flush(f);
-	hashcpy(obj-&gt;idx.sha1, sha1);
+	hashcpy(obj-&gt;idx.oid.hash, sha1);
 	return obj;
 }
 
@@ -1581,13 +1585,14 @@ static void show_pack_info(int stat_only)
 		if (stat_only)
 			continue;
 		printf("%s %-6s %lu %lu %"PRIuMAX,
-		       sha1_to_hex(obj-&gt;idx.sha1),
+		       oid_to_hex(&amp;obj-&gt;idx.oid),
 		       typename(obj-&gt;real_type), obj-&gt;size,
 		       (unsigned long)(obj[1].idx.offset - obj-&gt;idx.offset),
 		       (uintmax_t)obj-&gt;idx.offset);
 		if (is_delta_type(obj-&gt;type)) {
 			struct object_entry *bobj = &amp;objects[obj_stat[i].base_object_no];
-			printf(" %u %s", obj_stat[i].delta_depth, sha1_to_hex(bobj-&gt;idx.sha1));
+			printf(" %u %s", obj_stat[i].delta_depth,
+			       oid_to_hex(&amp;bobj-&gt;idx.oid));
 		}
 		putchar('\n');
 	}
diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index 477070806..d76ff0542 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -106,12 +106,14 @@ static void *get_delta(struct object_entry *entry)
 	void *buf, *base_buf, *delta_buf;
 	enum object_type type;
 
-	buf = read_sha1_file(entry-&gt;idx.sha1, &amp;type, &amp;size);
+	buf = read_sha1_file(entry-&gt;idx.oid.hash, &amp;type, &amp;size);
 	if (!buf)
-		die("unable to read %s", sha1_to_hex(entry-&gt;idx.sha1));
-	base_buf = read_sha1_file(entry-&gt;delta-&gt;idx.sha1, &amp;type, &amp;base_size);
+		die("unable to read %s", oid_to_hex(&amp;entry-&gt;idx.oid));
+	base_buf = read_sha1_file(entry-&gt;delta-&gt;idx.oid.hash, &amp;type,
+				  &amp;base_size);
 	if (!base_buf)
-		die("unable to read %s", sha1_to_hex(entry-&gt;delta-&gt;idx.sha1));
+		die("unable to read %s",
+		    oid_to_hex(&amp;entry-&gt;delta-&gt;idx.oid));
 	delta_buf = diff_delta(base_buf, base_size,
 			       buf, size, &amp;delta_size, 0);
 	if (!delta_buf || delta_size != entry-&gt;delta_size)
@@ -249,12 +251,14 @@ static unsigned long write_no_reuse_object(struct sha1file *f, struct object_ent
 	if (!usable_delta) {
 		if (entry-&gt;type == OBJ_BLOB &amp;&amp;
 		    entry-&gt;size &gt; big_file_threshold &amp;&amp;
-		    (st = open_istream(entry-&gt;idx.sha1, &amp;type, &amp;size, NULL)) != NULL)
+		    (st = open_istream(entry-&gt;idx.oid.hash, &amp;type, &amp;size, NULL)) != NULL)
 			buf = NULL;
 		else {
-			buf = read_sha1_file(entry-&gt;idx.sha1, &amp;type, &amp;size);
+			buf = read_sha1_file(entry-&gt;idx.oid.hash, &amp;type,
+					     &amp;size);
 			if (!buf)
-				die(_("unable to read %s"), sha1_to_hex(entry-&gt;idx.sha1));
+				die(_("unable to read %s"),
+				    oid_to_hex(&amp;entry-&gt;idx.oid));
 		}
 		/*
 		 * make sure no cached delta data remains from a
@@ -322,7 +326,7 @@ static unsigned long write_no_reuse_object(struct sha1file *f, struct object_ent
 			return 0;
 		}
 		sha1write(f, header, hdrlen);
-		sha1write(f, entry-&gt;delta-&gt;idx.sha1, 20);
+		sha1write(f, entry-&gt;delta-&gt;idx.oid.hash, 20);
 		hdrlen += 20;
 	} else {
 		if (limit &amp;&amp; hdrlen + datalen + 20 &gt;= limit) {
@@ -334,7 +338,7 @@ static unsigned long write_no_reuse_object(struct sha1file *f, struct object_ent
 		sha1write(f, header, hdrlen);
 	}
 	if (st) {
-		datalen = write_large_blob_data(st, f, entry-&gt;idx.sha1);
+		datalen = write_large_blob_data(st, f, entry-&gt;idx.oid.hash);
 		close_istream(st);
 	} else {
 		sha1write(f, buf, datalen);
@@ -369,7 +373,8 @@ static off_t write_reuse_object(struct sha1file *f, struct object_entry *entry,
 	datalen = revidx[1].offset - offset;
 	if (!pack_to_stdout &amp;&amp; p-&gt;index_version &gt; 1 &amp;&amp;
 	    check_pack_crc(p, &amp;w_curs, offset, datalen, revidx-&gt;nr)) {
-		error("bad packed object CRC for %s", sha1_to_hex(entry-&gt;idx.sha1));
+		error("bad packed object CRC for %s",
+		      oid_to_hex(&amp;entry-&gt;idx.oid));
 		unuse_pack(&amp;w_curs);
 		return write_no_reuse_object(f, entry, limit, usable_delta);
 	}
@@ -379,7 +384,8 @@ static off_t write_reuse_object(struct sha1file *f, struct object_entry *entry,
 
 	if (!pack_to_stdout &amp;&amp; p-&gt;index_version == 1 &amp;&amp;
 	    check_pack_inflate(p, &amp;w_curs, offset, datalen, entry-&gt;size)) {
-		error("corrupt packed object for %s", sha1_to_hex(entry-&gt;idx.sha1));
+		error("corrupt packed object for %s",
+		      oid_to_hex(&amp;entry-&gt;idx.oid));
 		unuse_pack(&amp;w_curs);
 		return write_no_reuse_object(f, entry, limit, usable_delta);
 	}
@@ -404,7 +410,7 @@ static off_t write_reuse_object(struct sha1file *f, struct object_entry *entry,
 			return 0;
 		}
 		sha1write(f, header, hdrlen);
-		sha1write(f, entry-&gt;delta-&gt;idx.sha1, 20);
+		sha1write(f, entry-&gt;delta-&gt;idx.oid.hash, 20);
 		hdrlen += 20;
 		reused_delta++;
 	} else {
@@ -509,7 +515,7 @@ static enum write_one_status write_one(struct sha1file *f,
 	recursing = (e-&gt;idx.offset == 1);
 	if (recursing) {
 		warning("recursive delta detected for object %s",
-			sha1_to_hex(e-&gt;idx.sha1));
+			oid_to_hex(&amp;e-&gt;idx.oid));
 		return WRITE_ONE_RECURSIVE;
 	} else if (e-&gt;idx.offset || e-&gt;preferred_base) {
 		/* offset is non zero if object is written already. */
@@ -1432,7 +1438,7 @@ static void check_object(struct object_entry *entry)
 				ofs += 1;
 				if (!ofs || MSB(ofs, 7)) {
 					error("delta base offset overflow in pack for %s",
-					      sha1_to_hex(entry-&gt;idx.sha1));
+					      oid_to_hex(&amp;entry-&gt;idx.oid));
 					goto give_up;
 				}
 				c = buf[used_0++];
@@ -1441,7 +1447,7 @@ static void check_object(struct object_entry *entry)
 			ofs = entry-&gt;in_pack_offset - ofs;
 			if (ofs &lt;= 0 || ofs &gt;= entry-&gt;in_pack_offset) {
 				error("delta base offset out of bound for %s",
-				      sha1_to_hex(entry-&gt;idx.sha1));
+				      oid_to_hex(&amp;entry-&gt;idx.oid));
 				goto give_up;
 			}
 			if (reuse_delta &amp;&amp; !entry-&gt;preferred_base) {
@@ -1498,7 +1504,7 @@ static void check_object(struct object_entry *entry)
 		unuse_pack(&amp;w_curs);
 	}
 
-	entry-&gt;type = sha1_object_info(entry-&gt;idx.sha1, &amp;entry-&gt;size);
+	entry-&gt;type = sha1_object_info(entry-&gt;idx.oid.hash, &amp;entry-&gt;size);
 	/*
 	 * The error condition is checked in prepare_pack().  This is
 	 * to permit a missing preferred base object to be ignored
@@ -1514,7 +1520,7 @@ static int pack_offset_sort(const void *_a, const void *_b)
 
 	/* avoid filesystem trashing with loose objects */
 	if (!a-&gt;in_pack &amp;&amp; !b-&gt;in_pack)
-		return hashcmp(a-&gt;idx.sha1, b-&gt;idx.sha1);
+		return oidcmp(&amp;a-&gt;idx.oid, &amp;b-&gt;idx.oid);
 
 	if (a-&gt;in_pack &lt; b-&gt;in_pack)
 		return -1;
@@ -1560,7 +1566,8 @@ static void drop_reused_delta(struct object_entry *entry)
 		 * And if that fails, the error will be recorded in entry-&gt;type
 		 * and dealt with in prepare_pack().
 		 */
-		entry-&gt;type = sha1_object_info(entry-&gt;idx.sha1, &amp;entry-&gt;size);
+		entry-&gt;type = sha1_object_info(entry-&gt;idx.oid.hash,
+					       &amp;entry-&gt;size);
 	}
 }
 
@@ -1852,26 +1859,29 @@ static int try_delta(struct unpacked *trg, struct unpacked *src,
 	/* Load data if not already done */
 	if (!trg-&gt;data) {
 		read_lock();
-		trg-&gt;data = read_sha1_file(trg_entry-&gt;idx.sha1, &amp;type, &amp;sz);
+		trg-&gt;data = read_sha1_file(trg_entry-&gt;idx.oid.hash, &amp;type,
+					   &amp;sz);
 		read_unlock();
 		if (!trg-&gt;data)
 			die("object %s cannot be read",
-			    sha1_to_hex(trg_entry-&gt;idx.sha1));
+			    oid_to_hex(&amp;trg_entry-&gt;idx.oid));
 		if (sz != trg_size)
 			die("object %s inconsistent object length (%lu vs %lu)",
-			    sha1_to_hex(trg_entry-&gt;idx.sha1), sz, trg_size);
+			    oid_to_hex(&amp;trg_entry-&gt;idx.oid), sz,
+			    trg_size);
 		*mem_usage += sz;
 	}
 	if (!src-&gt;data) {
 		read_lock();
-		src-&gt;data = read_sha1_file(src_entry-&gt;idx.sha1, &amp;type, &amp;sz);
+		src-&gt;data = read_sha1_file(src_entry-&gt;idx.oid.hash, &amp;type,
+					   &amp;sz);
 		read_unlock();
 		if (!src-&gt;data) {
 			if (src_entry-&gt;preferred_base) {
 				static int warned = 0;
 				if (!warned++)
 					warning("object %s cannot be read",
-						sha1_to_hex(src_entry-&gt;idx.sha1));
+						oid_to_hex(&amp;src_entry-&gt;idx.oid));
 				/*
 				 * Those objects are not included in the
 				 * resulting pack.  Be resilient and ignore
@@ -1881,11 +1891,12 @@ static int try_delta(struct unpacked *trg, struct unpacked *src,
 				return 0;
 			}
 			die("object %s cannot be read",
-			    sha1_to_hex(src_entry-&gt;idx.sha1));
+			    oid_to_hex(&amp;src_entry-&gt;idx.oid));
 		}
 		if (sz != src_size)
 			die("object %s inconsistent object length (%lu vs %lu)",
-			    sha1_to_hex(src_entry-&gt;idx.sha1), sz, src_size);
+			    oid_to_hex(&amp;src_entry-&gt;idx.oid), sz,
+			    src_size);
 		*mem_usage += sz;
 	}
 	if (!src-&gt;index) {
@@ -2406,7 +2417,7 @@ static void prepare_pack(int window, int depth)
 			nr_deltas++;
 			if (entry-&gt;type &lt; 0)
 				die("unable to get type of object %s",
-				    sha1_to_hex(entry-&gt;idx.sha1));
+				    oid_to_hex(&amp;entry-&gt;idx.oid));
 		} else {
 			if (entry-&gt;type &lt; 0) {
 				/*
diff --git a/bulk-checkin.c b/bulk-checkin.c
index ddb6070c4..5be7ce5c7 100644
--- a/bulk-checkin.c
+++ b/bulk-checkin.c
@@ -69,7 +69,7 @@ static int already_written(struct bulk_checkin_state *state, unsigned char sha1[
 
 	/* Might want to keep the list sorted */
 	for (i = 0; i &lt; state-&gt;nr_written; i++)
-		if (!hashcmp(state-&gt;written[i]-&gt;sha1, sha1))
+		if (!hashcmp(state-&gt;written[i]-&gt;oid.hash, sha1))
 			return 1;
 
 	/* This is a new object we need to keep */
@@ -242,7 +242,7 @@ static int deflate_to_pack(struct bulk_checkin_state *state,
 		state-&gt;offset = checkpoint.offset;
 		free(idx);
 	} else {
-		hashcpy(idx-&gt;sha1, result_sha1);
+		hashcpy(idx-&gt;oid.hash, result_sha1);
 		ALLOC_GROW(state-&gt;written,
 			   state-&gt;nr_written + 1,
 			   state-&gt;alloc_written);
diff --git a/fast-import.c b/fast-import.c
index d5de1545b..fb710cfc4 100644
--- a/fast-import.c
+++ b/fast-import.c
@@ -563,7 +563,7 @@ static struct object_entry *new_object(struct object_id *oid)
 		alloc_objects(object_entry_alloc);
 
 	e = blocks-&gt;next_free++;
-	hashcpy(e-&gt;idx.sha1, oid-&gt;hash);
+	oidcpy(&amp;e-&gt;idx.oid, oid);
 	return e;
 }
 
@@ -572,7 +572,7 @@ static struct object_entry *find_object(struct object_id *oid)
 	unsigned int h = oid-&gt;hash[0] &lt;&lt; 8 | oid-&gt;hash[1];
 	struct object_entry *e;
 	for (e = object_table[h]; e; e = e-&gt;next)
-		if (!hashcmp(oid-&gt;hash, e-&gt;idx.sha1))
+		if (!oidcmp(oid, &amp;e-&gt;idx.oid))
 			return e;
 	return NULL;
 }
@@ -583,7 +583,7 @@ static struct object_entry *insert_object(struct object_id *oid)
 	struct object_entry *e = object_table[h];
 
 	while (e) {
-		if (!hashcmp(oid-&gt;hash, e-&gt;idx.sha1))
+		if (!oidcmp(oid, &amp;e-&gt;idx.oid))
 			return e;
 		e = e-&gt;next;
 	}
@@ -1847,7 +1847,7 @@ static void dump_marks_helper(FILE *f,
 		for (k = 0; k &lt; 1024; k++) {
 			if (m-&gt;data.marked[k])
 				fprintf(f, ":%" PRIuMAX " %s\n", base + k,
-					sha1_to_hex(m-&gt;data.marked[k]-&gt;idx.sha1));
+					oid_to_hex(&amp;m-&gt;data.marked[k]-&gt;idx.oid));
 		}
 	}
 }
@@ -2385,7 +2385,7 @@ static void file_change_m(const char *p, struct branch *b)
 
 	if (*p == ':') {
 		oe = find_mark(parse_mark_ref_space(&amp;p));
-		hashcpy(oid.hash, oe-&gt;idx.sha1);
+		oidcpy(&amp;oid, &amp;oe-&gt;idx.oid);
 	} else if (skip_prefix(p, "inline ", &amp;p)) {
 		inline_data = 1;
 		oe = NULL; /* not used with inline_data, but makes gcc happy */
@@ -2551,7 +2551,7 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 	/* &lt;dataref&gt; or 'inline' */
 	if (*p == ':') {
 		oe = find_mark(parse_mark_ref_space(&amp;p));
-		hashcpy(oid.hash, oe-&gt;idx.sha1);
+		oidcpy(&amp;oid, &amp;oe-&gt;idx.oid);
 	} else if (skip_prefix(p, "inline ", &amp;p)) {
 		inline_data = 1;
 		oe = NULL; /* not used with inline_data, but makes gcc happy */
@@ -2574,7 +2574,7 @@ static void note_change_n(const char *p, struct branch *b, unsigned char *old_fa
 		struct object_entry *commit_oe = find_mark(commit_mark);
 		if (commit_oe-&gt;type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", commit_mark);
-		hashcpy(commit_oid.hash, commit_oe-&gt;idx.sha1);
+		oidcpy(&amp;commit_oid, &amp;commit_oe-&gt;idx.oid);
 	} else if (!get_oid(p, &amp;commit_oid)) {
 		unsigned long size;
 		char *buf = read_object_with_reference(commit_oid.hash,
@@ -2679,8 +2679,8 @@ static int parse_from(struct branch *b)
 		struct object_entry *oe = find_mark(idnum);
 		if (oe-&gt;type != OBJ_COMMIT)
 			die("Mark :%" PRIuMAX " not a commit", idnum);
-		if (hashcmp(b-&gt;oid.hash, oe-&gt;idx.sha1)) {
-			hashcpy(b-&gt;oid.hash, oe-&gt;idx.sha1);
+		if (oidcmp(&amp;b-&gt;oid, &amp;oe-&gt;idx.oid)) {
+			oidcpy(&amp;b-&gt;oid, &amp;oe-&gt;idx.oid);
 			if (oe-&gt;pack_id != MAX_PACK_ID) {
 				unsigned long size;
 				char *buf = gfi_unpack_entry(oe, &amp;size);
@@ -2723,7 +2723,7 @@ static struct hash_list *parse_merge(unsigned int *count)
 			struct object_entry *oe = find_mark(idnum);
 			if (oe-&gt;type != OBJ_COMMIT)
 				die("Mark :%" PRIuMAX " not a commit", idnum);
-			hashcpy(n-&gt;oid.hash, oe-&gt;idx.sha1);
+			oidcpy(&amp;n-&gt;oid, &amp;oe-&gt;idx.oid);
 		} else if (!get_oid(from, &amp;n-&gt;oid)) {
 			unsigned long size;
 			char *buf = read_object_with_reference(n-&gt;oid.hash,
@@ -2880,7 +2880,7 @@ static void parse_new_tag(const char *arg)
 		from_mark = parse_mark_ref_eol(from);
 		oe = find_mark(from_mark);
 		type = oe-&gt;type;
-		hashcpy(oid.hash, oe-&gt;idx.sha1);
+		oidcpy(&amp;oid, &amp;oe-&gt;idx.oid);
 	} else if (!get_oid(from, &amp;oid)) {
 		struct object_entry *oe = find_object(&amp;oid);
 		if (!oe) {
@@ -3010,7 +3010,7 @@ static void parse_get_mark(const char *p)
 	if (!oe)
 		die("Unknown mark: %s", command_buf.buf);
 
-	xsnprintf(output, sizeof(output), "%s\n", sha1_to_hex(oe-&gt;idx.sha1));
+	xsnprintf(output, sizeof(output), "%s\n", oid_to_hex(&amp;oe-&gt;idx.oid));
 	cat_blob_write(output, GIT_SHA1_HEXSZ + 1);
 }
 
@@ -3024,7 +3024,7 @@ static void parse_cat_blob(const char *p)
 		oe = find_mark(parse_mark_ref_eol(p));
 		if (!oe)
 			die("Unknown mark: %s", command_buf.buf);
-		hashcpy(oid.hash, oe-&gt;idx.sha1);
+		oidcpy(&amp;oid, &amp;oe-&gt;idx.oid);
 	} else {
 		if (parse_oid_hex(p, &amp;oid, &amp;p))
 			die("Invalid dataref: %s", command_buf.buf);
@@ -3096,7 +3096,7 @@ static struct object_entry *parse_treeish_dataref(const char **p)
 		e = find_mark(parse_mark_ref_space(p));
 		if (!e)
 			die("Unknown mark: %s", command_buf.buf);
-		hashcpy(oid.hash, e-&gt;idx.sha1);
+		oidcpy(&amp;oid, &amp;e-&gt;idx.oid);
 	} else {	/* &lt;sha1&gt; */
 		if (parse_oid_hex(*p, &amp;oid, p))
 			die("Invalid dataref: %s", command_buf.buf);
@@ -3150,7 +3150,7 @@ static void parse_ls(const char *p, struct branch *b)
 	} else {
 		struct object_entry *e = parse_treeish_dataref(&amp;p);
 		root = new_tree_entry();
-		hashcpy(root-&gt;versions[1].oid.hash, e-&gt;idx.sha1);
+		oidcpy(&amp;root-&gt;versions[1].oid, &amp;e-&gt;idx.oid);
 		if (!is_null_oid(&amp;root-&gt;versions[1].oid))
 			root-&gt;versions[1].mode = S_IFDIR;
 		load_tree(root);
diff --git a/pack-bitmap-write.c b/pack-bitmap-write.c
index e313f4f2b..8e47a96b3 100644
--- a/pack-bitmap-write.c
+++ b/pack-bitmap-write.c
@@ -73,7 +73,8 @@ void bitmap_writer_build_type_index(struct pack_idx_entry **index,
 			break;
 
 		default:
-			real_type = sha1_object_info(entry-&gt;idx.sha1, NULL);
+			real_type = sha1_object_info(entry-&gt;idx.oid.hash,
+						     NULL);
 			break;
 		}
 
@@ -96,7 +97,8 @@ void bitmap_writer_build_type_index(struct pack_idx_entry **index,
 
 		default:
 			die("Missing type information for %s (%d/%d)",
-			    sha1_to_hex(entry-&gt;idx.sha1), real_type, entry-&gt;type);
+			    oid_to_hex(&amp;entry-&gt;idx.oid), real_type,
+			    entry-&gt;type);
 		}
 	}
 }
@@ -459,7 +461,7 @@ static inline void dump_bitmap(struct sha1file *f, struct ewah_bitmap *bitmap)
 static const unsigned char *sha1_access(size_t pos, void *table)
 {
 	struct pack_idx_entry **index = table;
-	return index[pos]-&gt;sha1;
+	return index[pos]-&gt;oid.hash;
 }
 
 static void write_selected_commits_v1(struct sha1file *f,
diff --git a/pack-objects.c b/pack-objects.c
index 6398a8aa9..9558d1383 100644
--- a/pack-objects.c
+++ b/pack-objects.c
@@ -14,7 +14,7 @@ static uint32_t locate_object_entry_hash(struct packing_data *pdata,
 	while (pdata-&gt;index[i] &gt; 0) {
 		uint32_t pos = pdata-&gt;index[i] - 1;
 
-		if (!hashcmp(sha1, pdata-&gt;objects[pos].idx.sha1)) {
+		if (!hashcmp(sha1, pdata-&gt;objects[pos].idx.oid.hash)) {
 			*found = 1;
 			return i;
 		}
@@ -53,7 +53,9 @@ static void rehash_objects(struct packing_data *pdata)
 
 	for (i = 0; i &lt; pdata-&gt;nr_objects; i++) {
 		int found;
-		uint32_t ix = locate_object_entry_hash(pdata, entry-&gt;idx.sha1, &amp;found);
+		uint32_t ix = locate_object_entry_hash(pdata,
+						       entry-&gt;idx.oid.hash,
+						       &amp;found);
 
 		if (found)
 			die("BUG: Duplicate object in hash");
@@ -98,7 +100,7 @@ struct object_entry *packlist_alloc(struct packing_data *pdata,
 	new_entry = pdata-&gt;objects + pdata-&gt;nr_objects++;
 
 	memset(new_entry, 0, sizeof(*new_entry));
-	hashcpy(new_entry-&gt;idx.sha1, sha1);
+	hashcpy(new_entry-&gt;idx.oid.hash, sha1);
 
 	if (pdata-&gt;index_size * 3 &lt;= pdata-&gt;nr_objects * 4)
 		rehash_objects(pdata);
diff --git a/pack-write.c b/pack-write.c
index fa97b7255..a333ec675 100644
--- a/pack-write.c
+++ b/pack-write.c
@@ -13,7 +13,7 @@ static int sha1_compare(const void *_a, const void *_b)
 {
 	struct pack_idx_entry *a = *(struct pack_idx_entry **)_a;
 	struct pack_idx_entry *b = *(struct pack_idx_entry **)_b;
-	return hashcmp(a-&gt;sha1, b-&gt;sha1);
+	return oidcmp(&amp;a-&gt;oid, &amp;b-&gt;oid);
 }
 
 static int cmp_uint32(const void *a_, const void *b_)
@@ -103,7 +103,7 @@ const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
 		struct pack_idx_entry **next = list;
 		while (next &lt; last) {
 			struct pack_idx_entry *obj = *next;
-			if (obj-&gt;sha1[0] != i)
+			if (obj-&gt;oid.hash[0] != i)
 				break;
 			next++;
 		}
@@ -122,11 +122,11 @@ const char *write_idx_file(const char *index_name, struct pack_idx_entry **objec
 			uint32_t offset = htonl(obj-&gt;offset);
 			sha1write(f, &amp;offset, 4);
 		}
-		sha1write(f, obj-&gt;sha1, 20);
+		sha1write(f, obj-&gt;oid.hash, 20);
 		if ((opts-&gt;flags &amp; WRITE_IDX_STRICT) &amp;&amp;
-		    (i &amp;&amp; !hashcmp(list[-2]-&gt;sha1, obj-&gt;sha1)))
+		    (i &amp;&amp; !oidcmp(&amp;list[-2]-&gt;oid, &amp;obj-&gt;oid)))
 			die("The same object %s appears twice in the pack",
-			    sha1_to_hex(obj-&gt;sha1));
+			    oid_to_hex(&amp;obj-&gt;oid));
 	}
 
 	if (index_version &gt;= 2) {
diff --git a/pack.h b/pack.h
index 5c2158746..c7de42ef3 100644
--- a/pack.h
+++ b/pack.h
@@ -67,7 +67,7 @@ struct pack_idx_header {
  * Common part of object structure used for write_idx_file
  */
 struct pack_idx_entry {
-	unsigned char sha1[20];
+	struct object_id oid;
 	uint32_t crc32;
 	off_t offset;
 };

<a href="#m891b1840f7953004bf78a2705362287ba2ff8e22" id="e891b1840f7953004bf78a2705362287ba2ff8e22">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-27-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r891b1840f7953004bf78a2705362287ba2ff8e22">52+ messages in thread</a></pre><hr><pre><a href="#e76defffb3dd7d6d7027beed4ec6a0db95d866870" id="m76defffb3dd7d6d7027beed4ec6a0db95d866870">*</a> <b>[PATCH v2 27/53] builtin/unpack-objects: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r891b1840f7953004bf78a2705362287ba2ff8e22">(23 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m891b1840f7953004bf78a2705362287ba2ff8e22">[PATCH v2 26/53] pack: convert struct pack_idx_entry to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m020525f5d6be19bd2171fce4b1d77e84be12feeb">[PATCH v2 28/53] Convert remaining callers of lookup_blob to object_id</a> brian m. carlson
                   ` <a href="#r020525f5d6be19bd2171fce4b1d77e84be12feeb">(25 subsequent siblings)</a>
  <a href="#r76defffb3dd7d6d7027beed4ec6a0db95d866870">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert struct delta_info and struct object_info, as well as the various
functions, to use struct object_id.  Convert several hard-coded 20
values to GIT_SHA1_RAWSZ.  Among the functions converted is a caller of
lookup_blob, which we will convert shortly.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/unpack-objects.c | 64 ++++++++++++++++++++++++------------------------
 1 file changed, 32 insertions(+), 32 deletions(-)

diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index 4532aa083..3dc5e5691 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -127,7 +127,7 @@ static void *get_data(unsigned long size)
 }
 
 struct delta_info {
-	unsigned char base_sha1[20];
+	struct object_id base_oid;
 	unsigned nr;
 	off_t base_offset;
 	unsigned long size;
@@ -137,13 +137,13 @@ struct delta_info {
 
 static struct delta_info *delta_list;
 
-static void add_delta_to_list(unsigned nr, unsigned const char *base_sha1,
+static void add_delta_to_list(unsigned nr, const struct object_id *base_oid,
 			      off_t base_offset,
 			      void *delta, unsigned long size)
 {
 	struct delta_info *info = xmalloc(sizeof(*info));
 
-	hashcpy(info-&gt;base_sha1, base_sha1);
+	oidcpy(&amp;info-&gt;base_oid, base_oid);
 	info-&gt;base_offset = base_offset;
 	info-&gt;size = size;
 	info-&gt;delta = delta;
@@ -154,7 +154,7 @@ static void add_delta_to_list(unsigned nr, unsigned const char *base_sha1,
 
 struct obj_info {
 	off_t offset;
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct object *obj;
 };
 
@@ -170,9 +170,9 @@ static unsigned nr_objects;
  */
 static void write_cached_object(struct object *obj, struct obj_buffer *obj_buf)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 
-	if (write_sha1_file(obj_buf-&gt;buffer, obj_buf-&gt;size, typename(obj-&gt;type), sha1) &lt; 0)
+	if (write_sha1_file(obj_buf-&gt;buffer, obj_buf-&gt;size, typename(obj-&gt;type), oid.hash) &lt; 0)
 		die("failed to write object %s", oid_to_hex(&amp;obj-&gt;oid));
 	obj-&gt;flags |= FLAG_WRITTEN;
 }
@@ -237,19 +237,19 @@ static void write_object(unsigned nr, enum object_type type,
 			 void *buf, unsigned long size)
 {
 	if (!strict) {
-		if (write_sha1_file(buf, size, typename(type), obj_list[nr].sha1) &lt; 0)
+		if (write_sha1_file(buf, size, typename(type), obj_list[nr].oid.hash) &lt; 0)
 			die("failed to write object");
 		added_object(nr, type, buf, size);
 		free(buf);
 		obj_list[nr].obj = NULL;
 	} else if (type == OBJ_BLOB) {
 		struct blob *blob;
-		if (write_sha1_file(buf, size, typename(type), obj_list[nr].sha1) &lt; 0)
+		if (write_sha1_file(buf, size, typename(type), obj_list[nr].oid.hash) &lt; 0)
 			die("failed to write object");
 		added_object(nr, type, buf, size);
 		free(buf);
 
-		blob = lookup_blob(obj_list[nr].sha1);
+		blob = lookup_blob(obj_list[nr].oid.hash);
 		if (blob)
 			blob-&gt;object.flags |= FLAG_WRITTEN;
 		else
@@ -258,9 +258,9 @@ static void write_object(unsigned nr, enum object_type type,
 	} else {
 		struct object *obj;
 		int eaten;
-		hash_sha1_file(buf, size, typename(type), obj_list[nr].sha1);
+		hash_sha1_file(buf, size, typename(type), obj_list[nr].oid.hash);
 		added_object(nr, type, buf, size);
-		obj = parse_object_buffer(obj_list[nr].sha1, type, size, buf, &amp;eaten);
+		obj = parse_object_buffer(obj_list[nr].oid.hash, type, size, buf, &amp;eaten);
 		if (!obj)
 			die("invalid %s", typename(type));
 		add_object_buffer(obj, buf, size);
@@ -296,7 +296,7 @@ static void added_object(unsigned nr, enum object_type type,
 	struct delta_info *info;
 
 	while ((info = *p) != NULL) {
-		if (!hashcmp(info-&gt;base_sha1, obj_list[nr].sha1) ||
+		if (!oidcmp(&amp;info-&gt;base_oid, &amp;obj_list[nr].oid) ||
 		    info-&gt;base_offset == obj_list[nr].offset) {
 			*p = info-&gt;next;
 			p = &amp;delta_list;
@@ -320,12 +320,12 @@ static void unpack_non_delta_entry(enum object_type type, unsigned long size,
 		free(buf);
 }
 
-static int resolve_against_held(unsigned nr, const unsigned char *base,
+static int resolve_against_held(unsigned nr, const struct object_id *base,
 				void *delta_data, unsigned long delta_size)
 {
 	struct object *obj;
 	struct obj_buffer *obj_buffer;
-	obj = lookup_object(base);
+	obj = lookup_object(base-&gt;hash);
 	if (!obj)
 		return 0;
 	obj_buffer = lookup_object_buffer(obj);
@@ -341,25 +341,25 @@ static void unpack_delta_entry(enum object_type type, unsigned long delta_size,
 {
 	void *delta_data, *base;
 	unsigned long base_size;
-	unsigned char base_sha1[20];
+	struct object_id base_oid;
 
 	if (type == OBJ_REF_DELTA) {
-		hashcpy(base_sha1, fill(20));
-		use(20);
+		hashcpy(base_oid.hash, fill(GIT_SHA1_RAWSZ));
+		use(GIT_SHA1_RAWSZ);
 		delta_data = get_data(delta_size);
 		if (dry_run || !delta_data) {
 			free(delta_data);
 			return;
 		}
-		if (has_sha1_file(base_sha1))
+		if (has_object_file(&amp;base_oid))
 			; /* Ok we have this one */
-		else if (resolve_against_held(nr, base_sha1,
+		else if (resolve_against_held(nr, &amp;base_oid,
 					      delta_data, delta_size))
 			return; /* we are done */
 		else {
 			/* cannot resolve yet --- queue it */
-			hashclr(obj_list[nr].sha1);
-			add_delta_to_list(nr, base_sha1, 0, delta_data, delta_size);
+			oidclr(&amp;obj_list[nr].oid);
+			add_delta_to_list(nr, &amp;base_oid, 0, delta_data, delta_size);
 			return;
 		}
 	} else {
@@ -399,8 +399,8 @@ static void unpack_delta_entry(enum object_type type, unsigned long delta_size,
 			} else if (base_offset &gt; obj_list[mid].offset) {
 				lo = mid + 1;
 			} else {
-				hashcpy(base_sha1, obj_list[mid].sha1);
-				base_found = !is_null_sha1(base_sha1);
+				oidcpy(&amp;base_oid, &amp;obj_list[mid].oid);
+				base_found = !is_null_oid(&amp;base_oid);
 				break;
 			}
 		}
@@ -409,19 +409,19 @@ static void unpack_delta_entry(enum object_type type, unsigned long delta_size,
 			 * The delta base object is itself a delta that
 			 * has not been resolved yet.
 			 */
-			hashclr(obj_list[nr].sha1);
-			add_delta_to_list(nr, null_sha1, base_offset, delta_data, delta_size);
+			oidclr(&amp;obj_list[nr].oid);
+			add_delta_to_list(nr, &amp;null_oid, base_offset, delta_data, delta_size);
 			return;
 		}
 	}
 
-	if (resolve_against_held(nr, base_sha1, delta_data, delta_size))
+	if (resolve_against_held(nr, &amp;base_oid, delta_data, delta_size))
 		return;
 
-	base = read_sha1_file(base_sha1, &amp;type, &amp;base_size);
+	base = read_sha1_file(base_oid.hash, &amp;type, &amp;base_size);
 	if (!base) {
 		error("failed to read delta-pack base object %s",
-		      sha1_to_hex(base_sha1));
+		      oid_to_hex(&amp;base_oid));
 		if (!recover)
 			exit(1);
 		has_errors = 1;
@@ -505,7 +505,7 @@ static void unpack_all(void)
 int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 {
 	int i;
-	unsigned char sha1[20];
+	struct object_id oid;
 
 	check_replace_refs = 0;
 
@@ -566,12 +566,12 @@ int cmd_unpack_objects(int argc, const char **argv, const char *prefix)
 	git_SHA1_Init(&amp;ctx);
 	unpack_all();
 	git_SHA1_Update(&amp;ctx, buffer, offset);
-	git_SHA1_Final(sha1, &amp;ctx);
+	git_SHA1_Final(oid.hash, &amp;ctx);
 	if (strict)
 		write_rest();
-	if (hashcmp(fill(20), sha1))
+	if (hashcmp(fill(GIT_SHA1_RAWSZ), oid.hash))
 		die("final sha1 did not match");
-	use(20);
+	use(GIT_SHA1_RAWSZ);
 
 	/* Write the last part of the buffer to stdout */
 	while (len) {

<a href="#m76defffb3dd7d6d7027beed4ec6a0db95d866870" id="e76defffb3dd7d6d7027beed4ec6a0db95d866870">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-28-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r76defffb3dd7d6d7027beed4ec6a0db95d866870">52+ messages in thread</a></pre><hr><pre><a href="#e020525f5d6be19bd2171fce4b1d77e84be12feeb" id="m020525f5d6be19bd2171fce4b1d77e84be12feeb">*</a> <b>[PATCH v2 28/53] Convert remaining callers of lookup_blob to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r76defffb3dd7d6d7027beed4ec6a0db95d866870">(24 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m76defffb3dd7d6d7027beed4ec6a0db95d866870">[PATCH v2 27/53] builtin/unpack-objects: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">[PATCH v2 29/53] Convert lookup_blob to struct object_id</a> brian m. carlson
                   ` <a href="#rca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">(24 subsequent siblings)</a>
  <a href="#r020525f5d6be19bd2171fce4b1d77e84be12feeb">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

All but a few callers of lookup_blob have been converted to struct
object_id.  Introduce a temporary, which will be removed later, into
parse_object to ease the transition, and convert the remaining callers
so that we can update lookup_blob to take struct object_id *.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/index-pack.c | 28 ++++++++++++++--------------
 builtin/merge-tree.c | 10 +++++-----
 object.c             |  9 ++++++---
 3 files changed, 25 insertions(+), 22 deletions(-)

diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index fef0025e4..2241ee68e 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -785,7 +785,7 @@ static int check_collison(struct object_entry *entry)
 
 static void sha1_object(const void *data, struct object_entry *obj_entry,
 			unsigned long size, enum object_type type,
-			const unsigned char *sha1)
+			const struct object_id *oid)
 {
 	void *new_data = NULL;
 	int collision_test_needed = 0;
@@ -794,7 +794,7 @@ static void sha1_object(const void *data, struct object_entry *obj_entry,
 
 	if (startup_info-&gt;have_repository) {
 		read_lock();
-		collision_test_needed = has_sha1_file_with_flags(sha1, HAS_SHA1_QUICK);
+		collision_test_needed = has_sha1_file_with_flags(oid-&gt;hash, HAS_SHA1_QUICK);
 		read_unlock();
 	}
 
@@ -809,31 +809,31 @@ static void sha1_object(const void *data, struct object_entry *obj_entry,
 		enum object_type has_type;
 		unsigned long has_size;
 		read_lock();
-		has_type = sha1_object_info(sha1, &amp;has_size);
+		has_type = sha1_object_info(oid-&gt;hash, &amp;has_size);
 		if (has_type &lt; 0)
-			die(_("cannot read existing object info %s"), sha1_to_hex(sha1));
+			die(_("cannot read existing object info %s"), oid_to_hex(oid));
 		if (has_type != type || has_size != size)
-			die(_("SHA1 COLLISION FOUND WITH %s !"), sha1_to_hex(sha1));
-		has_data = read_sha1_file(sha1, &amp;has_type, &amp;has_size);
+			die(_("SHA1 COLLISION FOUND WITH %s !"), oid_to_hex(oid));
+		has_data = read_sha1_file(oid-&gt;hash, &amp;has_type, &amp;has_size);
 		read_unlock();
 		if (!data)
 			data = new_data = get_data_from_pack(obj_entry);
 		if (!has_data)
-			die(_("cannot read existing object %s"), sha1_to_hex(sha1));
+			die(_("cannot read existing object %s"), oid_to_hex(oid));
 		if (size != has_size || type != has_type ||
 		    memcmp(data, has_data, size) != 0)
-			die(_("SHA1 COLLISION FOUND WITH %s !"), sha1_to_hex(sha1));
+			die(_("SHA1 COLLISION FOUND WITH %s !"), oid_to_hex(oid));
 		free(has_data);
 	}
 
 	if (strict) {
 		read_lock();
 		if (type == OBJ_BLOB) {
-			struct blob *blob = lookup_blob(sha1);
+			struct blob *blob = lookup_blob(oid-&gt;hash);
 			if (blob)
 				blob-&gt;object.flags |= FLAG_CHECKED;
 			else
-				die(_("invalid blob object %s"), sha1_to_hex(sha1));
+				die(_("invalid blob object %s"), oid_to_hex(oid));
 		} else {
 			struct object *obj;
 			int eaten;
@@ -845,7 +845,7 @@ static void sha1_object(const void *data, struct object_entry *obj_entry,
 			 * we do not need to free the memory here, as the
 			 * buf is deleted by the caller.
 			 */
-			obj = parse_object_buffer(sha1, type, size, buf, &amp;eaten);
+			obj = parse_object_buffer(oid-&gt;hash, type, size, buf, &amp;eaten);
 			if (!obj)
 				die(_("invalid %s"), typename(type));
 			if (do_fsck_object &amp;&amp;
@@ -960,7 +960,7 @@ static void resolve_delta(struct object_entry *delta_obj,
 		       typename(delta_obj-&gt;real_type),
 		       delta_obj-&gt;idx.oid.hash);
 	sha1_object(result-&gt;data, NULL, result-&gt;size, delta_obj-&gt;real_type,
-		    delta_obj-&gt;idx.oid.hash);
+		    &amp;delta_obj-&gt;idx.oid);
 	counter_lock();
 	nr_resolved_deltas++;
 	counter_unlock();
@@ -1149,7 +1149,7 @@ static void parse_pack_objects(unsigned char *sha1)
 			nr_delays++;
 		} else
 			sha1_object(data, NULL, obj-&gt;size, obj-&gt;type,
-				    obj-&gt;idx.oid.hash);
+				    &amp;obj-&gt;idx.oid);
 		free(data);
 		display_progress(progress, i+1);
 	}
@@ -1176,7 +1176,7 @@ static void parse_pack_objects(unsigned char *sha1)
 			continue;
 		obj-&gt;real_type = obj-&gt;type;
 		sha1_object(NULL, obj, obj-&gt;size, obj-&gt;type,
-			    obj-&gt;idx.oid.hash);
+			    &amp;obj-&gt;idx.oid);
 		nr_delays--;
 	}
 	if (nr_delays)
diff --git a/builtin/merge-tree.c b/builtin/merge-tree.c
index 5b7ab9b96..cdeb6562d 100644
--- a/builtin/merge-tree.c
+++ b/builtin/merge-tree.c
@@ -161,14 +161,14 @@ static int both_empty(struct name_entry *a, struct name_entry *b)
 	return !(a-&gt;oid || b-&gt;oid);
 }
 
-static struct merge_list *create_entry(unsigned stage, unsigned mode, const unsigned char *sha1, const char *path)
+static struct merge_list *create_entry(unsigned stage, unsigned mode, const struct object_id *oid, const char *path)
 {
 	struct merge_list *res = xcalloc(1, sizeof(*res));
 
 	res-&gt;stage = stage;
 	res-&gt;path = path;
 	res-&gt;mode = mode;
-	res-&gt;blob = lookup_blob(sha1);
+	res-&gt;blob = lookup_blob(oid-&gt;hash);
 	return res;
 }
 
@@ -188,8 +188,8 @@ static void resolve(const struct traverse_info *info, struct name_entry *ours, s
 		return;
 
 	path = traverse_path(info, result);
-	orig = create_entry(2, ours-&gt;mode, ours-&gt;oid-&gt;hash, path);
-	final = create_entry(0, result-&gt;mode, result-&gt;oid-&gt;hash, path);
+	orig = create_entry(2, ours-&gt;mode, ours-&gt;oid, path);
+	final = create_entry(0, result-&gt;mode, result-&gt;oid, path);
 
 	final-&gt;link = orig;
 
@@ -239,7 +239,7 @@ static struct merge_list *link_entry(unsigned stage, const struct traverse_info
 		path = entry-&gt;path;
 	else
 		path = traverse_path(info, n);
-	link = create_entry(stage, n-&gt;mode, n-&gt;oid-&gt;hash, path);
+	link = create_entry(stage, n-&gt;mode, n-&gt;oid, path);
 	link-&gt;link = entry;
 	return link;
 }
diff --git a/object.c b/object.c
index fe2222356..0208c407a 100644
--- a/object.c
+++ b/object.c
@@ -190,7 +190,7 @@ struct object *parse_object_buffer(const unsigned char *sha1, enum object_type t
 
 	obj = NULL;
 	if (type == OBJ_BLOB) {
-		struct blob *blob = lookup_blob(sha1);
+		struct blob *blob = lookup_blob(oid.hash);
 		if (blob) {
 			if (parse_blob_buffer(blob, buffer, size))
 				return NULL;
@@ -251,8 +251,11 @@ struct object *parse_object(const unsigned char *sha1)
 	const unsigned char *repl = lookup_replace_object(sha1);
 	void *buffer;
 	struct object *obj;
+	struct object_id oid;
 
-	obj = lookup_object(sha1);
+	hashcpy(oid.hash, sha1);
+
+	obj = lookup_object(oid.hash);
 	if (obj &amp;&amp; obj-&gt;parsed)
 		return obj;
 
@@ -263,7 +266,7 @@ struct object *parse_object(const unsigned char *sha1)
 			error("sha1 mismatch %s", sha1_to_hex(repl));
 			return NULL;
 		}
-		parse_blob_buffer(lookup_blob(sha1), NULL, 0);
+		parse_blob_buffer(lookup_blob(oid.hash), NULL, 0);
 		return lookup_object(sha1);
 	}
 

<a href="#m020525f5d6be19bd2171fce4b1d77e84be12feeb" id="e020525f5d6be19bd2171fce4b1d77e84be12feeb">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-29-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r020525f5d6be19bd2171fce4b1d77e84be12feeb">52+ messages in thread</a></pre><hr><pre><a href="#eca131828dd17e3bb6c6e9f11f6425cff1f7ad27f" id="mca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">*</a> <b>[PATCH v2 29/53] Convert lookup_blob to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r020525f5d6be19bd2171fce4b1d77e84be12feeb">(25 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m020525f5d6be19bd2171fce4b1d77e84be12feeb">[PATCH v2 28/53] Convert remaining callers of lookup_blob to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m1189201e1cbe8ea272665337fabb2d3ed65ea3fb">[PATCH v2 30/53] tree: convert read_tree_1 to use struct object_id internally</a> brian m. carlson
                   ` <a href="#r1189201e1cbe8ea272665337fabb2d3ed65ea3fb">(23 subsequent siblings)</a>
  <a href="#rca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert lookup_blob to take a pointer to struct object_id.

The commit was created with manual changes to blob.c and blob.h, plus
the following semantic patch:

@@
expression E1;
@@
- lookup_blob(E1.hash)
+ lookup_blob(&amp;E1)

@@
expression E1;
@@
- lookup_blob(E1-&gt;hash)
+ lookup_blob(E1)

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 blob.c                   | 6 +++---
 blob.h                   | 2 +-
 builtin/fast-export.c    | 2 +-
 builtin/fsck.c           | 2 +-
 builtin/index-pack.c     | 2 +-
 builtin/merge-tree.c     | 2 +-
 builtin/unpack-objects.c | 2 +-
 fsck.c                   | 2 +-
 http-push.c              | 2 +-
 list-objects.c           | 2 +-
 object.c                 | 4 ++--
 reachable.c              | 2 +-
 revision.c               | 4 ++--
 tag.c                    | 2 +-
 walker.c                 | 2 +-
 15 files changed, 19 insertions(+), 19 deletions(-)

diff --git a/blob.c b/blob.c
index 1fcb8e44b..fa2ab4f7a 100644
--- a/blob.c
+++ b/blob.c
@@ -3,11 +3,11 @@
 
 const char *blob_type = "blob";
 
-struct blob *lookup_blob(const unsigned char *sha1)
+struct blob *lookup_blob(const struct object_id *oid)
 {
-	struct object *obj = lookup_object(sha1);
+	struct object *obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		return create_object(sha1, alloc_blob_node());
+		return create_object(oid-&gt;hash, alloc_blob_node());
 	return object_as_type(obj, OBJ_BLOB, 0);
 }
 
diff --git a/blob.h b/blob.h
index 59b394eea..446061683 100644
--- a/blob.h
+++ b/blob.h
@@ -9,7 +9,7 @@ struct blob {
 	struct object object;
 };
 
-struct blob *lookup_blob(const unsigned char *sha1);
+struct blob *lookup_blob(const struct object_id *oid);
 
 int parse_blob_buffer(struct blob *item, void *buffer, unsigned long size);
 
diff --git a/builtin/fast-export.c b/builtin/fast-export.c
index b4521cb62..ae36b14db 100644
--- a/builtin/fast-export.c
+++ b/builtin/fast-export.c
@@ -232,7 +232,7 @@ static void export_blob(const struct object_id *oid)
 
 	if (anonymize) {
 		buf = anonymize_blob(&amp;size);
-		object = (struct object *)lookup_blob(oid-&gt;hash);
+		object = (struct object *)lookup_blob(oid);
 		eaten = 0;
 	} else {
 		buf = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
diff --git a/builtin/fsck.c b/builtin/fsck.c
index c40e14de6..2f67e8217 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
@@ -781,7 +781,7 @@ int cmd_fsck(int argc, const char **argv, const char *prefix)
 			mode = active_cache[i]-&gt;ce_mode;
 			if (S_ISGITLINK(mode))
 				continue;
-			blob = lookup_blob(active_cache[i]-&gt;oid.hash);
+			blob = lookup_blob(&amp;active_cache[i]-&gt;oid);
 			if (!blob)
 				continue;
 			obj = &amp;blob-&gt;object;
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index 2241ee68e..b75133f62 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -829,7 +829,7 @@ static void sha1_object(const void *data, struct object_entry *obj_entry,
 	if (strict) {
 		read_lock();
 		if (type == OBJ_BLOB) {
-			struct blob *blob = lookup_blob(oid-&gt;hash);
+			struct blob *blob = lookup_blob(oid);
 			if (blob)
 				blob-&gt;object.flags |= FLAG_CHECKED;
 			else
diff --git a/builtin/merge-tree.c b/builtin/merge-tree.c
index cdeb6562d..bad6735c7 100644
--- a/builtin/merge-tree.c
+++ b/builtin/merge-tree.c
@@ -168,7 +168,7 @@ static struct merge_list *create_entry(unsigned stage, unsigned mode, const stru
 	res-&gt;stage = stage;
 	res-&gt;path = path;
 	res-&gt;mode = mode;
-	res-&gt;blob = lookup_blob(oid-&gt;hash);
+	res-&gt;blob = lookup_blob(oid);
 	return res;
 }
 
diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index 3dc5e5691..7d5efa2b3 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -249,7 +249,7 @@ static void write_object(unsigned nr, enum object_type type,
 		added_object(nr, type, buf, size);
 		free(buf);
 
-		blob = lookup_blob(obj_list[nr].oid.hash);
+		blob = lookup_blob(&amp;obj_list[nr].oid);
 		if (blob)
 			blob-&gt;object.flags |= FLAG_WRITTEN;
 		else
diff --git a/fsck.c b/fsck.c
index e6152e4e6..ab3016c0e 100644
--- a/fsck.c
+++ b/fsck.c
@@ -365,7 +365,7 @@ static int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *op
 			result = options-&gt;walk(obj, OBJ_TREE, data, options);
 		}
 		else if (S_ISREG(entry.mode) || S_ISLNK(entry.mode)) {
-			obj = &amp;lookup_blob(entry.oid-&gt;hash)-&gt;object;
+			obj = &amp;lookup_blob(entry.oid)-&gt;object;
 			if (name)
 				put_object_name(options, obj, "%s%s", name,
 					entry.path);
diff --git a/http-push.c b/http-push.c
index 04568e4fb..9bb5e0648 100644
--- a/http-push.c
+++ b/http-push.c
@@ -1315,7 +1315,7 @@ static struct object_list **process_tree(struct tree *tree,
 			p = process_tree(lookup_tree(entry.oid-&gt;hash), p);
 			break;
 		case OBJ_BLOB:
-			p = process_blob(lookup_blob(entry.oid-&gt;hash), p);
+			p = process_blob(lookup_blob(entry.oid), p);
 			break;
 		default:
 			/* Subproject commit - not in this repository */
diff --git a/list-objects.c b/list-objects.c
index f3ca6aafb..721e5fb08 100644
--- a/list-objects.c
+++ b/list-objects.c
@@ -119,7 +119,7 @@ static void process_tree(struct rev_info *revs,
 					cb_data);
 		else
 			process_blob(revs,
-				     lookup_blob(entry.oid-&gt;hash),
+				     lookup_blob(entry.oid),
 				     show, base, entry.path,
 				     cb_data);
 	}
diff --git a/object.c b/object.c
index 0208c407a..2c8d1e5d3 100644
--- a/object.c
+++ b/object.c
@@ -190,7 +190,7 @@ struct object *parse_object_buffer(const unsigned char *sha1, enum object_type t
 
 	obj = NULL;
 	if (type == OBJ_BLOB) {
-		struct blob *blob = lookup_blob(oid.hash);
+		struct blob *blob = lookup_blob(&amp;oid);
 		if (blob) {
 			if (parse_blob_buffer(blob, buffer, size))
 				return NULL;
@@ -266,7 +266,7 @@ struct object *parse_object(const unsigned char *sha1)
 			error("sha1 mismatch %s", sha1_to_hex(repl));
 			return NULL;
 		}
-		parse_blob_buffer(lookup_blob(oid.hash), NULL, 0);
+		parse_blob_buffer(lookup_blob(&amp;oid), NULL, 0);
 		return lookup_object(sha1);
 	}
 
diff --git a/reachable.c b/reachable.c
index a8a979bd4..8ea0bdd7c 100644
--- a/reachable.c
+++ b/reachable.c
@@ -88,7 +88,7 @@ static void add_recent_object(const struct object_id *oid,
 		obj = (struct object *)lookup_tree(oid-&gt;hash);
 		break;
 	case OBJ_BLOB:
-		obj = (struct object *)lookup_blob(oid-&gt;hash);
+		obj = (struct object *)lookup_blob(oid);
 		break;
 	default:
 		die("unknown object type for %s: %s",
diff --git a/revision.c b/revision.c
index f8e0dee6d..db2de7a7a 100644
--- a/revision.c
+++ b/revision.c
@@ -62,7 +62,7 @@ static void mark_tree_contents_uninteresting(struct tree *tree)
 			mark_tree_uninteresting(lookup_tree(entry.oid-&gt;hash));
 			break;
 		case OBJ_BLOB:
-			mark_blob_uninteresting(lookup_blob(entry.oid-&gt;hash));
+			mark_blob_uninteresting(lookup_blob(entry.oid));
 			break;
 		default:
 			/* Subproject commit - not in this repository */
@@ -1275,7 +1275,7 @@ void add_index_objects_to_pending(struct rev_info *revs, unsigned flags)
 		if (S_ISGITLINK(ce-&gt;ce_mode))
 			continue;
 
-		blob = lookup_blob(ce-&gt;oid.hash);
+		blob = lookup_blob(&amp;ce-&gt;oid);
 		if (!blob)
 			die("unable to add index blob to traversal");
 		add_pending_object_with_path(revs, &amp;blob-&gt;object, "",
diff --git a/tag.c b/tag.c
index 79b78d358..dff251673 100644
--- a/tag.c
+++ b/tag.c
@@ -142,7 +142,7 @@ int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 	bufptr = nl + 1;
 
 	if (!strcmp(type, blob_type)) {
-		item-&gt;tagged = &amp;lookup_blob(oid.hash)-&gt;object;
+		item-&gt;tagged = &amp;lookup_blob(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, tree_type)) {
 		item-&gt;tagged = &amp;lookup_tree(oid.hash)-&gt;object;
 	} else if (!strcmp(type, commit_type)) {
diff --git a/walker.c b/walker.c
index b499fcb72..3d6029c8e 100644
--- a/walker.c
+++ b/walker.c
@@ -52,7 +52,7 @@ static int process_tree(struct walker *walker, struct tree *tree)
 				obj = &amp;tree-&gt;object;
 		}
 		else {
-			struct blob *blob = lookup_blob(entry.oid-&gt;hash);
+			struct blob *blob = lookup_blob(entry.oid);
 			if (blob)
 				obj = &amp;blob-&gt;object;
 		}

<a href="#mca131828dd17e3bb6c6e9f11f6425cff1f7ad27f" id="eca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-30-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">52+ messages in thread</a></pre><hr><pre><a href="#e1189201e1cbe8ea272665337fabb2d3ed65ea3fb" id="m1189201e1cbe8ea272665337fabb2d3ed65ea3fb">*</a> <b>[PATCH v2 30/53] tree: convert read_tree_1 to use struct object_id internally</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">(26 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">[PATCH v2 29/53] Convert lookup_blob to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m6401726cb6374424ac36da9790da16ca18fbe4e5">[PATCH v2 31/53] builtin/reflog: convert tree_is_complete to take struct object_id</a> brian m. carlson
                   ` <a href="#r6401726cb6374424ac36da9790da16ca18fbe4e5">(22 subsequent siblings)</a>
  <a href="#r1189201e1cbe8ea272665337fabb2d3ed65ea3fb">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 tree.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/tree.c b/tree.c
index 33fa7ee71..21fd80b80 100644
--- a/tree.c
+++ b/tree.c
@@ -58,7 +58,7 @@ static int read_tree_1(struct tree *tree, struct strbuf *base,
 {
 	struct tree_desc desc;
 	struct name_entry entry;
-	unsigned char sha1[20];
+	struct object_id oid;
 	int len, oldlen = base-&gt;len;
 	enum interesting retval = entry_not_interesting;
 
@@ -87,7 +87,7 @@ static int read_tree_1(struct tree *tree, struct strbuf *base,
 		}
 
 		if (S_ISDIR(entry.mode))
-			hashcpy(sha1, entry.oid-&gt;hash);
+			oidcpy(&amp;oid, entry.oid);
 		else if (S_ISGITLINK(entry.mode)) {
 			struct commit *commit;
 
@@ -102,7 +102,7 @@ static int read_tree_1(struct tree *tree, struct strbuf *base,
 				    oid_to_hex(entry.oid),
 				    base-&gt;buf, entry.path);
 
-			hashcpy(sha1, commit-&gt;tree-&gt;object.oid.hash);
+			oidcpy(&amp;oid, &amp;commit-&gt;tree-&gt;object.oid);
 		}
 		else
 			continue;
@@ -110,7 +110,7 @@ static int read_tree_1(struct tree *tree, struct strbuf *base,
 		len = tree_entry_len(&amp;entry);
 		strbuf_add(base, entry.path, len);
 		strbuf_addch(base, '/');
-		retval = read_tree_1(lookup_tree(sha1),
+		retval = read_tree_1(lookup_tree(oid.hash),
 				     base, stage, pathspec,
 				     fn, context);
 		strbuf_setlen(base, oldlen);

<a href="#m1189201e1cbe8ea272665337fabb2d3ed65ea3fb" id="e1189201e1cbe8ea272665337fabb2d3ed65ea3fb">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-31-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r1189201e1cbe8ea272665337fabb2d3ed65ea3fb">52+ messages in thread</a></pre><hr><pre><a href="#e6401726cb6374424ac36da9790da16ca18fbe4e5" id="m6401726cb6374424ac36da9790da16ca18fbe4e5">*</a> <b>[PATCH v2 31/53] builtin/reflog: convert tree_is_complete to take struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r1189201e1cbe8ea272665337fabb2d3ed65ea3fb">(27 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m1189201e1cbe8ea272665337fabb2d3ed65ea3fb">[PATCH v2 30/53] tree: convert read_tree_1 to use struct object_id internally</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m391adf34d36b0e6a3310cd9b07c12a79f53c1457">[PATCH v2 32/53] Convert lookup_tree to struct object_id</a> brian m. carlson
                   ` <a href="#r391adf34d36b0e6a3310cd9b07c12a79f53c1457">(21 subsequent siblings)</a>
  <a href="#r6401726cb6374424ac36da9790da16ca18fbe4e5">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/reflog.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/builtin/reflog.c b/builtin/reflog.c
index 4831116ea..7866a0341 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -55,14 +55,14 @@ struct collect_reflog_cb {
 #define STUDYING	(1u&lt;&lt;11)
 #define REACHABLE	(1u&lt;&lt;12)
 
-static int tree_is_complete(const unsigned char *sha1)
+static int tree_is_complete(const struct object_id *oid)
 {
 	struct tree_desc desc;
 	struct name_entry entry;
 	int complete;
 	struct tree *tree;
 
-	tree = lookup_tree(sha1);
+	tree = lookup_tree(oid-&gt;hash);
 	if (!tree)
 		return 0;
 	if (tree-&gt;object.flags &amp; SEEN)
@@ -73,7 +73,7 @@ static int tree_is_complete(const unsigned char *sha1)
 	if (!tree-&gt;buffer) {
 		enum object_type type;
 		unsigned long size;
-		void *data = read_sha1_file(sha1, &amp;type, &amp;size);
+		void *data = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
 		if (!data) {
 			tree-&gt;object.flags |= INCOMPLETE;
 			return 0;
@@ -85,7 +85,7 @@ static int tree_is_complete(const unsigned char *sha1)
 	complete = 1;
 	while (tree_entry(&amp;desc, &amp;entry)) {
 		if (!has_sha1_file(entry.oid-&gt;hash) ||
-		    (S_ISDIR(entry.mode) &amp;&amp; !tree_is_complete(entry.oid-&gt;hash))) {
+		    (S_ISDIR(entry.mode) &amp;&amp; !tree_is_complete(entry.oid))) {
 			tree-&gt;object.flags |= INCOMPLETE;
 			complete = 0;
 		}
@@ -152,7 +152,7 @@ static int commit_is_complete(struct commit *commit)
 		for (i = 0; i &lt; found.nr; i++) {
 			struct commit *c =
 				(struct commit *)found.objects[i].item;
-			if (!tree_is_complete(c-&gt;tree-&gt;object.oid.hash)) {
+			if (!tree_is_complete(&amp;c-&gt;tree-&gt;object.oid)) {
 				is_incomplete = 1;
 				c-&gt;object.flags |= INCOMPLETE;
 			}

<a href="#m6401726cb6374424ac36da9790da16ca18fbe4e5" id="e6401726cb6374424ac36da9790da16ca18fbe4e5">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-32-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r6401726cb6374424ac36da9790da16ca18fbe4e5">52+ messages in thread</a></pre><hr><pre><a href="#e391adf34d36b0e6a3310cd9b07c12a79f53c1457" id="m391adf34d36b0e6a3310cd9b07c12a79f53c1457">*</a> <b>[PATCH v2 32/53] Convert lookup_tree to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r6401726cb6374424ac36da9790da16ca18fbe4e5">(28 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m6401726cb6374424ac36da9790da16ca18fbe4e5">[PATCH v2 31/53] builtin/reflog: convert tree_is_complete to take struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m663203f9dd55b3399d534345634dea0738de99f6">[PATCH v2 33/53] log-tree: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r663203f9dd55b3399d534345634dea0738de99f6">(20 subsequent siblings)</a>
  <a href="#r391adf34d36b0e6a3310cd9b07c12a79f53c1457">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the lookup_tree function to take a pointer to struct object_id.

The commit was created with manual changes to tree.c, tree.h, and
object.c, plus the following semantic patch:

@@
@@
- lookup_tree(EMPTY_TREE_SHA1_BIN)
+ lookup_tree(&amp;empty_tree_oid)

@@
expression E1;
@@
- lookup_tree(E1.hash)
+ lookup_tree(&amp;E1)

@@
expression E1;
@@
- lookup_tree(E1-&gt;hash)
+ lookup_tree(E1)

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/am.c        | 4 ++--
 builtin/diff-tree.c | 2 +-
 builtin/diff.c      | 2 +-
 builtin/reflog.c    | 2 +-
 cache-tree.c        | 2 +-
 commit.c            | 2 +-
 fsck.c              | 2 +-
 http-push.c         | 2 +-
 list-objects.c      | 2 +-
 merge-recursive.c   | 6 +++---
 object.c            | 2 +-
 reachable.c         | 2 +-
 revision.c          | 4 ++--
 sequencer.c         | 2 +-
 tag.c               | 2 +-
 tree.c              | 8 ++++----
 tree.h              | 2 +-
 walker.c            | 2 +-
 18 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/builtin/am.c b/builtin/am.c
index 650269ac5..7663f12e6 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -1453,9 +1453,9 @@ static void write_index_patch(const struct am_state *state)
 	FILE *fp;
 
 	if (!get_sha1_tree("HEAD", head.hash))
-		tree = lookup_tree(head.hash);
+		tree = lookup_tree(&amp;head);
 	else
-		tree = lookup_tree(EMPTY_TREE_SHA1_BIN);
+		tree = lookup_tree(&amp;empty_tree_oid);
 
 	fp = xfopen(am_path(state, "patch"), "w");
 	init_revisions(&amp;rev_info, NULL);
diff --git a/builtin/diff-tree.c b/builtin/diff-tree.c
index e85a449df..95b8d1ba7 100644
--- a/builtin/diff-tree.c
+++ b/builtin/diff-tree.c
@@ -44,7 +44,7 @@ static int stdin_diff_trees(struct tree *tree1, const char *p)
 	struct tree *tree2;
 	if (!isspace(*p++) || parse_oid_hex(p, &amp;oid, &amp;p) || *p)
 		return error("Need exactly two trees, separated by a space");
-	tree2 = lookup_tree(oid.hash);
+	tree2 = lookup_tree(&amp;oid);
 	if (!tree2 || parse_tree(tree2))
 		return -1;
 	printf("%s %s\n", oid_to_hex(&amp;tree1-&gt;object.oid),
diff --git a/builtin/diff.c b/builtin/diff.c
index a25b4e4ae..895f92897 100644
--- a/builtin/diff.c
+++ b/builtin/diff.c
@@ -381,7 +381,7 @@ int cmd_diff(int argc, const char **argv, const char *prefix)
 				add_head_to_pending(&amp;rev);
 				if (!rev.pending.nr) {
 					struct tree *tree;
-					tree = lookup_tree(EMPTY_TREE_SHA1_BIN);
+					tree = lookup_tree(&amp;empty_tree_oid);
 					add_pending_object(&amp;rev, &amp;tree-&gt;object, "HEAD");
 				}
 				break;
diff --git a/builtin/reflog.c b/builtin/reflog.c
index 7866a0341..7e89e84dc 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -62,7 +62,7 @@ static int tree_is_complete(const struct object_id *oid)
 	int complete;
 	struct tree *tree;
 
-	tree = lookup_tree(oid-&gt;hash);
+	tree = lookup_tree(oid);
 	if (!tree)
 		return 0;
 	if (tree-&gt;object.flags &amp; SEEN)
diff --git a/cache-tree.c b/cache-tree.c
index 35d507ed7..489241021 100644
--- a/cache-tree.c
+++ b/cache-tree.c
@@ -672,7 +672,7 @@ static void prime_cache_tree_rec(struct cache_tree *it, struct tree *tree)
 			cnt++;
 		else {
 			struct cache_tree_sub *sub;
-			struct tree *subtree = lookup_tree(entry.oid-&gt;hash);
+			struct tree *subtree = lookup_tree(entry.oid);
 			if (!subtree-&gt;object.parsed)
 				parse_tree(subtree);
 			sub = cache_tree_sub(it, entry.path);
diff --git a/commit.c b/commit.c
index 0f6c9b6bf..8004008bc 100644
--- a/commit.c
+++ b/commit.c
@@ -331,7 +331,7 @@ int parse_commit_buffer(struct commit *item, const void *buffer, unsigned long s
 	if (get_sha1_hex(bufptr + 5, parent.hash) &lt; 0)
 		return error("bad tree pointer in commit %s",
 			     oid_to_hex(&amp;item-&gt;object.oid));
-	item-&gt;tree = lookup_tree(parent.hash);
+	item-&gt;tree = lookup_tree(&amp;parent);
 	bufptr += tree_entry_len + 1; /* "tree " + "hex sha1" + "\n" */
 	pptr = &amp;item-&gt;parents;
 
diff --git a/fsck.c b/fsck.c
index ab3016c0e..ee5224aea 100644
--- a/fsck.c
+++ b/fsck.c
@@ -358,7 +358,7 @@ static int fsck_walk_tree(struct tree *tree, void *data, struct fsck_options *op
 			continue;
 
 		if (S_ISDIR(entry.mode)) {
-			obj = &amp;lookup_tree(entry.oid-&gt;hash)-&gt;object;
+			obj = &amp;lookup_tree(entry.oid)-&gt;object;
 			if (name)
 				put_object_name(options, obj, "%s%s/", name,
 					entry.path);
diff --git a/http-push.c b/http-push.c
index 9bb5e0648..7781f4078 100644
--- a/http-push.c
+++ b/http-push.c
@@ -1312,7 +1312,7 @@ static struct object_list **process_tree(struct tree *tree,
 	while (tree_entry(&amp;desc, &amp;entry))
 		switch (object_type(entry.mode)) {
 		case OBJ_TREE:
-			p = process_tree(lookup_tree(entry.oid-&gt;hash), p);
+			p = process_tree(lookup_tree(entry.oid), p);
 			break;
 		case OBJ_BLOB:
 			p = process_blob(lookup_blob(entry.oid), p);
diff --git a/list-objects.c b/list-objects.c
index 721e5fb08..b3931fa43 100644
--- a/list-objects.c
+++ b/list-objects.c
@@ -110,7 +110,7 @@ static void process_tree(struct rev_info *revs,
 
 		if (S_ISDIR(entry.mode))
 			process_tree(revs,
-				     lookup_tree(entry.oid-&gt;hash),
+				     lookup_tree(entry.oid),
 				     show, base, entry.path,
 				     cb_data);
 		else if (S_ISGITLINK(entry.mode))
diff --git a/merge-recursive.c b/merge-recursive.c
index 1315a45b9..92e0a63dc 100644
--- a/merge-recursive.c
+++ b/merge-recursive.c
@@ -67,7 +67,7 @@ static struct tree *shift_tree_object(struct tree *one, struct tree *two,
 	}
 	if (!oidcmp(&amp;two-&gt;object.oid, &amp;shifted))
 		return two;
-	return lookup_tree(shifted.hash);
+	return lookup_tree(&amp;shifted);
 }
 
 static struct commit *make_virtual_commit(struct tree *tree, const char *comment)
@@ -304,7 +304,7 @@ struct tree *write_tree_from_memory(struct merge_options *o)
 		return NULL;
 	}
 
-	result = lookup_tree(active_cache_tree-&gt;oid.hash);
+	result = lookup_tree(&amp;active_cache_tree-&gt;oid);
 
 	return result;
 }
@@ -2042,7 +2042,7 @@ int merge_recursive(struct merge_options *o,
 		/* if there is no common ancestor, use an empty tree */
 		struct tree *tree;
 
-		tree = lookup_tree(EMPTY_TREE_SHA1_BIN);
+		tree = lookup_tree(&amp;empty_tree_oid);
 		merged_common_ancestors = make_virtual_commit(tree, "ancestor");
 	}
 
diff --git a/object.c b/object.c
index 2c8d1e5d3..d23c5fad3 100644
--- a/object.c
+++ b/object.c
@@ -197,7 +197,7 @@ struct object *parse_object_buffer(const unsigned char *sha1, enum object_type t
 			obj = &amp;blob-&gt;object;
 		}
 	} else if (type == OBJ_TREE) {
-		struct tree *tree = lookup_tree(sha1);
+		struct tree *tree = lookup_tree(&amp;oid);
 		if (tree) {
 			obj = &amp;tree-&gt;object;
 			if (!tree-&gt;buffer)
diff --git a/reachable.c b/reachable.c
index 8ea0bdd7c..3bbc84417 100644
--- a/reachable.c
+++ b/reachable.c
@@ -85,7 +85,7 @@ static void add_recent_object(const struct object_id *oid,
 		obj = parse_object_or_die(oid-&gt;hash, NULL);
 		break;
 	case OBJ_TREE:
-		obj = (struct object *)lookup_tree(oid-&gt;hash);
+		obj = (struct object *)lookup_tree(oid);
 		break;
 	case OBJ_BLOB:
 		obj = (struct object *)lookup_blob(oid);
diff --git a/revision.c b/revision.c
index db2de7a7a..c2091b6de 100644
--- a/revision.c
+++ b/revision.c
@@ -59,7 +59,7 @@ static void mark_tree_contents_uninteresting(struct tree *tree)
 	while (tree_entry(&amp;desc, &amp;entry)) {
 		switch (object_type(entry.mode)) {
 		case OBJ_TREE:
-			mark_tree_uninteresting(lookup_tree(entry.oid-&gt;hash));
+			mark_tree_uninteresting(lookup_tree(entry.oid));
 			break;
 		case OBJ_BLOB:
 			mark_blob_uninteresting(lookup_blob(entry.oid));
@@ -1249,7 +1249,7 @@ static void add_cache_tree(struct cache_tree *it, struct rev_info *revs,
 	int i;
 
 	if (it-&gt;entry_count &gt;= 0) {
-		struct tree *tree = lookup_tree(it-&gt;oid.hash);
+		struct tree *tree = lookup_tree(&amp;it-&gt;oid);
 		add_pending_object_with_path(revs, &amp;tree-&gt;object, "",
 					     040000, path-&gt;buf);
 	}
diff --git a/sequencer.c b/sequencer.c
index e98a896d7..fa35e03b6 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -344,7 +344,7 @@ static int read_oneliner(struct strbuf *buf,
 
 static struct tree *empty_tree(void)
 {
-	return lookup_tree(EMPTY_TREE_SHA1_BIN);
+	return lookup_tree(&amp;empty_tree_oid);
 }
 
 static int error_dirty_index(struct replay_opts *opts)
diff --git a/tag.c b/tag.c
index dff251673..062516b40 100644
--- a/tag.c
+++ b/tag.c
@@ -144,7 +144,7 @@ int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 	if (!strcmp(type, blob_type)) {
 		item-&gt;tagged = &amp;lookup_blob(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, tree_type)) {
-		item-&gt;tagged = &amp;lookup_tree(oid.hash)-&gt;object;
+		item-&gt;tagged = &amp;lookup_tree(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, commit_type)) {
 		item-&gt;tagged = &amp;lookup_commit(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, tag_type)) {
diff --git a/tree.c b/tree.c
index 21fd80b80..28ce930b9 100644
--- a/tree.c
+++ b/tree.c
@@ -110,7 +110,7 @@ static int read_tree_1(struct tree *tree, struct strbuf *base,
 		len = tree_entry_len(&amp;entry);
 		strbuf_add(base, entry.path, len);
 		strbuf_addch(base, '/');
-		retval = read_tree_1(lookup_tree(oid.hash),
+		retval = read_tree_1(lookup_tree(&amp;oid),
 				     base, stage, pathspec,
 				     fn, context);
 		strbuf_setlen(base, oldlen);
@@ -184,11 +184,11 @@ int read_tree(struct tree *tree, int stage, struct pathspec *match)
 	return 0;
 }
 
-struct tree *lookup_tree(const unsigned char *sha1)
+struct tree *lookup_tree(const struct object_id *oid)
 {
-	struct object *obj = lookup_object(sha1);
+	struct object *obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		return create_object(sha1, alloc_tree_node());
+		return create_object(oid-&gt;hash, alloc_tree_node());
 	return object_as_type(obj, OBJ_TREE, 0);
 }
 
diff --git a/tree.h b/tree.h
index d24786cba..2b2c8dbbe 100644
--- a/tree.h
+++ b/tree.h
@@ -12,7 +12,7 @@ struct tree {
 	unsigned long size;
 };
 
-struct tree *lookup_tree(const unsigned char *sha1);
+struct tree *lookup_tree(const struct object_id *oid);
 
 int parse_tree_buffer(struct tree *item, void *buffer, unsigned long size);
 
diff --git a/walker.c b/walker.c
index 3d6029c8e..eae9fb974 100644
--- a/walker.c
+++ b/walker.c
@@ -47,7 +47,7 @@ static int process_tree(struct walker *walker, struct tree *tree)
 		if (S_ISGITLINK(entry.mode))
 			continue;
 		if (S_ISDIR(entry.mode)) {
-			struct tree *tree = lookup_tree(entry.oid-&gt;hash);
+			struct tree *tree = lookup_tree(entry.oid);
 			if (tree)
 				obj = &amp;tree-&gt;object;
 		}

<a href="#m391adf34d36b0e6a3310cd9b07c12a79f53c1457" id="e391adf34d36b0e6a3310cd9b07c12a79f53c1457">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-33-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r391adf34d36b0e6a3310cd9b07c12a79f53c1457">52+ messages in thread</a></pre><hr><pre><a href="#e663203f9dd55b3399d534345634dea0738de99f6" id="m663203f9dd55b3399d534345634dea0738de99f6">*</a> <b>[PATCH v2 33/53] log-tree: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r391adf34d36b0e6a3310cd9b07c12a79f53c1457">(29 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m391adf34d36b0e6a3310cd9b07c12a79f53c1457">[PATCH v2 32/53] Convert lookup_tree to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8cd4976cf14f674146e9ed8cea81aa8aee2ec554">[PATCH v2 34/53] Convert lookup_tag to struct object_id</a> brian m. carlson
                   ` <a href="#r8cd4976cf14f674146e9ed8cea81aa8aee2ec554">(19 subsequent siblings)</a>
  <a href="#r663203f9dd55b3399d534345634dea0738de99f6">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the remaining functions to take pointers to struct object_id
instead of pointers to unsigned char, and update the internals of these
functions as well.  Among these functions is a caller of lookup_tag,
which we will convert shortly.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 log-tree.c | 18 +++++++++---------
 1 file changed, 9 insertions(+), 9 deletions(-)

diff --git a/log-tree.c b/log-tree.c
index 7fb1a85d2..169fd039f 100644
--- a/log-tree.c
+++ b/log-tree.c
@@ -184,7 +184,7 @@ static const struct name_decoration *current_pointed_by_HEAD(const struct name_d
 {
 	const struct name_decoration *list, *head = NULL;
 	const char *branch_name = NULL;
-	unsigned char unused[20];
+	struct object_id unused;
 	int rru_flags;
 
 	/* First find HEAD */
@@ -197,7 +197,7 @@ static const struct name_decoration *current_pointed_by_HEAD(const struct name_d
 		return NULL;
 
 	/* Now resolve and find the matching current branch */
-	branch_name = resolve_ref_unsafe("HEAD", 0, unused, &amp;rru_flags);
+	branch_name = resolve_ref_unsafe("HEAD", 0, unused.hash, &amp;rru_flags);
 	if (!(rru_flags &amp; REF_ISSYMREF))
 		return NULL;
 
@@ -456,13 +456,13 @@ static void show_signature(struct rev_info *opt, struct commit *commit)
 	strbuf_release(&amp;signature);
 }
 
-static int which_parent(const unsigned char *sha1, const struct commit *commit)
+static int which_parent(const struct object_id *oid, const struct commit *commit)
 {
 	int nth;
 	const struct commit_list *parent;
 
 	for (nth = 0, parent = commit-&gt;parents; parent; parent = parent-&gt;next) {
-		if (!hashcmp(parent-&gt;item-&gt;object.oid.hash, sha1))
+		if (!oidcmp(&amp;parent-&gt;item-&gt;object.oid, oid))
 			return nth;
 		nth++;
 	}
@@ -481,14 +481,14 @@ static void show_one_mergetag(struct commit *commit,
 			      void *data)
 {
 	struct rev_info *opt = (struct rev_info *)data;
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct tag *tag;
 	struct strbuf verify_message;
 	int status, nth;
 	size_t payload_size, gpg_message_offset;
 
-	hash_sha1_file(extra-&gt;value, extra-&gt;len, typename(OBJ_TAG), sha1);
-	tag = lookup_tag(sha1);
+	hash_sha1_file(extra-&gt;value, extra-&gt;len, typename(OBJ_TAG), oid.hash);
+	tag = lookup_tag(oid.hash);
 	if (!tag)
 		return; /* error message already given */
 
@@ -500,7 +500,7 @@ static void show_one_mergetag(struct commit *commit,
 			  &amp;commit-&gt;parents-&gt;next-&gt;item-&gt;object.oid))
 		strbuf_addf(&amp;verify_message,
 			    "merged tag '%s'\n", tag-&gt;tag);
-	else if ((nth = which_parent(tag-&gt;tagged-&gt;oid.hash, commit)) &lt; 0)
+	else if ((nth = which_parent(&amp;tag-&gt;tagged-&gt;oid, commit)) &lt; 0)
 		strbuf_addf(&amp;verify_message, "tag %s names a non-parent %s\n",
 				    tag-&gt;tag, tag-&gt;tagged-&gt;oid.hash);
 	else
@@ -536,7 +536,7 @@ void show_log(struct rev_info *opt)
 	struct strbuf msgbuf = STRBUF_INIT;
 	struct log_info *log = opt-&gt;loginfo;
 	struct commit *commit = log-&gt;commit, *parent = log-&gt;parent;
-	int abbrev_commit = opt-&gt;abbrev_commit ? opt-&gt;abbrev : 40;
+	int abbrev_commit = opt-&gt;abbrev_commit ? opt-&gt;abbrev : GIT_SHA1_HEXSZ;
 	const char *extra_headers = opt-&gt;extra_headers;
 	struct pretty_print_context ctx = {0};
 

<a href="#m663203f9dd55b3399d534345634dea0738de99f6" id="e663203f9dd55b3399d534345634dea0738de99f6">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-34-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r663203f9dd55b3399d534345634dea0738de99f6">52+ messages in thread</a></pre><hr><pre><a href="#e8cd4976cf14f674146e9ed8cea81aa8aee2ec554" id="m8cd4976cf14f674146e9ed8cea81aa8aee2ec554">*</a> <b>[PATCH v2 34/53] Convert lookup_tag to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r663203f9dd55b3399d534345634dea0738de99f6">(30 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m663203f9dd55b3399d534345634dea0738de99f6">[PATCH v2 33/53] log-tree: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m43ca35cb6d4cf1c251a29a4a0b10009f639c8014">[PATCH v2 35/53] Convert the verify_pack callback to struct object_id</a> brian m. carlson
                   ` <a href="#r43ca35cb6d4cf1c251a29a4a0b10009f639c8014">(18 subsequent siblings)</a>
  <a href="#r8cd4976cf14f674146e9ed8cea81aa8aee2ec554">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert lookup_tag to take a pointer to struct object_id.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/describe.c     | 6 +++---
 builtin/pack-objects.c | 2 +-
 builtin/replace.c      | 2 +-
 log-tree.c             | 2 +-
 object.c               | 2 +-
 sha1_name.c            | 2 +-
 tag.c                  | 8 ++++----
 tag.h                  | 2 +-
 8 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/builtin/describe.c b/builtin/describe.c
index f6032f593..893c8789f 100644
--- a/builtin/describe.c
+++ b/builtin/describe.c
@@ -79,13 +79,13 @@ static int replace_name(struct commit_name *e,
 		struct tag *t;
 
 		if (!e-&gt;tag) {
-			t = lookup_tag(e-&gt;oid.hash);
+			t = lookup_tag(&amp;e-&gt;oid);
 			if (!t || parse_tag(t))
 				return 1;
 			e-&gt;tag = t;
 		}
 
-		t = lookup_tag(oid-&gt;hash);
+		t = lookup_tag(oid);
 		if (!t || parse_tag(t))
 			return 0;
 		*tag = t;
@@ -245,7 +245,7 @@ static unsigned long finish_depth_computation(
 static void display_name(struct commit_name *n)
 {
 	if (n-&gt;prio == 2 &amp;&amp; !n-&gt;tag) {
-		n-&gt;tag = lookup_tag(n-&gt;oid.hash);
+		n-&gt;tag = lookup_tag(&amp;n-&gt;oid);
 		if (!n-&gt;tag || parse_tag(n-&gt;tag))
 			die(_("annotated tag %s not available"), n-&gt;path);
 	}
diff --git a/builtin/pack-objects.c b/builtin/pack-objects.c
index d76ff0542..7cebb5a7f 100644
--- a/builtin/pack-objects.c
+++ b/builtin/pack-objects.c
@@ -2348,7 +2348,7 @@ static void add_tag_chain(const struct object_id *oid)
 	if (packlist_find(&amp;to_pack, oid-&gt;hash, NULL))
 		return;
 
-	tag = lookup_tag(oid-&gt;hash);
+	tag = lookup_tag(oid);
 	while (1) {
 		if (!tag || parse_tag(tag) || !tag-&gt;tagged)
 			die("unable to pack objects reachable from tag %s",
diff --git a/builtin/replace.c b/builtin/replace.c
index 3c44ef750..c921bc976 100644
--- a/builtin/replace.c
+++ b/builtin/replace.c
@@ -355,7 +355,7 @@ static void check_one_mergetag(struct commit *commit,
 	int i;
 
 	hash_sha1_file(extra-&gt;value, extra-&gt;len, typename(OBJ_TAG), tag_oid.hash);
-	tag = lookup_tag(tag_oid.hash);
+	tag = lookup_tag(&amp;tag_oid);
 	if (!tag)
 		die(_("bad mergetag in commit '%s'"), ref);
 	if (parse_tag_buffer(tag, extra-&gt;value, extra-&gt;len))
diff --git a/log-tree.c b/log-tree.c
index 169fd039f..6532c892c 100644
--- a/log-tree.c
+++ b/log-tree.c
@@ -488,7 +488,7 @@ static void show_one_mergetag(struct commit *commit,
 	size_t payload_size, gpg_message_offset;
 
 	hash_sha1_file(extra-&gt;value, extra-&gt;len, typename(OBJ_TAG), oid.hash);
-	tag = lookup_tag(oid.hash);
+	tag = lookup_tag(&amp;oid);
 	if (!tag)
 		return; /* error message already given */
 
diff --git a/object.c b/object.c
index d23c5fad3..dd4d3a1ea 100644
--- a/object.c
+++ b/object.c
@@ -220,7 +220,7 @@ struct object *parse_object_buffer(const unsigned char *sha1, enum object_type t
 			obj = &amp;commit-&gt;object;
 		}
 	} else if (type == OBJ_TAG) {
-		struct tag *tag = lookup_tag(sha1);
+		struct tag *tag = lookup_tag(&amp;oid);
 		if (tag) {
 			if (parse_tag_buffer(tag, buffer, size))
 			       return NULL;
diff --git a/sha1_name.c b/sha1_name.c
index 390a09c41..b7e09ac13 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -361,7 +361,7 @@ static int show_ambiguous_object(const struct object_id *oid, void *data)
 			format_commit_message(commit, " %ad - %s", &amp;desc, &amp;pp);
 		}
 	} else if (type == OBJ_TAG) {
-		struct tag *tag = lookup_tag(oid-&gt;hash);
+		struct tag *tag = lookup_tag(oid);
 		if (!parse_tag(tag) &amp;&amp; tag-&gt;tag)
 			strbuf_addf(&amp;desc, " %s", tag-&gt;tag);
 	}
diff --git a/tag.c b/tag.c
index 062516b40..571798519 100644
--- a/tag.c
+++ b/tag.c
@@ -89,11 +89,11 @@ struct object *deref_tag_noverify(struct object *o)
 	return o;
 }
 
-struct tag *lookup_tag(const unsigned char *sha1)
+struct tag *lookup_tag(const struct object_id *oid)
 {
-	struct object *obj = lookup_object(sha1);
+	struct object *obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		return create_object(sha1, alloc_tag_node());
+		return create_object(oid-&gt;hash, alloc_tag_node());
 	return object_as_type(obj, OBJ_TAG, 0);
 }
 
@@ -148,7 +148,7 @@ int parse_tag_buffer(struct tag *item, const void *data, unsigned long size)
 	} else if (!strcmp(type, commit_type)) {
 		item-&gt;tagged = &amp;lookup_commit(&amp;oid)-&gt;object;
 	} else if (!strcmp(type, tag_type)) {
-		item-&gt;tagged = &amp;lookup_tag(oid.hash)-&gt;object;
+		item-&gt;tagged = &amp;lookup_tag(&amp;oid)-&gt;object;
 	} else {
 		error("Unknown type %s", type);
 		item-&gt;tagged = NULL;
diff --git a/tag.h b/tag.h
index a5721b673..8d6fc2814 100644
--- a/tag.h
+++ b/tag.h
@@ -12,7 +12,7 @@ struct tag {
 	unsigned long date;
 };
 
-extern struct tag *lookup_tag(const unsigned char *sha1);
+extern struct tag *lookup_tag(const struct object_id *oid);
 extern int parse_tag_buffer(struct tag *item, const void *data, unsigned long size);
 extern int parse_tag(struct tag *item);
 extern struct object *deref_tag(struct object *, const char *, int);

<a href="#m8cd4976cf14f674146e9ed8cea81aa8aee2ec554" id="e8cd4976cf14f674146e9ed8cea81aa8aee2ec554">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-35-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8cd4976cf14f674146e9ed8cea81aa8aee2ec554">52+ messages in thread</a></pre><hr><pre><a href="#e43ca35cb6d4cf1c251a29a4a0b10009f639c8014" id="m43ca35cb6d4cf1c251a29a4a0b10009f639c8014">*</a> <b>[PATCH v2 35/53] Convert the verify_pack callback to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8cd4976cf14f674146e9ed8cea81aa8aee2ec554">(31 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8cd4976cf14f674146e9ed8cea81aa8aee2ec554">[PATCH v2 34/53] Convert lookup_tag to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m02ced868770a7c67f5b7e1d7a054601f4af81473">[PATCH v2 36/53] Convert struct ref_array_item to struct object_id</a> brian m. carlson
                   ` <a href="#r02ced868770a7c67f5b7e1d7a054601f4af81473">(17 subsequent siblings)</a>
  <a href="#r43ca35cb6d4cf1c251a29a4a0b10009f639c8014">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái 
Ngọc Duy

Make the verify_pack_callback take a pointer to struct object_id.
Change the pack checksum to use GIT_MAX_RAWSZ, even though it is not
strictly an object ID.  Doing so ensures resilience against future hash
size changes, and allows us to remove hard-coded assumptions about how
big the buffer needs to be.

Also, use a union to convert the pointer from nth_packed_object_sha1 to
to a pointer to struct object_id.  This behavior is compatible with GCC
and clang and explicitly sanctioned by C11.  The alternatives are to
just perform a cast, which would run afoul of strict aliasing rules, but
should just work, and changing the pointer into an instance of struct
object_id and copying the value.  The latter operation could seriously
bloat memory usage on fsck, which already uses a lot of memory on some
repositories.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/fsck.c |  6 +++---
 pack-check.c   | 25 ++++++++++++++-----------
 pack.h         |  2 +-
 3 files changed, 18 insertions(+), 15 deletions(-)

diff --git a/builtin/fsck.c b/builtin/fsck.c
index 2f67e8217..a187054da 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
@@ -377,7 +377,7 @@ static int fsck_obj(struct object *obj)
 	return 0;
 }
 
-static int fsck_obj_buffer(const unsigned char *sha1, enum object_type 
type,
+static int fsck_obj_buffer(const struct object_id *oid, enum 
object_type type,
 			   unsigned long size, void *buffer, int *eaten)
 {
 	/*
@@ -385,10 +385,10 @@ static int fsck_obj_buffer(const unsigned char 
*sha1, enum object_type type,
 	 * verify_packfile(), data_valid variable for details.
 	 */
 	struct object *obj;
-	obj = parse_object_buffer(sha1, type, size, buffer, eaten);
+	obj = parse_object_buffer(oid-&gt;hash, type, size, buffer, eaten);
 	if (!obj) {
 		errors_found |= ERROR_OBJECT;
-		return error("%s: object corrupt or missing", sha1_to_hex(sha1));
+		return error("%s: object corrupt or missing", oid_to_hex(oid));
 	}
 	obj-&gt;flags = HAS_OBJ;
 	return fsck_obj(obj);
diff --git a/pack-check.c b/pack-check.c
index 27f70d345..e1fcb228f 100644
--- a/pack-check.c
+++ b/pack-check.c
@@ -5,7 +5,10 @@
 
 struct idx_entry {
 	off_t                offset;
-	const unsigned char *sha1;
+	union idx_entry_object {
+		const unsigned char *hash;
+		struct object_id *oid;
+	} oid;
 	unsigned int nr;
 };
 
@@ -51,7 +54,7 @@ static int verify_packfile(struct packed_git *p,
 	off_t index_size = p-&gt;index_size;
 	const unsigned char *index_base = p-&gt;index_data;
 	git_SHA_CTX ctx;
-	unsigned char sha1[20], *pack_sig;
+	unsigned char hash[GIT_MAX_RAWSZ], *pack_sig;
 	off_t offset = 0, pack_sig_ofs = 0;
 	uint32_t nr_objects, i;
 	int err = 0;
@@ -71,9 +74,9 @@ static int verify_packfile(struct packed_git *p,
 			remaining -= (unsigned int)(offset - pack_sig_ofs);
 		git_SHA1_Update(&amp;ctx, in, remaining);
 	} while (offset &lt; pack_sig_ofs);
-	git_SHA1_Final(sha1, &amp;ctx);
+	git_SHA1_Final(hash, &amp;ctx);
 	pack_sig = use_pack(p, w_curs, pack_sig_ofs, NULL);
-	if (hashcmp(sha1, pack_sig))
+	if (hashcmp(hash, pack_sig))
 		err = error("%s SHA1 checksum mismatch",
 			    p-&gt;pack_name);
 	if (hashcmp(index_base + index_size - 40, pack_sig))
@@ -90,8 +93,8 @@ static int verify_packfile(struct packed_git *p,
 	entries[nr_objects].offset = pack_sig_ofs;
 	/* first sort entries by pack offset, since unpacking them is more 
efficient that way */
 	for (i = 0; i &lt; nr_objects; i++) {
-		entries[i].sha1 = nth_packed_object_sha1(p, i);
-		if (!entries[i].sha1)
+		entries[i].oid.hash = nth_packed_object_sha1(p, i);
+		if (!entries[i].oid.hash)
 			die("internal error pack-check nth-packed-object");
 		entries[i].offset = nth_packed_object_offset(p, i);
 		entries[i].nr = i;
@@ -112,7 +115,7 @@ static int verify_packfile(struct packed_git *p,
 			if (check_pack_crc(p, w_curs, offset, len, nr))
 				err = error("index CRC mismatch for object %s "
 					    "from %s at offset %"PRIuMAX"",
-					    sha1_to_hex(entries[i].sha1),
+					    oid_to_hex(entries[i].oid.oid),
 					    p-&gt;pack_name, (uintmax_t)offset);
 		}
 
@@ -135,14 +138,14 @@ static int verify_packfile(struct packed_git *p,
 
 		if (data_valid &amp;&amp; !data)
 			err = error("cannot unpack %s from %s at offset %"PRIuMAX"",
-				    sha1_to_hex(entries[i].sha1), p-&gt;pack_name,
+				    oid_to_hex(entries[i].oid.oid), p-&gt;pack_name,
 				    (uintmax_t)entries[i].offset);
-		else if (check_sha1_signature(entries[i].sha1, data, size, 
typename(type)))
+		else if (check_sha1_signature(entries[i].oid.hash, data, size, 
typename(type)))
 			err = error("packed %s from %s is corrupt",
-				    sha1_to_hex(entries[i].sha1), p-&gt;pack_name);
+				    oid_to_hex(entries[i].oid.oid), p-&gt;pack_name);
 		else if (fn) {
 			int eaten = 0;
-			err |= fn(entries[i].sha1, type, size, data, &amp;eaten);
+			err |= fn(entries[i].oid.oid, type, size, data, &amp;eaten);
 			if (eaten)
 				data = NULL;
 		}
diff --git a/pack.h b/pack.h
index c7de42ef3..8294341af 100644
--- a/pack.h
+++ b/pack.h
@@ -75,7 +75,7 @@ struct pack_idx_entry {
 
 struct progress;
 /* Note, the data argument could be NULL if object type is blob */
-typedef int (*verify_fn)(const unsigned char*, enum object_type, 
unsigned long, void*, int*);
+typedef int (*verify_fn)(const struct object_id *, enum object_type, 
unsigned long, void*, int*);
 
 extern const char *write_idx_file(const char *index_name, struct 
pack_idx_entry **objects, int nr_objects, const struct pack_idx_option 
*, const unsigned char *sha1);
 extern int check_pack_crc(struct packed_git *p, struct pack_window 
**w_curs, off_t offset, off_t len, unsigned int nr);

<a href="#m43ca35cb6d4cf1c251a29a4a0b10009f639c8014" id="e43ca35cb6d4cf1c251a29a4a0b10009f639c8014">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-36-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r43ca35cb6d4cf1c251a29a4a0b10009f639c8014">52+ messages in thread</a></pre><hr><pre><a href="#e02ced868770a7c67f5b7e1d7a054601f4af81473" id="m02ced868770a7c67f5b7e1d7a054601f4af81473">*</a> <b>[PATCH v2 36/53] Convert struct ref_array_item to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r43ca35cb6d4cf1c251a29a4a0b10009f639c8014">(32 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m43ca35cb6d4cf1c251a29a4a0b10009f639c8014">[PATCH v2 35/53] Convert the verify_pack callback to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m60a7de9b41905363acb0fbd42eacb298bb47af26">[PATCH v2 37/53] ref-filter: convert some static functions to struct object_id</a> brian m. carlson
                   ` <a href="#r60a7de9b41905363acb0fbd42eacb298bb47af26">(16 subsequent siblings)</a>
  <a href="#r02ced868770a7c67f5b7e1d7a054601f4af81473">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert struct ref_array_item to use struct object_id by changing the
definition and applying the following semantic patch, plus the standard
object_id transforms:

@@
struct ref_array_item E1;
@@
- E1.objectname
+ E1.objectname.hash

@@
struct ref_array_item *E1;
@@
- E1-&gt;objectname
+ E1-&gt;objectname.hash

This transformation allows us to convert get_obj, which is needed to
convert parse_object_buffer.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 ref-filter.c | 10 +++++-----
 ref-filter.h |  2 +-
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/ref-filter.c b/ref-filter.c
index e1d18ac0d..77aee273f 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -1366,7 +1366,7 @@ static void populate_value(struct ref_array_item *ref)
 				v-&gt;s = xstrdup(buf + 1);
 			}
 			continue;
-		} else if (!deref &amp;&amp; grab_objectname(name, ref-&gt;objectname, v, atom)) {
+		} else if (!deref &amp;&amp; grab_objectname(name, ref-&gt;objectname.hash, v, atom)) {
 			continue;
 		} else if (!strcmp(name, "HEAD")) {
 			const char *head;
@@ -1415,13 +1415,13 @@ static void populate_value(struct ref_array_item *ref)
 	return;
 
  need_obj:
-	buf = get_obj(ref-&gt;objectname, &amp;obj, &amp;size, &amp;eaten);
+	buf = get_obj(ref-&gt;objectname.hash, &amp;obj, &amp;size, &amp;eaten);
 	if (!buf)
 		die(_("missing object %s for %s"),
-		    sha1_to_hex(ref-&gt;objectname), ref-&gt;refname);
+		    oid_to_hex(&amp;ref-&gt;objectname), ref-&gt;refname);
 	if (!obj)
 		die(_("parse_object_buffer failed on %s for %s"),
-		    sha1_to_hex(ref-&gt;objectname), ref-&gt;refname);
+		    oid_to_hex(&amp;ref-&gt;objectname), ref-&gt;refname);
 
 	grab_values(ref-&gt;value, 0, obj, buf, size);
 	if (!eaten)
@@ -1704,7 +1704,7 @@ static struct ref_array_item *new_ref_array_item(const char *refname,
 {
 	struct ref_array_item *ref;
 	FLEX_ALLOC_STR(ref, refname, refname);
-	hashcpy(ref-&gt;objectname, objectname);
+	hashcpy(ref-&gt;objectname.hash, objectname);
 	ref-&gt;flag = flag;
 
 	return ref;
diff --git a/ref-filter.h b/ref-filter.h
index c20167aa3..6552024f0 100644
--- a/ref-filter.h
+++ b/ref-filter.h
@@ -34,7 +34,7 @@ struct ref_sorting {
 };
 
 struct ref_array_item {
-	unsigned char objectname[20];
+	struct object_id objectname;
 	int flag;
 	unsigned int kind;
 	const char *symref;

<a href="#m02ced868770a7c67f5b7e1d7a054601f4af81473" id="e02ced868770a7c67f5b7e1d7a054601f4af81473">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-37-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r02ced868770a7c67f5b7e1d7a054601f4af81473">52+ messages in thread</a></pre><hr><pre><a href="#e60a7de9b41905363acb0fbd42eacb298bb47af26" id="m60a7de9b41905363acb0fbd42eacb298bb47af26">*</a> <b>[PATCH v2 37/53] ref-filter: convert some static functions to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r02ced868770a7c67f5b7e1d7a054601f4af81473">(33 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m02ced868770a7c67f5b7e1d7a054601f4af81473">[PATCH v2 36/53] Convert struct ref_array_item to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8220cedc15796315efb7be2c60c4f981a89e6864">[PATCH v2 38/53] refs: convert struct ref_update to use struct object_id</a> brian m. carlson
                   ` <a href="#r8220cedc15796315efb7be2c60c4f981a89e6864">(15 subsequent siblings)</a>
  <a href="#r60a7de9b41905363acb0fbd42eacb298bb47af26">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Among the converted functions is a caller of parse_object_buffer, which
we will convert later.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 ref-filter.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/ref-filter.c b/ref-filter.c
index 77aee273f..56fc990a5 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -677,13 +677,13 @@ int verify_ref_format(const char *format)
  * by the "struct object" representation, set *eaten as well---it is a
  * signal from parse_object_buffer to us not to free the buffer.
  */
-static void *get_obj(const unsigned char *sha1, struct object **obj, unsigned long *sz, int *eaten)
+static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
 {
 	enum object_type type;
-	void *buf = read_sha1_file(sha1, &amp;type, sz);
+	void *buf = read_sha1_file(oid-&gt;hash, &amp;type, sz);
 
 	if (buf)
-		*obj = parse_object_buffer(sha1, type, *sz, buf, eaten);
+		*obj = parse_object_buffer(oid-&gt;hash, type, *sz, buf, eaten);
 	else
 		*obj = NULL;
 	return buf;
@@ -1293,7 +1293,7 @@ static void populate_value(struct ref_array_item *ref)
 	struct object *obj;
 	int eaten, i;
 	unsigned long size;
-	const unsigned char *tagged;
+	const struct object_id *tagged;
 
 	ref-&gt;value = xcalloc(used_atom_cnt, sizeof(struct atom_value));
 
@@ -1370,10 +1370,10 @@ static void populate_value(struct ref_array_item *ref)
 			continue;
 		} else if (!strcmp(name, "HEAD")) {
 			const char *head;
-			unsigned char sha1[20];
+			struct object_id oid;
 
 			head = resolve_ref_unsafe("HEAD", RESOLVE_REF_READING,
-						  sha1, NULL);
+						  oid.hash, NULL);
 			if (head &amp;&amp; !strcmp(ref-&gt;refname, head))
 				v-&gt;s = "*";
 			else
@@ -1415,7 +1415,7 @@ static void populate_value(struct ref_array_item *ref)
 	return;
 
  need_obj:
-	buf = get_obj(ref-&gt;objectname.hash, &amp;obj, &amp;size, &amp;eaten);
+	buf = get_obj(&amp;ref-&gt;objectname, &amp;obj, &amp;size, &amp;eaten);
 	if (!buf)
 		die(_("missing object %s for %s"),
 		    oid_to_hex(&amp;ref-&gt;objectname), ref-&gt;refname);
@@ -1438,7 +1438,7 @@ static void populate_value(struct ref_array_item *ref)
 	 * If it is a tag object, see if we use a value that derefs
 	 * the object, and if we do grab the object it refers to.
 	 */
-	tagged = ((struct tag *)obj)-&gt;tagged-&gt;oid.hash;
+	tagged = &amp;((struct tag *)obj)-&gt;tagged-&gt;oid;
 
 	/*
 	 * NEEDSWORK: This derefs tag only once, which
@@ -1449,10 +1449,10 @@ static void populate_value(struct ref_array_item *ref)
 	buf = get_obj(tagged, &amp;obj, &amp;size, &amp;eaten);
 	if (!buf)
 		die(_("missing object %s for %s"),
-		    sha1_to_hex(tagged), ref-&gt;refname);
+		    oid_to_hex(tagged), ref-&gt;refname);
 	if (!obj)
 		die(_("parse_object_buffer failed on %s for %s"),
-		    sha1_to_hex(tagged), ref-&gt;refname);
+		    oid_to_hex(tagged), ref-&gt;refname);
 	grab_values(ref-&gt;value, 1, obj, buf, size);
 	if (!eaten)
 		free(buf);

<a href="#m60a7de9b41905363acb0fbd42eacb298bb47af26" id="e60a7de9b41905363acb0fbd42eacb298bb47af26">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-38-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r60a7de9b41905363acb0fbd42eacb298bb47af26">52+ messages in thread</a></pre><hr><pre><a href="#e8220cedc15796315efb7be2c60c4f981a89e6864" id="m8220cedc15796315efb7be2c60c4f981a89e6864">*</a> <b>[PATCH v2 38/53] refs: convert struct ref_update to use struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r60a7de9b41905363acb0fbd42eacb298bb47af26">(34 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m60a7de9b41905363acb0fbd42eacb298bb47af26">[PATCH v2 37/53] ref-filter: convert some static functions to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mbbc5a0892326a643bb95010e8b8a11dda2f843c2">[PATCH v2 39/53] refs/files-backend: convert many internals to struct object_id</a> brian m. carlson
                   ` <a href="#rbbc5a0892326a643bb95010e8b8a11dda2f843c2">(14 subsequent siblings)</a>
  <a href="#r8220cedc15796315efb7be2c60c4f981a89e6864">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert struct ref_array_item to use struct object_id by changing the
definition and applying the following semantic patch, plus the standard
object_id transforms:

@@
struct ref_update E1;
@@
- E1.new_sha1
+ E1.new_oid.hash

@@
struct ref_update *E1;
@@
- E1-&gt;new_sha1
+ E1-&gt;new_oid.hash

@@
struct ref_update E1;
@@
- E1.old_sha1
+ E1.old_oid.hash

@@
struct ref_update *E1;
@@
- E1-&gt;old_sha1
+ E1-&gt;old_oid.hash

This transformation allows us to convert write_ref_to_lockfile, which is
required to convert parse_object.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 refs.c               |  4 ++--
 refs/files-backend.c | 29 +++++++++++++++--------------
 refs/refs-internal.h |  4 ++--
 3 files changed, 19 insertions(+), 18 deletions(-)

diff --git a/refs.c b/refs.c
index df75f8e0d..c738f5911 100644
--- a/refs.c
+++ b/refs.c
@@ -882,9 +882,9 @@ struct ref_update *ref_transaction_add_update(
 	update-&gt;flags = flags;
 
 	if (flags &amp; REF_HAVE_NEW)
-		hashcpy(update-&gt;new_sha1, new_sha1);
+		hashcpy(update-&gt;new_oid.hash, new_sha1);
 	if (flags &amp; REF_HAVE_OLD)
-		hashcpy(update-&gt;old_sha1, old_sha1);
+		hashcpy(update-&gt;old_oid.hash, old_sha1);
 	update-&gt;msg = xstrdup_or_null(msg);
 	return update;
 }
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 298a838c5..413505ff0 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -2633,7 +2633,7 @@ static int split_head_update(struct ref_update *update,
 	new_update = ref_transaction_add_update(
 			transaction, "HEAD",
 			update-&gt;flags | REF_LOG_ONLY | REF_NODEREF,
-			update-&gt;new_sha1, update-&gt;old_sha1,
+			update-&gt;new_oid.hash, update-&gt;old_oid.hash,
 			update-&gt;msg);
 
 	item-&gt;util = new_update;
@@ -2690,7 +2690,7 @@ static int split_symref_update(struct files_ref_store *refs,
 
 	new_update = ref_transaction_add_update(
 			transaction, referent, new_flags,
-			update-&gt;new_sha1, update-&gt;old_sha1,
+			update-&gt;new_oid.hash, update-&gt;old_oid.hash,
 			update-&gt;msg);
 
 	new_update-&gt;parent_update = update;
@@ -2729,10 +2729,10 @@ static int check_old_oid(struct ref_update *update, struct object_id *oid,
 			 struct strbuf *err)
 {
 	if (!(update-&gt;flags &amp; REF_HAVE_OLD) ||
-		   !hashcmp(oid-&gt;hash, update-&gt;old_sha1))
+		   !oidcmp(oid, &amp;update-&gt;old_oid))
 		return 0;
 
-	if (is_null_sha1(update-&gt;old_sha1))
+	if (is_null_oid(&amp;update-&gt;old_oid))
 		strbuf_addf(err, "cannot lock ref '%s': "
 			    "reference already exists",
 			    original_update_refname(update));
@@ -2740,13 +2740,13 @@ static int check_old_oid(struct ref_update *update, struct object_id *oid,
 		strbuf_addf(err, "cannot lock ref '%s': "
 			    "reference is missing but expected %s",
 			    original_update_refname(update),
-			    sha1_to_hex(update-&gt;old_sha1));
+			    oid_to_hex(&amp;update-&gt;old_oid));
 	else
 		strbuf_addf(err, "cannot lock ref '%s': "
 			    "is at %s but expected %s",
 			    original_update_refname(update),
 			    oid_to_hex(oid),
-			    sha1_to_hex(update-&gt;old_sha1));
+			    oid_to_hex(&amp;update-&gt;old_oid));
 
 	return -1;
 }
@@ -2773,13 +2773,13 @@ static int lock_ref_for_update(struct files_ref_store *refs,
 {
 	struct strbuf referent = STRBUF_INIT;
 	int mustexist = (update-&gt;flags &amp; REF_HAVE_OLD) &amp;&amp;
-		!is_null_sha1(update-&gt;old_sha1);
+		!is_null_oid(&amp;update-&gt;old_oid);
 	int ret;
 	struct ref_lock *lock;
 
 	files_assert_main_repository(refs, "lock_ref_for_update");
 
-	if ((update-&gt;flags &amp; REF_HAVE_NEW) &amp;&amp; is_null_sha1(update-&gt;new_sha1))
+	if ((update-&gt;flags &amp; REF_HAVE_NEW) &amp;&amp; is_null_oid(&amp;update-&gt;new_oid))
 		update-&gt;flags |= REF_DELETING;
 
 	if (head_ref) {
@@ -2861,12 +2861,12 @@ static int lock_ref_for_update(struct files_ref_store *refs,
 	    !(update-&gt;flags &amp; REF_DELETING) &amp;&amp;
 	    !(update-&gt;flags &amp; REF_LOG_ONLY)) {
 		if (!(update-&gt;type &amp; REF_ISSYMREF) &amp;&amp;
-		    !hashcmp(lock-&gt;old_oid.hash, update-&gt;new_sha1)) {
+		    !oidcmp(&amp;lock-&gt;old_oid, &amp;update-&gt;new_oid)) {
 			/*
 			 * The reference already has the desired
 			 * value, so we don't need to write it.
 			 */
-		} else if (write_ref_to_lockfile(lock, update-&gt;new_sha1,
+		} else if (write_ref_to_lockfile(lock, update-&gt;new_oid.hash,
 						 err)) {
 			char *write_err = strbuf_detach(err, NULL);
 
@@ -3002,7 +3002,7 @@ static int files_transaction_commit(struct ref_store *ref_store,
 			if (files_log_ref_write(refs,
 						lock-&gt;ref_name,
 						lock-&gt;old_oid.hash,
-						update-&gt;new_sha1,
+						update-&gt;new_oid.hash,
 						update-&gt;msg, update-&gt;flags,
 						err)) {
 				char *old_msg = strbuf_detach(err, NULL);
@@ -3151,7 +3151,7 @@ static int files_initial_transaction_commit(struct ref_store *ref_store,
 		struct ref_update *update = transaction-&gt;updates[i];
 
 		if ((update-&gt;flags &amp; REF_HAVE_OLD) &amp;&amp;
-		    !is_null_sha1(update-&gt;old_sha1))
+		    !is_null_oid(&amp;update-&gt;old_oid))
 			die("BUG: initial ref transaction with old_sha1 set");
 		if (refs_verify_refname_available(&amp;refs-&gt;base, update-&gt;refname,
 						  &amp;affected_refnames, NULL,
@@ -3172,8 +3172,9 @@ static int files_initial_transaction_commit(struct ref_store *ref_store,
 		struct ref_update *update = transaction-&gt;updates[i];
 
 		if ((update-&gt;flags &amp; REF_HAVE_NEW) &amp;&amp;
-		    !is_null_sha1(update-&gt;new_sha1))
-			add_packed_ref(refs, update-&gt;refname, update-&gt;new_sha1);
+		    !is_null_oid(&amp;update-&gt;new_oid))
+			add_packed_ref(refs, update-&gt;refname,
+				       update-&gt;new_oid.hash);
 	}
 
 	if (commit_packed_refs(refs)) {
diff --git a/refs/refs-internal.h b/refs/refs-internal.h
index 3d46131ef..b267d5ca9 100644
--- a/refs/refs-internal.h
+++ b/refs/refs-internal.h
@@ -130,13 +130,13 @@ struct ref_update {
 	/*
 	 * If (flags &amp; REF_HAVE_NEW), set the reference to this value:
 	 */
-	unsigned char new_sha1[20];
+	struct object_id new_oid;
 
 	/*
 	 * If (flags &amp; REF_HAVE_OLD), check that the reference
 	 * previously had this value:
 	 */
-	unsigned char old_sha1[20];
+	struct object_id old_oid;
 
 	/*
 	 * One or more of REF_HAVE_NEW, REF_HAVE_OLD, REF_NODEREF,

<a href="#m8220cedc15796315efb7be2c60c4f981a89e6864" id="e8220cedc15796315efb7be2c60c4f981a89e6864">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-39-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8220cedc15796315efb7be2c60c4f981a89e6864">52+ messages in thread</a></pre><hr><pre><a href="#ebbc5a0892326a643bb95010e8b8a11dda2f843c2" id="mbbc5a0892326a643bb95010e8b8a11dda2f843c2">*</a> <b>[PATCH v2 39/53] refs/files-backend: convert many internals to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8220cedc15796315efb7be2c60c4f981a89e6864">(35 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8220cedc15796315efb7be2c60c4f981a89e6864">[PATCH v2 38/53] refs: convert struct ref_update to use struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mf83d6ab2107273110534406eb521db25eb0acd77">[PATCH v2 40/53] http-push: convert process_ls_object and descendants to object_id</a> brian m. carlson
                   ` <a href="#rf83d6ab2107273110534406eb521db25eb0acd77">(13 subsequent siblings)</a>
  <a href="#rbbc5a0892326a643bb95010e8b8a11dda2f843c2">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert many of the internals of the files backend to use struct
object_id.  Avoid converting public APIs (except one change to
refs/ref-cache.c) to limit the scope of the changes.

Convert one use of get_sha1_hex to parse_oid_hex, and rely on the fact
that a strbuf will be NUL-terminated and that parse_oid_hex will fail on
truncated input to avoid the need to check for an explicit length.

This is a requirement to convert parse_object later on.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 refs/files-backend.c | 125 ++++++++++++++++++++++++---------------------------
 refs/ref-cache.c     |   4 +-
 refs/ref-cache.h     |   2 +-
 3 files changed, 61 insertions(+), 70 deletions(-)

diff --git a/refs/files-backend.c b/refs/files-backend.c
index 413505ff0..12be6746b 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -195,27 +195,18 @@ static const char PACKED_REFS_HEADER[] =
  * Return a pointer to the refname within the line (null-terminated),
  * or NULL if there was a problem.
  */
-static const char *parse_ref_line(struct strbuf *line, unsigned char *sha1)
+static const char *parse_ref_line(struct strbuf *line, struct object_id *oid)
 {
 	const char *ref;
 
-	/*
-	 * 42: the answer to everything.
-	 *
-	 * In this case, it happens to be the answer to
-	 *  40 (length of sha1 hex representation)
-	 *  +1 (space in between hex and name)
-	 *  +1 (newline at the end of the line)
-	 */
-	if (line-&gt;len &lt;= 42)
+	if (!line-&gt;len)
 		return NULL;
 
-	if (get_sha1_hex(line-&gt;buf, sha1) &lt; 0)
+	if (parse_oid_hex(line-&gt;buf, oid, &amp;ref) &lt; 0)
 		return NULL;
-	if (!isspace(line-&gt;buf[40]))
+	if (!isspace(*ref++))
 		return NULL;
 
-	ref = line-&gt;buf + 41;
 	if (isspace(*ref))
 		return NULL;
 
@@ -260,7 +251,7 @@ static void read_packed_refs(FILE *f, struct ref_dir *dir)
 	enum { PEELED_NONE, PEELED_TAGS, PEELED_FULLY } peeled = PEELED_NONE;
 
 	while (strbuf_getwholeline(&amp;line, f, '\n') != EOF) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		const char *refname;
 		const char *traits;
 
@@ -273,17 +264,17 @@ static void read_packed_refs(FILE *f, struct ref_dir *dir)
 			continue;
 		}
 
-		refname = parse_ref_line(&amp;line, sha1);
+		refname = parse_ref_line(&amp;line, &amp;oid);
 		if (refname) {
 			int flag = REF_ISPACKED;
 
 			if (check_refname_format(refname, REFNAME_ALLOW_ONELEVEL)) {
 				if (!refname_is_safe(refname))
 					die("packed refname is dangerous: %s", refname);
-				hashclr(sha1);
+				oidclr(&amp;oid);
 				flag |= REF_BAD_NAME | REF_ISBROKEN;
 			}
-			last = create_ref_entry(refname, sha1, flag, 0);
+			last = create_ref_entry(refname, &amp;oid, flag, 0);
 			if (peeled == PEELED_FULLY ||
 			    (peeled == PEELED_TAGS &amp;&amp; starts_with(refname, "refs/tags/")))
 				last-&gt;flag |= REF_KNOWS_PEELED;
@@ -294,8 +285,8 @@ static void read_packed_refs(FILE *f, struct ref_dir *dir)
 		    line.buf[0] == '^' &amp;&amp;
 		    line.len == PEELED_LINE_LENGTH &amp;&amp;
 		    line.buf[PEELED_LINE_LENGTH - 1] == '\n' &amp;&amp;
-		    !get_sha1_hex(line.buf + 1, sha1)) {
-			hashcpy(last-&gt;u.value.peeled.hash, sha1);
+		    !get_oid_hex(line.buf + 1, &amp;oid)) {
+			oidcpy(&amp;last-&gt;u.value.peeled, &amp;oid);
 			/*
 			 * Regardless of what the file header said,
 			 * we definitely know the value of *this*
@@ -404,14 +395,14 @@ static struct ref_dir *get_packed_refs(struct files_ref_store *refs)
  * commit_packed_refs().
  */
 static void add_packed_ref(struct files_ref_store *refs,
-			   const char *refname, const unsigned char *sha1)
+			   const char *refname, const struct object_id *oid)
 {
 	struct packed_ref_cache *packed_ref_cache = get_packed_ref_cache(refs);
 
 	if (!packed_ref_cache-&gt;lock)
 		die("internal error: packed refs not locked");
 	add_ref_entry(get_packed_ref_dir(packed_ref_cache),
-		      create_ref_entry(refname, sha1, REF_ISPACKED, 1));
+		      create_ref_entry(refname, oid, REF_ISPACKED, 1));
 }
 
 /*
@@ -444,7 +435,7 @@ static void loose_fill_ref_dir(struct ref_store *ref_store,
 	strbuf_add(&amp;refname, dirname, dirnamelen);
 
 	while ((de = readdir(d)) != NULL) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		struct stat st;
 		int flag;
 
@@ -465,10 +456,10 @@ static void loose_fill_ref_dir(struct ref_store *ref_store,
 			if (!refs_resolve_ref_unsafe(&amp;refs-&gt;base,
 						     refname.buf,
 						     RESOLVE_REF_READING,
-						     sha1, &amp;flag)) {
-				hashclr(sha1);
+						     oid.hash, &amp;flag)) {
+				oidclr(&amp;oid);
 				flag |= REF_ISBROKEN;
-			} else if (is_null_sha1(sha1)) {
+			} else if (is_null_oid(&amp;oid)) {
 				/*
 				 * It is so astronomically unlikely
 				 * that NULL_SHA1 is the SHA-1 of an
@@ -484,11 +475,11 @@ static void loose_fill_ref_dir(struct ref_store *ref_store,
 						 REFNAME_ALLOW_ONELEVEL)) {
 				if (!refname_is_safe(refname.buf))
 					die("loose refname is dangerous: %s", refname.buf);
-				hashclr(sha1);
+				oidclr(&amp;oid);
 				flag |= REF_BAD_NAME | REF_ISBROKEN;
 			}
 			add_entry_to_dir(dir,
-					 create_ref_entry(refname.buf, sha1, flag, 0));
+					 create_ref_entry(refname.buf, &amp;oid, flag, 0));
 		}
 		strbuf_setlen(&amp;refname, dirnamelen);
 		strbuf_setlen(&amp;path, path_baselen);
@@ -1526,7 +1517,7 @@ static int files_pack_refs(struct ref_store *ref_store, unsigned int flags)
 			packed_entry-&gt;flag = REF_ISPACKED;
 			oidcpy(&amp;packed_entry-&gt;u.value.oid, iter-&gt;oid);
 		} else {
-			packed_entry = create_ref_entry(iter-&gt;refname, iter-&gt;oid-&gt;hash,
+			packed_entry = create_ref_entry(iter-&gt;refname, iter-&gt;oid,
 							REF_ISPACKED, 0);
 			add_ref_entry(packed_refs, packed_entry);
 		}
@@ -1709,10 +1700,10 @@ static int rename_tmp_log(struct files_ref_store *refs, const char *newrefname)
 }
 
 static int write_ref_to_lockfile(struct ref_lock *lock,
-				 const unsigned char *sha1, struct strbuf *err);
+				 const struct object_id *oid, struct strbuf *err);
 static int commit_ref_update(struct files_ref_store *refs,
 			     struct ref_lock *lock,
-			     const unsigned char *sha1, const char *logmsg,
+			     const struct object_id *oid, const char *logmsg,
 			     struct strbuf *err);
 
 static int files_rename_ref(struct ref_store *ref_store,
@@ -1721,7 +1712,7 @@ static int files_rename_ref(struct ref_store *ref_store,
 {
 	struct files_ref_store *refs =
 		files_downcast(ref_store, REF_STORE_WRITE, "rename_ref");
-	unsigned char sha1[20], orig_sha1[20];
+	struct object_id oid, orig_oid;
 	int flag = 0, logmoved = 0;
 	struct ref_lock *lock;
 	struct stat loginfo;
@@ -1743,7 +1734,7 @@ static int files_rename_ref(struct ref_store *ref_store,
 
 	if (!refs_resolve_ref_unsafe(&amp;refs-&gt;base, oldrefname,
 				     RESOLVE_REF_READING | RESOLVE_REF_NO_RECURSE,
-				orig_sha1, &amp;flag)) {
+				orig_oid.hash, &amp;flag)) {
 		ret = error("refname %s not found", oldrefname);
 		goto out;
 	}
@@ -1765,21 +1756,21 @@ static int files_rename_ref(struct ref_store *ref_store,
 	}
 
 	if (refs_delete_ref(&amp;refs-&gt;base, logmsg, oldrefname,
-			    orig_sha1, REF_NODEREF)) {
+			    orig_oid.hash, REF_NODEREF)) {
 		error("unable to delete old %s", oldrefname);
 		goto rollback;
 	}
 
 	/*
-	 * Since we are doing a shallow lookup, sha1 is not the
-	 * correct value to pass to delete_ref as old_sha1. But that
-	 * doesn't matter, because an old_sha1 check wouldn't add to
+	 * Since we are doing a shallow lookup, oid is not the
+	 * correct value to pass to delete_ref as old_oid. But that
+	 * doesn't matter, because an old_oid check wouldn't add to
 	 * the safety anyway; we want to delete the reference whatever
 	 * its current value.
 	 */
 	if (!refs_read_ref_full(&amp;refs-&gt;base, newrefname,
 				RESOLVE_REF_READING | RESOLVE_REF_NO_RECURSE,
-				sha1, NULL) &amp;&amp;
+				oid.hash, NULL) &amp;&amp;
 	    refs_delete_ref(&amp;refs-&gt;base, NULL, newrefname,
 			    NULL, REF_NODEREF)) {
 		if (errno == EISDIR) {
@@ -1812,10 +1803,10 @@ static int files_rename_ref(struct ref_store *ref_store,
 		strbuf_release(&amp;err);
 		goto rollback;
 	}
-	hashcpy(lock-&gt;old_oid.hash, orig_sha1);
+	oidcpy(&amp;lock-&gt;old_oid, &amp;orig_oid);
 
-	if (write_ref_to_lockfile(lock, orig_sha1, &amp;err) ||
-	    commit_ref_update(refs, lock, orig_sha1, logmsg, &amp;err)) {
+	if (write_ref_to_lockfile(lock, &amp;orig_oid, &amp;err) ||
+	    commit_ref_update(refs, lock, &amp;orig_oid, logmsg, &amp;err)) {
 		error("unable to write current sha1 into %s: %s", newrefname, err.buf);
 		strbuf_release(&amp;err);
 		goto rollback;
@@ -1835,8 +1826,8 @@ static int files_rename_ref(struct ref_store *ref_store,
 
 	flag = log_all_ref_updates;
 	log_all_ref_updates = LOG_REFS_NONE;
-	if (write_ref_to_lockfile(lock, orig_sha1, &amp;err) ||
-	    commit_ref_update(refs, lock, orig_sha1, NULL, &amp;err)) {
+	if (write_ref_to_lockfile(lock, &amp;orig_oid, &amp;err) ||
+	    commit_ref_update(refs, lock, &amp;orig_oid, NULL, &amp;err)) {
 		error("unable to write current sha1 into %s: %s", oldrefname, err.buf);
 		strbuf_release(&amp;err);
 	}
@@ -1986,8 +1977,8 @@ static int files_create_reflog(struct ref_store *ref_store,
 	return 0;
 }
 
-static int log_ref_write_fd(int fd, const unsigned char *old_sha1,
-			    const unsigned char *new_sha1,
+static int log_ref_write_fd(int fd, const struct object_id *old_oid,
+			    const struct object_id *new_oid,
 			    const char *committer, const char *msg)
 {
 	int msglen, written;
@@ -1998,8 +1989,8 @@ static int log_ref_write_fd(int fd, const unsigned char *old_sha1,
 	maxlen = strlen(committer) + msglen + 100;
 	logrec = xmalloc(maxlen);
 	len = xsnprintf(logrec, maxlen, "%s %s %s\n",
-			sha1_to_hex(old_sha1),
-			sha1_to_hex(new_sha1),
+			oid_to_hex(old_oid),
+			oid_to_hex(new_oid),
 			committer);
 	if (msglen)
 		len += copy_reflog_msg(logrec + len - 1, msg) - 1;
@@ -2013,8 +2004,8 @@ static int log_ref_write_fd(int fd, const unsigned char *old_sha1,
 }
 
 static int files_log_ref_write(struct files_ref_store *refs,
-			       const char *refname, const unsigned char *old_sha1,
-			       const unsigned char *new_sha1, const char *msg,
+			       const char *refname, const struct object_id *old_oid,
+			       const struct object_id *new_oid, const char *msg,
 			       int flags, struct strbuf *err)
 {
 	int logfd, result;
@@ -2031,7 +2022,7 @@ static int files_log_ref_write(struct files_ref_store *refs,
 
 	if (logfd &lt; 0)
 		return 0;
-	result = log_ref_write_fd(logfd, old_sha1, new_sha1,
+	result = log_ref_write_fd(logfd, old_oid, new_oid,
 				  git_committer_info(0), msg);
 	if (result) {
 		struct strbuf sb = STRBUF_INIT;
@@ -2063,29 +2054,29 @@ static int files_log_ref_write(struct files_ref_store *refs,
  * return -1.
  */
 static int write_ref_to_lockfile(struct ref_lock *lock,
-				 const unsigned char *sha1, struct strbuf *err)
+				 const struct object_id *oid, struct strbuf *err)
 {
 	static char term = '\n';
 	struct object *o;
 	int fd;
 
-	o = parse_object(sha1);
+	o = parse_object(oid-&gt;hash);
 	if (!o) {
 		strbuf_addf(err,
 			    "trying to write ref '%s' with nonexistent object %s",
-			    lock-&gt;ref_name, sha1_to_hex(sha1));
+			    lock-&gt;ref_name, oid_to_hex(oid));
 		unlock_ref(lock);
 		return -1;
 	}
 	if (o-&gt;type != OBJ_COMMIT &amp;&amp; is_branch(lock-&gt;ref_name)) {
 		strbuf_addf(err,
 			    "trying to write non-commit object %s to branch '%s'",
-			    sha1_to_hex(sha1), lock-&gt;ref_name);
+			    oid_to_hex(oid), lock-&gt;ref_name);
 		unlock_ref(lock);
 		return -1;
 	}
 	fd = get_lock_file_fd(lock-&gt;lk);
-	if (write_in_full(fd, sha1_to_hex(sha1), 40) != 40 ||
+	if (write_in_full(fd, oid_to_hex(oid), GIT_SHA1_HEXSZ) != GIT_SHA1_HEXSZ ||
 	    write_in_full(fd, &amp;term, 1) != 1 ||
 	    close_ref(lock) &lt; 0) {
 		strbuf_addf(err,
@@ -2103,14 +2094,14 @@ static int write_ref_to_lockfile(struct ref_lock *lock,
  */
 static int commit_ref_update(struct files_ref_store *refs,
 			     struct ref_lock *lock,
-			     const unsigned char *sha1, const char *logmsg,
+			     const struct object_id *oid, const char *logmsg,
 			     struct strbuf *err)
 {
 	files_assert_main_repository(refs, "commit_ref_update");
 
 	clear_loose_ref_cache(refs);
 	if (files_log_ref_write(refs, lock-&gt;ref_name,
-				lock-&gt;old_oid.hash, sha1,
+				&amp;lock-&gt;old_oid, oid,
 				logmsg, 0, err)) {
 		char *old_msg = strbuf_detach(err, NULL);
 		strbuf_addf(err, "cannot update the ref '%s': %s",
@@ -2133,18 +2124,18 @@ static int commit_ref_update(struct files_ref_store *refs,
 		 * check with HEAD only which should cover 99% of all usage
 		 * scenarios (even 100% of the default ones).
 		 */
-		unsigned char head_sha1[20];
+		struct object_id head_oid;
 		int head_flag;
 		const char *head_ref;
 
 		head_ref = refs_resolve_ref_unsafe(&amp;refs-&gt;base, "HEAD",
 						   RESOLVE_REF_READING,
-						   head_sha1, &amp;head_flag);
+						   head_oid.hash, &amp;head_flag);
 		if (head_ref &amp;&amp; (head_flag &amp; REF_ISSYMREF) &amp;&amp;
 		    !strcmp(head_ref, lock-&gt;ref_name)) {
 			struct strbuf log_err = STRBUF_INIT;
 			if (files_log_ref_write(refs, "HEAD",
-						lock-&gt;old_oid.hash, sha1,
+						&amp;lock-&gt;old_oid, oid,
 						logmsg, 0, &amp;log_err)) {
 				error("%s", log_err.buf);
 				strbuf_release(&amp;log_err);
@@ -2182,12 +2173,12 @@ static void update_symref_reflog(struct files_ref_store *refs,
 				 const char *target, const char *logmsg)
 {
 	struct strbuf err = STRBUF_INIT;
-	unsigned char new_sha1[20];
+	struct object_id new_oid;
 	if (logmsg &amp;&amp;
 	    !refs_read_ref_full(&amp;refs-&gt;base, target,
-				RESOLVE_REF_READING, new_sha1, NULL) &amp;&amp;
-	    files_log_ref_write(refs, refname, lock-&gt;old_oid.hash,
-				new_sha1, logmsg, 0, &amp;err)) {
+				RESOLVE_REF_READING, new_oid.hash, NULL) &amp;&amp;
+	    files_log_ref_write(refs, refname, &amp;lock-&gt;old_oid,
+				&amp;new_oid, logmsg, 0, &amp;err)) {
 		error("%s", err.buf);
 		strbuf_release(&amp;err);
 	}
@@ -2866,7 +2857,7 @@ static int lock_ref_for_update(struct files_ref_store *refs,
 			 * The reference already has the desired
 			 * value, so we don't need to write it.
 			 */
-		} else if (write_ref_to_lockfile(lock, update-&gt;new_oid.hash,
+		} else if (write_ref_to_lockfile(lock, &amp;update-&gt;new_oid,
 						 err)) {
 			char *write_err = strbuf_detach(err, NULL);
 
@@ -3001,8 +2992,8 @@ static int files_transaction_commit(struct ref_store *ref_store,
 		    update-&gt;flags &amp; REF_LOG_ONLY) {
 			if (files_log_ref_write(refs,
 						lock-&gt;ref_name,
-						lock-&gt;old_oid.hash,
-						update-&gt;new_oid.hash,
+						&amp;lock-&gt;old_oid,
+						&amp;update-&gt;new_oid,
 						update-&gt;msg, update-&gt;flags,
 						err)) {
 				char *old_msg = strbuf_detach(err, NULL);
@@ -3174,7 +3165,7 @@ static int files_initial_transaction_commit(struct ref_store *ref_store,
 		if ((update-&gt;flags &amp; REF_HAVE_NEW) &amp;&amp;
 		    !is_null_oid(&amp;update-&gt;new_oid))
 			add_packed_ref(refs, update-&gt;refname,
-				       update-&gt;new_oid.hash);
+				       &amp;update-&gt;new_oid);
 	}
 
 	if (commit_packed_refs(refs)) {
diff --git a/refs/ref-cache.c b/refs/ref-cache.c
index 6059362f1..6b11d9cd1 100644
--- a/refs/ref-cache.c
+++ b/refs/ref-cache.c
@@ -32,7 +32,7 @@ struct ref_dir *get_ref_dir(struct ref_entry *entry)
 }
 
 struct ref_entry *create_ref_entry(const char *refname,
-				   const unsigned char *sha1, int flag,
+				   const struct object_id *oid, int flag,
 				   int check_name)
 {
 	struct ref_entry *ref;
@@ -41,7 +41,7 @@ struct ref_entry *create_ref_entry(const char *refname,
 	    check_refname_format(refname, REFNAME_ALLOW_ONELEVEL))
 		die("Reference has invalid format: '%s'", refname);
 	FLEX_ALLOC_STR(ref, name, refname);
-	hashcpy(ref-&gt;u.value.oid.hash, sha1);
+	oidcpy(&amp;ref-&gt;u.value.oid, oid);
 	oidclr(&amp;ref-&gt;u.value.peeled);
 	ref-&gt;flag = flag;
 	return ref;
diff --git a/refs/ref-cache.h b/refs/ref-cache.h
index ffdc54f3f..1f65e2f9e 100644
--- a/refs/ref-cache.h
+++ b/refs/ref-cache.h
@@ -185,7 +185,7 @@ struct ref_entry *create_dir_entry(struct ref_cache *cache,
 				   int incomplete);
 
 struct ref_entry *create_ref_entry(const char *refname,
-				   const unsigned char *sha1, int flag,
+				   const struct object_id *oid, int flag,
 				   int check_name);
 
 /*

<a href="#mbbc5a0892326a643bb95010e8b8a11dda2f843c2" id="ebbc5a0892326a643bb95010e8b8a11dda2f843c2">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-40-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rbbc5a0892326a643bb95010e8b8a11dda2f843c2">52+ messages in thread</a></pre><hr><pre><a href="#ef83d6ab2107273110534406eb521db25eb0acd77" id="mf83d6ab2107273110534406eb521db25eb0acd77">*</a> <b>[PATCH v2 40/53] http-push: convert process_ls_object and descendants to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rbbc5a0892326a643bb95010e8b8a11dda2f843c2">(36 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mbbc5a0892326a643bb95010e8b8a11dda2f843c2">[PATCH v2 39/53] refs/files-backend: convert many internals to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mb570f4354485c39e3a0e560626571a95a25a990d">[PATCH v2 41/53] revision: rename add_pending_sha1 to add_pending_oid</a> brian m. carlson
                   ` <a href="#rb570f4354485c39e3a0e560626571a95a25a990d">(12 subsequent siblings)</a>
  <a href="#rf83d6ab2107273110534406eb521db25eb0acd77">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Rename one function to reflect that it now uses struct object_id.  This
conversion is a prerequisite for converting parse_object.

Note that while the use of a buffer that is exactly forty bytes long
looks questionable, get_oid_hex reads exactly the right number of bytes
and does not require the data to be NUL-terminated.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 http-push.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/http-push.c b/http-push.c
index 7781f4078..4e7bd9e42 100644
--- a/http-push.c
+++ b/http-push.c
@@ -718,13 +718,13 @@ static int fetch_indices(void)
 	return ret;
 }
 
-static void one_remote_object(const unsigned char *sha1)
+static void one_remote_object(const struct object_id *oid)
 {
 	struct object *obj;
 
-	obj = lookup_object(sha1);
+	obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		obj = parse_object(sha1);
+		obj = parse_object(oid-&gt;hash);
 
 	/* Ignore remote objects that don't exist locally */
 	if (!obj)
@@ -1013,26 +1013,26 @@ static void remote_ls(const char *path, int flags,
 		      void *userData);
 
 /* extract hex from sharded "xx/x{40}" filename */
-static int get_sha1_hex_from_objpath(const char *path, unsigned char *sha1)
+static int get_oid_hex_from_objpath(const char *path, struct object_id *oid)
 {
-	char hex[40];
+	char hex[GIT_MAX_HEXSZ];
 
-	if (strlen(path) != 41)
+	if (strlen(path) != GIT_SHA1_HEXSZ + 1)
 		return -1;
 
 	memcpy(hex, path, 2);
 	path += 2;
 	path++; /* skip '/' */
-	memcpy(hex, path, 38);
+	memcpy(hex, path, GIT_SHA1_HEXSZ - 2);
 
-	return get_sha1_hex(hex, sha1);
+	return get_oid_hex(hex, oid);
 }
 
 static void process_ls_object(struct remote_ls_ctx *ls)
 {
 	unsigned int *parent = (unsigned int *)ls-&gt;userData;
 	const char *path = ls-&gt;dentry_name;
-	unsigned char sha1[20];
+	struct object_id oid;
 
 	if (!strcmp(ls-&gt;path, ls-&gt;dentry_name) &amp;&amp; (ls-&gt;flags &amp; IS_DIR)) {
 		remote_dir_exists[*parent] = 1;
@@ -1040,10 +1040,10 @@ static void process_ls_object(struct remote_ls_ctx *ls)
 	}
 
 	if (!skip_prefix(path, "objects/", &amp;path) ||
-	    get_sha1_hex_from_objpath(path, sha1))
+	    get_oid_hex_from_objpath(path, &amp;oid))
 		return;
 
-	one_remote_object(sha1);
+	one_remote_object(&amp;oid);
 }
 
 static void process_ls_ref(struct remote_ls_ctx *ls)

<a href="#mf83d6ab2107273110534406eb521db25eb0acd77" id="ef83d6ab2107273110534406eb521db25eb0acd77">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-41-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rf83d6ab2107273110534406eb521db25eb0acd77">52+ messages in thread</a></pre><hr><pre><a href="#eb570f4354485c39e3a0e560626571a95a25a990d" id="mb570f4354485c39e3a0e560626571a95a25a990d">*</a> <b>[PATCH v2 41/53] revision: rename add_pending_sha1 to add_pending_oid</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rf83d6ab2107273110534406eb521db25eb0acd77">(37 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mf83d6ab2107273110534406eb521db25eb0acd77">[PATCH v2 40/53] http-push: convert process_ls_object and descendants to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mc41d3211081d0964c919f84e4c00eb4de1a7f6df">[PATCH v2 42/53] revision: convert remaining parse_object callers to object_id</a> brian m. carlson
                   ` <a href="#rc41d3211081d0964c919f84e4c00eb4de1a7f6df">(11 subsequent siblings)</a>
  <a href="#rb570f4354485c39e3a0e560626571a95a25a990d">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Rename this function and convert it to take a pointer to struct
object_id.

This is a prerequisite for converting get_reference, which is needed to
convert parse_object.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/am.c       | 2 +-
 builtin/checkout.c | 4 ++--
 revision.c         | 8 ++++----
 revision.h         | 6 +++---
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/builtin/am.c b/builtin/am.c
index 7663f12e6..642d7047d 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -1618,7 +1618,7 @@ static int fall_back_threeway(const struct am_state *state, const char *index_pa
 		init_revisions(&amp;rev_info, NULL);
 		rev_info.diffopt.output_format = DIFF_FORMAT_NAME_STATUS;
 		diff_opt_parse(&amp;rev_info.diffopt, &amp;diff_filter_str, 1, rev_info.prefix);
-		add_pending_sha1(&amp;rev_info, "HEAD", our_tree.hash, 0);
+		add_pending_oid(&amp;rev_info, "HEAD", &amp;our_tree, 0);
 		diff_setup_done(&amp;rev_info.diffopt);
 		run_diff_index(&amp;rev_info, 1);
 	}
diff --git a/builtin/checkout.c b/builtin/checkout.c
index afa99fb8a..7f1eeea94 100644
--- a/builtin/checkout.c
+++ b/builtin/checkout.c
@@ -721,7 +721,7 @@ static int add_pending_uninteresting_ref(const char *refname,
 					 const struct object_id *oid,
 					 int flags, void *cb_data)
 {
-	add_pending_sha1(cb_data, refname, oid-&gt;hash, UNINTERESTING);
+	add_pending_oid(cb_data, refname, oid, UNINTERESTING);
 	return 0;
 }
 
@@ -807,7 +807,7 @@ static void orphaned_commit_warning(struct commit *old, struct commit *new)
 	add_pending_object(&amp;revs, object, oid_to_hex(&amp;object-&gt;oid));
 
 	for_each_ref(add_pending_uninteresting_ref, &amp;revs);
-	add_pending_sha1(&amp;revs, "HEAD", new-&gt;object.oid.hash, UNINTERESTING);
+	add_pending_oid(&amp;revs, "HEAD", &amp;new-&gt;object.oid, UNINTERESTING);
 
 	refs = revs.pending;
 	revs.leak_pending = 1;
diff --git a/revision.c b/revision.c
index c2091b6de..f82c56e1f 100644
--- a/revision.c
+++ b/revision.c
@@ -203,10 +203,10 @@ static struct object *get_reference(struct rev_info *revs, const char *name,
 	return object;
 }
 
-void add_pending_sha1(struct rev_info *revs, const char *name,
-		      const unsigned char *sha1, unsigned int flags)
+void add_pending_oid(struct rev_info *revs, const char *name,
+		      const struct object_id *oid, unsigned int flags)
 {
-	struct object *object = get_reference(revs, name, sha1, flags);
+	struct object *object = get_reference(revs, name, oid-&gt;hash, flags);
 	add_pending_object(revs, object, name);
 }
 
@@ -1159,7 +1159,7 @@ static int handle_one_ref(const char *path, const struct object_id *oid,
 
 	object = get_reference(cb-&gt;all_revs, path, oid-&gt;hash, cb-&gt;all_flags);
 	add_rev_cmdline(cb-&gt;all_revs, object, path, REV_CMD_REF, cb-&gt;all_flags);
-	add_pending_sha1(cb-&gt;all_revs, path, oid-&gt;hash, cb-&gt;all_flags);
+	add_pending_oid(cb-&gt;all_revs, path, oid, cb-&gt;all_flags);
 	return 0;
 }
 
diff --git a/revision.h b/revision.h
index 14886ec92..728425a02 100644
--- a/revision.h
+++ b/revision.h
@@ -263,9 +263,9 @@ extern void show_object_with_name(FILE *, struct object *, const char *);
 
 extern void add_pending_object(struct rev_info *revs,
 			       struct object *obj, const char *name);
-extern void add_pending_sha1(struct rev_info *revs,
-			     const char *name, const unsigned char *sha1,
-			     unsigned int flags);
+extern void add_pending_oid(struct rev_info *revs,
+			    const char *name, const struct object_id *oid,
+			    unsigned int flags);
 
 extern void add_head_to_pending(struct rev_info *);
 extern void add_reflogs_to_pending(struct rev_info *, unsigned int flags);

<a href="#mb570f4354485c39e3a0e560626571a95a25a990d" id="eb570f4354485c39e3a0e560626571a95a25a990d">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-42-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rb570f4354485c39e3a0e560626571a95a25a990d">52+ messages in thread</a></pre><hr><pre><a href="#ec41d3211081d0964c919f84e4c00eb4de1a7f6df" id="mc41d3211081d0964c919f84e4c00eb4de1a7f6df">*</a> <u id="u"><b>[PATCH v2 42/53] revision: convert remaining parse_object callers to object_id</b></u>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rb570f4354485c39e3a0e560626571a95a25a990d">(38 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mb570f4354485c39e3a0e560626571a95a25a990d">[PATCH v2 41/53] revision: rename add_pending_sha1 to add_pending_oid</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mfd9765dc878f10a7eeba0bf1f73efa2196eba891">[PATCH v2 43/53] upload-pack: convert remaining parse_object callers to object_id</a> brian m. carlson
                   ` <a href="#rfd9765dc878f10a7eeba0bf1f73efa2196eba891">(10 subsequent siblings)</a>
  <a href="#rc41d3211081d0964c919f84e4c00eb4de1a7f6df">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 revision.c | 44 ++++++++++++++++++++++----------------------
 1 file changed, 22 insertions(+), 22 deletions(-)

diff --git a/revision.c b/revision.c
index f82c56e1f..80f74bb7b 100644
--- a/revision.c
+++ b/revision.c
@@ -177,23 +177,23 @@ void add_pending_object(struct rev_info *revs,
 
 void add_head_to_pending(struct rev_info *revs)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct object *obj;
-	if (get_sha1("HEAD", sha1))
+	if (get_oid("HEAD", &amp;oid))
 		return;
-	obj = parse_object(sha1);
+	obj = parse_object(oid.hash);
 	if (!obj)
 		return;
 	add_pending_object(revs, obj, "HEAD");
 }
 
 static struct object *get_reference(struct rev_info *revs, const char *name,
-				    const unsigned char *sha1,
+				    const struct object_id *oid,
 				    unsigned int flags)
 {
 	struct object *object;
 
-	object = parse_object(sha1);
+	object = parse_object(oid-&gt;hash);
 	if (!object) {
 		if (revs-&gt;ignore_missing)
 			return object;
@@ -206,7 +206,7 @@ static struct object *get_reference(struct rev_info *revs, const char *name,
 void add_pending_oid(struct rev_info *revs, const char *name,
 		      const struct object_id *oid, unsigned int flags)
 {
-	struct object *object = get_reference(revs, name, oid-&gt;hash, flags);
+	struct object *object = get_reference(revs, name, oid, flags);
 	add_pending_object(revs, object, name);
 }
 
@@ -1157,7 +1157,7 @@ static int handle_one_ref(const char *path, const struct object_id *oid,
 	if (ref_excluded(cb-&gt;all_revs-&gt;ref_excludes, path))
 	    return 0;
 
-	object = get_reference(cb-&gt;all_revs, path, oid-&gt;hash, cb-&gt;all_flags);
+	object = get_reference(cb-&gt;all_revs, path, oid, cb-&gt;all_flags);
 	add_rev_cmdline(cb-&gt;all_revs, object, path, REV_CMD_REF, cb-&gt;all_flags);
 	add_pending_oid(cb-&gt;all_revs, path, oid, cb-&gt;all_flags);
 	return 0;
@@ -1292,7 +1292,7 @@ void add_index_objects_to_pending(struct rev_info *revs, unsigned flags)
 static int add_parents_only(struct rev_info *revs, const char *arg_, int flags,
 			    int exclude_parent)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct object *it;
 	struct commit *commit;
 	struct commit_list *parents;
@@ -1303,17 +1303,17 @@ static int add_parents_only(struct rev_info *revs, const char *arg_, int flags,
 		flags ^= UNINTERESTING | BOTTOM;
 		arg++;
 	}
-	if (get_sha1_committish(arg, sha1))
+	if (get_sha1_committish(arg, oid.hash))
 		return 0;
 	while (1) {
-		it = get_reference(revs, arg, sha1, 0);
+		it = get_reference(revs, arg, &amp;oid, 0);
 		if (!it &amp;&amp; revs-&gt;ignore_missing)
 			return 0;
 		if (it-&gt;type != OBJ_TAG)
 			break;
 		if (!((struct tag*)it)-&gt;tagged)
 			return 0;
-		hashcpy(sha1, ((struct tag*)it)-&gt;tagged-&gt;oid.hash);
+		oidcpy(&amp;oid, &amp;((struct tag*)it)-&gt;tagged-&gt;oid);
 	}
 	if (it-&gt;type != OBJ_COMMIT)
 		return 0;
@@ -1434,7 +1434,7 @@ int handle_revision_arg(const char *arg_, struct rev_info *revs, int flags, unsi
 	struct object_context oc;
 	char *dotdot;
 	struct object *object;
-	unsigned char sha1[20];
+	struct object_id oid;
 	int local_flags;
 	const char *arg = arg_;
 	int cant_be_filename = revarg_opt &amp; REVARG_CANNOT_BE_FILENAME;
@@ -1444,7 +1444,7 @@ int handle_revision_arg(const char *arg_, struct rev_info *revs, int flags, unsi
 
 	dotdot = strstr(arg, "..");
 	if (dotdot) {
-		unsigned char from_sha1[20];
+		struct object_id from_oid;
 		const char *next = dotdot + 2;
 		const char *this = arg;
 		int symmetric = *next == '.';
@@ -1470,8 +1470,8 @@ int handle_revision_arg(const char *arg_, struct rev_info *revs, int flags, unsi
 				return -1;
 			}
 		}
-		if (!get_sha1_committish(this, from_sha1) &amp;&amp;
-		    !get_sha1_committish(next, sha1)) {
+		if (!get_sha1_committish(this, from_oid.hash) &amp;&amp;
+		    !get_sha1_committish(next, oid.hash)) {
 			struct object *a_obj, *b_obj;
 
 			if (!cant_be_filename) {
@@ -1479,8 +1479,8 @@ int handle_revision_arg(const char *arg_, struct rev_info *revs, int flags, unsi
 				verify_non_filename(revs-&gt;prefix, arg);
 			}
 
-			a_obj = parse_object(from_sha1);
-			b_obj = parse_object(sha1);
+			a_obj = parse_object(from_oid.hash);
+			b_obj = parse_object(oid.hash);
 			if (!a_obj || !b_obj) {
 			missing:
 				if (revs-&gt;ignore_missing)
@@ -1568,11 +1568,11 @@ int handle_revision_arg(const char *arg_, struct rev_info *revs, int flags, unsi
 	if (revarg_opt &amp; REVARG_COMMITTISH)
 		get_sha1_flags = GET_SHA1_COMMITTISH;
 
-	if (get_sha1_with_context(arg, get_sha1_flags, sha1, &amp;oc))
+	if (get_sha1_with_context(arg, get_sha1_flags, oid.hash, &amp;oc))
 		return revs-&gt;ignore_missing ? 0 : -1;
 	if (!cant_be_filename)
 		verify_non_filename(revs-&gt;prefix, arg);
-	object = get_reference(revs, arg, sha1, flags ^ local_flags);
+	object = get_reference(revs, arg, &amp;oid, flags ^ local_flags);
 	add_rev_cmdline(revs, object, arg_, REV_CMD_REV, flags ^ local_flags);
 	add_pending_object_with_mode(revs, object, arg, oc.mode);
 	return 0;
@@ -2287,12 +2287,12 @@ int setup_revisions(int argc, const char **argv, struct rev_info *revs, struct s
 	if (revs-&gt;show_merge)
 		prepare_show_merge(revs);
 	if (revs-&gt;def &amp;&amp; !revs-&gt;pending.nr &amp;&amp; !got_rev_arg) {
-		unsigned char sha1[20];
+		struct object_id oid;
 		struct object *object;
 		struct object_context oc;
-		if (get_sha1_with_context(revs-&gt;def, 0, sha1, &amp;oc))
+		if (get_sha1_with_context(revs-&gt;def, 0, oid.hash, &amp;oc))
 			diagnose_missing_default(revs-&gt;def);
-		object = get_reference(revs, revs-&gt;def, sha1, 0);
+		object = get_reference(revs, revs-&gt;def, &amp;oid, 0);
 		add_pending_object_with_mode(revs, object, revs-&gt;def, oc.mode);
 	}
 

<a href="#mc41d3211081d0964c919f84e4c00eb4de1a7f6df" id="ec41d3211081d0964c919f84e4c00eb4de1a7f6df">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rc41d3211081d0964c919f84e4c00eb4de1a7f6df">52+ messages in thread</a></pre><hr><pre><a href="#efd9765dc878f10a7eeba0bf1f73efa2196eba891" id="mfd9765dc878f10a7eeba0bf1f73efa2196eba891">*</a> <b>[PATCH v2 43/53] upload-pack: convert remaining parse_object callers to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rc41d3211081d0964c919f84e4c00eb4de1a7f6df">(39 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mc41d3211081d0964c919f84e4c00eb4de1a7f6df">[PATCH v2 42/53] revision: convert remaining parse_object callers to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8f380b1897acf9bc1c19d0649c73dde9577ecde7">[PATCH v2 44/53] sha1_name: convert internals of peel_onion to object_id</a> brian m. carlson
                   ` <a href="#r8f380b1897acf9bc1c19d0649c73dde9577ecde7">(9 subsequent siblings)</a>
  <a href="#rfd9765dc878f10a7eeba0bf1f73efa2196eba891">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert the remaining parse_object callers to struct object_id.  Use
named constants for several hard-coded values.  In addition, rename
got_sha1 to got_oid to reflect the new argument.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 upload-pack.c | 50 +++++++++++++++++++++++++-------------------------
 1 file changed, 25 insertions(+), 25 deletions(-)

diff --git a/upload-pack.c b/upload-pack.c
index 20f87cd38..5b9d21089 100644
--- a/upload-pack.c
+++ b/upload-pack.c
@@ -286,19 +286,19 @@ static void create_pack_file(void)
 	die("git upload-pack: %s", abort_msg);
 }
 
-static int got_sha1(const char *hex, unsigned char *sha1)
+static int got_oid(const char *hex, struct object_id *oid)
 {
 	struct object *o;
 	int we_knew_they_have = 0;
 
-	if (get_sha1_hex(hex, sha1))
+	if (get_oid_hex(hex, oid))
 		die("git upload-pack: expected SHA1 object, got '%s'", hex);
-	if (!has_sha1_file(sha1))
+	if (!has_object_file(oid))
 		return -1;
 
-	o = parse_object(sha1);
+	o = parse_object(oid-&gt;hash);
 	if (!o)
-		die("oops (%s)", sha1_to_hex(sha1));
+		die("oops (%s)", oid_to_hex(oid));
 	if (o-&gt;type == OBJ_COMMIT) {
 		struct commit_list *parents;
 		struct commit *commit = (struct commit *)o;
@@ -382,8 +382,8 @@ static int ok_to_give_up(void)
 
 static int get_common_commits(void)
 {
-	unsigned char sha1[20];
-	char last_hex[41];
+	struct object_id oid;
+	char last_hex[GIT_MAX_HEXSZ + 1];
 	int got_common = 0;
 	int got_other = 0;
 	int sent_ready = 0;
@@ -416,11 +416,11 @@ static int get_common_commits(void)
 			continue;
 		}
 		if (skip_prefix(line, "have ", &amp;arg)) {
-			switch (got_sha1(arg, sha1)) {
+			switch (got_oid(arg, &amp;oid)) {
 			case -1: /* they have what we do not */
 				got_other = 1;
 				if (multi_ack &amp;&amp; ok_to_give_up()) {
-					const char *hex = sha1_to_hex(sha1);
+					const char *hex = oid_to_hex(&amp;oid);
 					if (multi_ack == 2) {
 						sent_ready = 1;
 						packet_write_fmt(1, "ACK %s ready\n", hex);
@@ -430,7 +430,7 @@ static int get_common_commits(void)
 				break;
 			default:
 				got_common = 1;
-				memcpy(last_hex, sha1_to_hex(sha1), 41);
+				memcpy(last_hex, oid_to_hex(&amp;oid), 41);
 				if (multi_ack == 2)
 					packet_write_fmt(1, "ACK %s common\n", last_hex);
 				else if (multi_ack)
@@ -492,7 +492,7 @@ static int do_reachable_revlist(struct child_process *cmd,
 		goto error;
 
 	namebuf[0] = '^';
-	namebuf[41] = '\n';
+	namebuf[GIT_SHA1_HEXSZ + 1] = '\n';
 	for (i = get_max_object_index(); 0 &lt; i; ) {
 		o = get_indexed_object(--i);
 		if (!o)
@@ -502,10 +502,10 @@ static int do_reachable_revlist(struct child_process *cmd,
 		if (!is_our_ref(o))
 			continue;
 		memcpy(namebuf + 1, oid_to_hex(&amp;o-&gt;oid), GIT_SHA1_HEXSZ);
-		if (write_in_full(cmd-&gt;in, namebuf, 42) &lt; 0)
+		if (write_in_full(cmd-&gt;in, namebuf, GIT_SHA1_HEXSZ + 2) &lt; 0)
 			goto error;
 	}
-	namebuf[40] = '\n';
+	namebuf[GIT_SHA1_HEXSZ] = '\n';
 	for (i = 0; i &lt; src-&gt;nr; i++) {
 		o = src-&gt;objects[i].item;
 		if (is_our_ref(o)) {
@@ -516,7 +516,7 @@ static int do_reachable_revlist(struct child_process *cmd,
 		if (reachable &amp;&amp; o-&gt;type == OBJ_COMMIT)
 			o-&gt;flags |= TMP_MARK;
 		memcpy(namebuf, oid_to_hex(&amp;o-&gt;oid), GIT_SHA1_HEXSZ);
-		if (write_in_full(cmd-&gt;in, namebuf, 41) &lt; 0)
+		if (write_in_full(cmd-&gt;in, namebuf, GIT_SHA1_HEXSZ + 1) &lt; 0)
 			goto error;
 	}
 	close(cmd-&gt;in);
@@ -742,7 +742,7 @@ static void receive_needs(void)
 	for (;;) {
 		struct object *o;
 		const char *features;
-		unsigned char sha1_buf[20];
+		struct object_id oid_buf;
 		char *line = packet_read_line(0, NULL);
 		const char *arg;
 
@@ -751,15 +751,15 @@ static void receive_needs(void)
 			break;
 
 		if (skip_prefix(line, "shallow ", &amp;arg)) {
-			unsigned char sha1[20];
+			struct object_id oid;
 			struct object *object;
-			if (get_sha1_hex(arg, sha1))
+			if (get_oid_hex(arg, &amp;oid))
 				die("invalid shallow line: %s", line);
-			object = parse_object(sha1);
+			object = parse_object(oid.hash);
 			if (!object)
 				continue;
 			if (object-&gt;type != OBJ_COMMIT)
-				die("invalid shallow object %s", sha1_to_hex(sha1));
+				die("invalid shallow object %s", oid_to_hex(&amp;oid));
 			if (!(object-&gt;flags &amp; CLIENT_SHALLOW)) {
 				object-&gt;flags |= CLIENT_SHALLOW;
 				add_object_array(object, NULL, &amp;shallows);
@@ -785,8 +785,8 @@ static void receive_needs(void)
 		}
 		if (skip_prefix(line, "deepen-not ", &amp;arg)) {
 			char *ref = NULL;
-			unsigned char sha1[20];
-			if (expand_ref(arg, strlen(arg), sha1, &amp;ref) != 1)
+			struct object_id oid;
+			if (expand_ref(arg, strlen(arg), oid.hash, &amp;ref) != 1)
 				die("git upload-pack: ambiguous deepen-not: %s", line);
 			string_list_append(&amp;deepen_not, ref);
 			free(ref);
@@ -794,7 +794,7 @@ static void receive_needs(void)
 			continue;
 		}
 		if (!skip_prefix(line, "want ", &amp;arg) ||
-		    get_sha1_hex(arg, sha1_buf))
+		    get_oid_hex(arg, &amp;oid_buf))
 			die("git upload-pack: protocol error, "
 			    "expected to get sha, not '%s'", line);
 
@@ -821,13 +821,13 @@ static void receive_needs(void)
 		if (parse_feature_request(features, "include-tag"))
 			use_include_tag = 1;
 
-		o = parse_object(sha1_buf);
+		o = parse_object(oid_buf.hash);
 		if (!o) {
 			packet_write_fmt(1,
 					 "ERR upload-pack: not our ref %s",
-					 sha1_to_hex(sha1_buf));
+					 oid_to_hex(&amp;oid_buf));
 			die("git upload-pack: not our ref %s",
-			    sha1_to_hex(sha1_buf));
+			    oid_to_hex(&amp;oid_buf));
 		}
 		if (!(o-&gt;flags &amp; WANTED)) {
 			o-&gt;flags |= WANTED;

<a href="#mfd9765dc878f10a7eeba0bf1f73efa2196eba891" id="efd9765dc878f10a7eeba0bf1f73efa2196eba891">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-44-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rfd9765dc878f10a7eeba0bf1f73efa2196eba891">52+ messages in thread</a></pre><hr><pre><a href="#e8f380b1897acf9bc1c19d0649c73dde9577ecde7" id="m8f380b1897acf9bc1c19d0649c73dde9577ecde7">*</a> <b>[PATCH v2 44/53] sha1_name: convert internals of peel_onion to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rfd9765dc878f10a7eeba0bf1f73efa2196eba891">(40 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mfd9765dc878f10a7eeba0bf1f73efa2196eba891">[PATCH v2 43/53] upload-pack: convert remaining parse_object callers to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m49aa033377306c7b5ae145b505e04d295b9b6b6b">[PATCH v2 45/53] builtin/read-tree: convert to struct object_id</a> brian m. carlson
                   ` <a href="#r49aa033377306c7b5ae145b505e04d295b9b6b6b">(8 subsequent siblings)</a>
  <a href="#r8f380b1897acf9bc1c19d0649c73dde9577ecde7">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 sha1_name.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/sha1_name.c b/sha1_name.c
index b7e09ac13..72e72ab9a 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -798,7 +798,7 @@ struct object *peel_to_type(const char *name, int namelen,
 static int peel_onion(const char *name, int len, unsigned char *sha1,
 		      unsigned lookup_flags)
 {
-	unsigned char outer[20];
+	struct object_id outer;
 	const char *sp;
 	unsigned int expected_type = 0;
 	struct object *o;
@@ -846,10 +846,10 @@ static int peel_onion(const char *name, int len, unsigned char *sha1,
 	else if (expected_type == OBJ_TREE)
 		lookup_flags |= GET_SHA1_TREEISH;
 
-	if (get_sha1_1(name, sp - name - 2, outer, lookup_flags))
+	if (get_sha1_1(name, sp - name - 2, outer.hash, lookup_flags))
 		return -1;
 
-	o = parse_object(outer);
+	o = parse_object(outer.hash);
 	if (!o)
 		return -1;
 	if (!expected_type) {

<a href="#m8f380b1897acf9bc1c19d0649c73dde9577ecde7" id="e8f380b1897acf9bc1c19d0649c73dde9577ecde7">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-45-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8f380b1897acf9bc1c19d0649c73dde9577ecde7">52+ messages in thread</a></pre><hr><pre><a href="#e49aa033377306c7b5ae145b505e04d295b9b6b6b" id="m49aa033377306c7b5ae145b505e04d295b9b6b6b">*</a> <b>[PATCH v2 45/53] builtin/read-tree: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8f380b1897acf9bc1c19d0649c73dde9577ecde7">(41 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8f380b1897acf9bc1c19d0649c73dde9577ecde7">[PATCH v2 44/53] sha1_name: convert internals of peel_onion to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m607f6a4b8c19f208b4d6b35c4d60b657c3854b72">[PATCH v2 46/53] builtin/ls-files: convert overlay_tree_on_cache to object_id</a> brian m. carlson
                   ` <a href="#r607f6a4b8c19f208b4d6b35c4d60b657c3854b72">(7 subsequent siblings)</a>
  <a href="#r49aa033377306c7b5ae145b505e04d295b9b6b6b">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a caller of parse_tree_indirect, which must be converted in
order to convert parse_object.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/read-tree.c | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/builtin/read-tree.c b/builtin/read-tree.c
index 23e212ee8..92eff23e4 100644
--- a/builtin/read-tree.c
+++ b/builtin/read-tree.c
@@ -23,13 +23,13 @@ static int read_empty;
 static struct tree *trees[MAX_UNPACK_TREES];
 static int recurse_submodules = RECURSE_SUBMODULES_DEFAULT;
 
-static int list_tree(unsigned char *sha1)
+static int list_tree(struct object_id *oid)
 {
 	struct tree *tree;
 
 	if (nr_trees &gt;= MAX_UNPACK_TREES)
 		die("I cannot read more than %d trees", MAX_UNPACK_TREES);
-	tree = parse_tree_indirect(sha1);
+	tree = parse_tree_indirect(oid-&gt;hash);
 	if (!tree)
 		return -1;
 	trees[nr_trees++] = tree;
@@ -121,7 +121,7 @@ static struct lock_file lock_file;
 int cmd_read_tree(int argc, const char **argv, const char *unused_prefix)
 {
 	int i, stage = 0;
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct tree_desc t[MAX_UNPACK_TREES];
 	struct unpack_trees_options opts;
 	int prefix_set = 0;
@@ -204,9 +204,9 @@ int cmd_read_tree(int argc, const char **argv, const char *unused_prefix)
 	for (i = 0; i &lt; argc; i++) {
 		const char *arg = argv[i];
 
-		if (get_sha1(arg, sha1))
+		if (get_oid(arg, &amp;oid))
 			die("Not a valid object name %s", arg);
-		if (list_tree(sha1) &lt; 0)
+		if (list_tree(&amp;oid) &lt; 0)
 			die("failed to unpack tree object %s", arg);
 		stage++;
 	}

<a href="#m49aa033377306c7b5ae145b505e04d295b9b6b6b" id="e49aa033377306c7b5ae145b505e04d295b9b6b6b">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-46-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r49aa033377306c7b5ae145b505e04d295b9b6b6b">52+ messages in thread</a></pre><hr><pre><a href="#e607f6a4b8c19f208b4d6b35c4d60b657c3854b72" id="m607f6a4b8c19f208b4d6b35c4d60b657c3854b72">*</a> <b>[PATCH v2 46/53] builtin/ls-files: convert overlay_tree_on_cache to object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r49aa033377306c7b5ae145b505e04d295b9b6b6b">(42 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m49aa033377306c7b5ae145b505e04d295b9b6b6b">[PATCH v2 45/53] builtin/read-tree: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m3eb79c7ed25fdce8306c3099f05061c62668af70">[PATCH v2 47/53] sequencer: convert fast_forward_to to struct object_id</a> brian m. carlson
                   ` <a href="#r3eb79c7ed25fdce8306c3099f05061c62668af70">(6 subsequent siblings)</a>
  <a href="#r607f6a4b8c19f208b4d6b35c4d60b657c3854b72">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is another caller of parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/ls-files.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/builtin/ls-files.c b/builtin/ls-files.c
index a6c70dbe9..da0ff849f 100644
--- a/builtin/ls-files.c
+++ b/builtin/ls-files.c
@@ -414,14 +414,14 @@ static void prune_cache(const char *prefix, size_t prefixlen)
 void overlay_tree_on_cache(const char *tree_name, const char *prefix)
 {
 	struct tree *tree;
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct pathspec pathspec;
 	struct cache_entry *last_stage0 = NULL;
 	int i;
 
-	if (get_sha1(tree_name, sha1))
+	if (get_oid(tree_name, &amp;oid))
 		die("tree-ish %s not found.", tree_name);
-	tree = parse_tree_indirect(sha1);
+	tree = parse_tree_indirect(oid.hash);
 	if (!tree)
 		die("bad tree-ish %s", tree_name);
 

<a href="#m607f6a4b8c19f208b4d6b35c4d60b657c3854b72" id="e607f6a4b8c19f208b4d6b35c4d60b657c3854b72">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-47-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r607f6a4b8c19f208b4d6b35c4d60b657c3854b72">52+ messages in thread</a></pre><hr><pre><a href="#e3eb79c7ed25fdce8306c3099f05061c62668af70" id="m3eb79c7ed25fdce8306c3099f05061c62668af70">*</a> <b>[PATCH v2 47/53] sequencer: convert fast_forward_to to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r607f6a4b8c19f208b4d6b35c4d60b657c3854b72">(43 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m607f6a4b8c19f208b4d6b35c4d60b657c3854b72">[PATCH v2 46/53] builtin/ls-files: convert overlay_tree_on_cache to object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#md23aa796bd1b61ecfdb7f836846e649518747c74">[PATCH v2 48/53] merge: convert checkout_fast_forward to struct object_id</a> brian m. carlson
                   ` <a href="#rd23aa796bd1b61ecfdb7f836846e649518747c74">(5 subsequent siblings)</a>
  <a href="#r3eb79c7ed25fdce8306c3099f05061c62668af70">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

fast_forward_to is required for checkout_fast_fowrard, which is required
for parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 sequencer.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/sequencer.c b/sequencer.c
index fa35e03b6..68e032630 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -374,7 +374,7 @@ static void update_abort_safety_file(void)
 		write_file(git_path_abort_safety_file(), "%s", "");
 }
 
-static int fast_forward_to(const unsigned char *to, const unsigned char *from,
+static int fast_forward_to(const struct object_id *to, const struct object_id *from,
 			int unborn, struct replay_opts *opts)
 {
 	struct ref_transaction *transaction;
@@ -382,7 +382,7 @@ static int fast_forward_to(const unsigned char *to, const unsigned char *from,
 	struct strbuf err = STRBUF_INIT;
 
 	read_cache();
-	if (checkout_fast_forward(from, to, 1))
+	if (checkout_fast_forward(from-&gt;hash, to-&gt;hash, 1))
 		return -1; /* the callee should have complained already */
 
 	strbuf_addf(&amp;sb, _("%s: fast-forward"), _(action_name(opts)));
@@ -390,7 +390,7 @@ static int fast_forward_to(const unsigned char *to, const unsigned char *from,
 	transaction = ref_transaction_begin(&amp;err);
 	if (!transaction ||
 	    ref_transaction_update(transaction, "HEAD",
-				   to, unborn ? null_sha1 : from,
+				   to-&gt;hash, unborn ? null_sha1 : from-&gt;hash,
 				   0, sb.buf, &amp;err) ||
 	    ref_transaction_commit(transaction, &amp;err)) {
 		ref_transaction_free(transaction);
@@ -935,7 +935,7 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 {
 	unsigned int flags = opts-&gt;edit ? EDIT_MSG : 0;
 	const char *msg_file = opts-&gt;edit ? NULL : git_path_merge_msg();
-	unsigned char head[20];
+	struct object_id head;
 	struct commit *base, *next, *parent;
 	const char *base_label, *next_label;
 	struct commit_message msg = { NULL, NULL, NULL, NULL };
@@ -949,12 +949,12 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 		 * that represents the "current" state for merge-recursive
 		 * to work on.
 		 */
-		if (write_cache_as_tree(head, 0, NULL))
+		if (write_cache_as_tree(head.hash, 0, NULL))
 			return error(_("your index file is unmerged."));
 	} else {
-		unborn = get_sha1("HEAD", head);
+		unborn = get_oid("HEAD", &amp;head);
 		if (unborn)
-			hashcpy(head, EMPTY_TREE_SHA1_BIN);
+			oidcpy(&amp;head, &amp;empty_tree_oid);
 		if (index_differs_from(unborn ? EMPTY_TREE_SHA1_HEX : "HEAD", 0, 0))
 			return error_dirty_index(opts);
 	}
@@ -990,11 +990,11 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 			oid_to_hex(&amp;commit-&gt;object.oid));
 
 	if (opts-&gt;allow_ff &amp;&amp; !is_fixup(command) &amp;&amp;
-	    ((parent &amp;&amp; !hashcmp(parent-&gt;object.oid.hash, head)) ||
+	    ((parent &amp;&amp; !oidcmp(&amp;parent-&gt;object.oid, &amp;head)) ||
 	     (!parent &amp;&amp; unborn))) {
 		if (is_rebase_i(opts))
 			write_author_script(msg.message);
-		res = fast_forward_to(commit-&gt;object.oid.hash, head, unborn,
+		res = fast_forward_to(&amp;commit-&gt;object.oid, &amp;head, unborn,
 			opts);
 		if (res || command != TODO_REWORD)
 			goto leave;
@@ -1081,7 +1081,7 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 		res = -1;
 	else if (!opts-&gt;strategy || !strcmp(opts-&gt;strategy, "recursive") || command == TODO_REVERT) {
 		res = do_recursive_merge(base, next, base_label, next_label,
-					 head, &amp;msgbuf, opts);
+					 head.hash, &amp;msgbuf, opts);
 		if (res &lt; 0)
 			return res;
 		res |= write_message(msgbuf.buf, msgbuf.len,
@@ -1097,7 +1097,7 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 		commit_list_insert(next, &amp;remotes);
 		res |= try_merge_command(opts-&gt;strategy,
 					 opts-&gt;xopts_nr, (const char **)opts-&gt;xopts,
-					common, sha1_to_hex(head), remotes);
+					common, oid_to_hex(&amp;head), remotes);
 		free_commit_list(common);
 		free_commit_list(remotes);
 	}

<a href="#m3eb79c7ed25fdce8306c3099f05061c62668af70" id="e3eb79c7ed25fdce8306c3099f05061c62668af70">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-48-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r3eb79c7ed25fdce8306c3099f05061c62668af70">52+ messages in thread</a></pre><hr><pre><a href="#ed23aa796bd1b61ecfdb7f836846e649518747c74" id="md23aa796bd1b61ecfdb7f836846e649518747c74">*</a> <b>[PATCH v2 48/53] merge: convert checkout_fast_forward to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r3eb79c7ed25fdce8306c3099f05061c62668af70">(44 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m3eb79c7ed25fdce8306c3099f05061c62668af70">[PATCH v2 47/53] sequencer: convert fast_forward_to to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#ma4e1b00422265eee46e4ad4d21251b063cfb20d8">[PATCH v2 49/53] builtin/ls-tree: convert to struct object_id</a> brian m. carlson
                   ` <a href="#ra4e1b00422265eee46e4ad4d21251b063cfb20d8">(4 subsequent siblings)</a>
  <a href="#rd23aa796bd1b61ecfdb7f836846e649518747c74">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Converting checkout_fast_forward is required to convert
parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/merge.c | 4 ++--
 builtin/pull.c  | 4 ++--
 cache.h         | 4 ++--
 merge.c         | 8 ++++----
 sequencer.c     | 2 +-
 5 files changed, 11 insertions(+), 11 deletions(-)

diff --git a/builtin/merge.c b/builtin/merge.c
index f11b5f3de..5ea7f7da9 100644
--- a/builtin/merge.c
+++ b/builtin/merge.c
@@ -1372,8 +1372,8 @@ int cmd_merge(int argc, const char **argv, const char *prefix)
 			goto done;
 		}
 
-		if (checkout_fast_forward(head_commit-&gt;object.oid.hash,
-					  commit-&gt;object.oid.hash,
+		if (checkout_fast_forward(&amp;head_commit-&gt;object.oid,
+					  &amp;commit-&gt;object.oid,
 					  overwrite_ignore)) {
 			ret = 1;
 			goto done;
diff --git a/builtin/pull.c b/builtin/pull.c
index 2ffb6569a..318c273eb 100644
--- a/builtin/pull.c
+++ b/builtin/pull.c
@@ -523,7 +523,7 @@ static int pull_into_void(const struct object_id *merge_head,
 	 * index/worktree changes that the user already made on the unborn
 	 * branch.
 	 */
-	if (checkout_fast_forward(EMPTY_TREE_SHA1_BIN, merge_head-&gt;hash, 0))
+	if (checkout_fast_forward(&amp;empty_tree_oid, merge_head, 0))
 		return 1;
 
 	if (update_ref("initial pull", "HEAD", merge_head-&gt;hash, curr_head-&gt;hash, 0, UPDATE_REFS_DIE_ON_ERR))
@@ -839,7 +839,7 @@ int cmd_pull(int argc, const char **argv, const char *prefix)
 			"fast-forwarding your working tree from\n"
 			"commit %s."), oid_to_hex(&amp;orig_head));
 
-		if (checkout_fast_forward(orig_head.hash, curr_head.hash, 0))
+		if (checkout_fast_forward(&amp;orig_head, &amp;curr_head, 0))
 			die(_("Cannot fast-forward your working tree.\n"
 				"After making sure that you saved anything precious from\n"
 				"$ git diff %s\n"
diff --git a/cache.h b/cache.h
index e1f0e182a..8862510f9 100644
--- a/cache.h
+++ b/cache.h
@@ -2198,8 +2198,8 @@ struct commit_list;
 int try_merge_command(const char *strategy, size_t xopts_nr,
 		const char **xopts, struct commit_list *common,
 		const char *head_arg, struct commit_list *remotes);
-int checkout_fast_forward(const unsigned char *from,
-			  const unsigned char *to,
+int checkout_fast_forward(const struct object_id *from,
+			  const struct object_id *to,
 			  int overwrite_ignore);
 
 
diff --git a/merge.c b/merge.c
index 04ee5fc91..b0cffe16f 100644
--- a/merge.c
+++ b/merge.c
@@ -44,8 +44,8 @@ int try_merge_command(const char *strategy, size_t xopts_nr,
 	return ret;
 }
 
-int checkout_fast_forward(const unsigned char *head,
-			  const unsigned char *remote,
+int checkout_fast_forward(const struct object_id *head,
+			  const struct object_id *remote,
 			  int overwrite_ignore)
 {
 	struct tree *trees[MAX_UNPACK_TREES];
@@ -79,10 +79,10 @@ int checkout_fast_forward(const unsigned char *head,
 	opts.fn = twoway_merge;
 	setup_unpack_trees_porcelain(&amp;opts, "merge");
 
-	trees[nr_trees] = parse_tree_indirect(head);
+	trees[nr_trees] = parse_tree_indirect(head-&gt;hash);
 	if (!trees[nr_trees++])
 		return -1;
-	trees[nr_trees] = parse_tree_indirect(remote);
+	trees[nr_trees] = parse_tree_indirect(remote-&gt;hash);
 	if (!trees[nr_trees++])
 		return -1;
 	for (i = 0; i &lt; nr_trees; i++) {
diff --git a/sequencer.c b/sequencer.c
index 68e032630..b295004af 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -382,7 +382,7 @@ static int fast_forward_to(const struct object_id *to, const struct object_id *f
 	struct strbuf err = STRBUF_INIT;
 
 	read_cache();
-	if (checkout_fast_forward(from-&gt;hash, to-&gt;hash, 1))
+	if (checkout_fast_forward(from, to, 1))
 		return -1; /* the callee should have complained already */
 
 	strbuf_addf(&amp;sb, _("%s: fast-forward"), _(action_name(opts)));

<a href="#md23aa796bd1b61ecfdb7f836846e649518747c74" id="ed23aa796bd1b61ecfdb7f836846e649518747c74">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-49-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rd23aa796bd1b61ecfdb7f836846e649518747c74">52+ messages in thread</a></pre><hr><pre><a href="#ea4e1b00422265eee46e4ad4d21251b063cfb20d8" id="ma4e1b00422265eee46e4ad4d21251b063cfb20d8">*</a> <b>[PATCH v2 49/53] builtin/ls-tree: convert to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rd23aa796bd1b61ecfdb7f836846e649518747c74">(45 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#md23aa796bd1b61ecfdb7f836846e649518747c74">[PATCH v2 48/53] merge: convert checkout_fast_forward to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#mf1693ad7f67b2fe233754b9eadcab84aadf89028">[PATCH v2 50/53] diff-lib: convert do_diff_cache to struct object_id</a> brian m. carlson
                   ` <a href="#rf1693ad7f67b2fe233754b9eadcab84aadf89028">(3 subsequent siblings)</a>
  <a href="#ra4e1b00422265eee46e4ad4d21251b063cfb20d8">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is a prerequisite to convert do_diff_cache, which is required to
convert parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/ls-tree.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/builtin/ls-tree.c b/builtin/ls-tree.c
index d7ebeb4ce..5baac3ef2 100644
--- a/builtin/ls-tree.c
+++ b/builtin/ls-tree.c
@@ -119,7 +119,7 @@ static int show_tree(const unsigned char *sha1, struct strbuf *base,
 
 int cmd_ls_tree(int argc, const char **argv, const char *prefix)
 {
-	unsigned char sha1[20];
+	struct object_id oid;
 	struct tree *tree;
 	int i, full_tree = 0;
 	const struct option ls_tree_options[] = {
@@ -164,7 +164,7 @@ int cmd_ls_tree(int argc, const char **argv, const char *prefix)
 
 	if (argc &lt; 1)
 		usage_with_options(ls_tree_usage, ls_tree_options);
-	if (get_sha1(argv[0], sha1))
+	if (get_oid(argv[0], &amp;oid))
 		die("Not a valid object name %s", argv[0]);
 
 	/*
@@ -180,7 +180,7 @@ int cmd_ls_tree(int argc, const char **argv, const char *prefix)
 	for (i = 0; i &lt; pathspec.nr; i++)
 		pathspec.items[i].nowildcard_len = pathspec.items[i].len;
 	pathspec.has_wildcard = 0;
-	tree = parse_tree_indirect(sha1);
+	tree = parse_tree_indirect(oid.hash);
 	if (!tree)
 		die("not a tree object");
 	return !!read_tree_recursive(tree, "", 0, 0, &amp;pathspec, show_tree, NULL);

<a href="#ma4e1b00422265eee46e4ad4d21251b063cfb20d8" id="ea4e1b00422265eee46e4ad4d21251b063cfb20d8">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-50-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#ra4e1b00422265eee46e4ad4d21251b063cfb20d8">52+ messages in thread</a></pre><hr><pre><a href="#ef1693ad7f67b2fe233754b9eadcab84aadf89028" id="mf1693ad7f67b2fe233754b9eadcab84aadf89028">*</a> <b>[PATCH v2 50/53] diff-lib: convert do_diff_cache to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#ra4e1b00422265eee46e4ad4d21251b063cfb20d8">(46 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#ma4e1b00422265eee46e4ad4d21251b063cfb20d8">[PATCH v2 49/53] builtin/ls-tree: convert to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m983604041bbfadedd072bd3e5c477354fa062e73">[PATCH v2 51/53] sequencer: convert do_recursive_merge to struct object_id</a> brian m. carlson
                   ` <a href="#r983604041bbfadedd072bd3e5c477354fa062e73">(2 subsequent siblings)</a>
  <a href="#rf1693ad7f67b2fe233754b9eadcab84aadf89028">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This is needed to convert parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/am.c    |  2 +-
 builtin/blame.c |  6 +++---
 builtin/reset.c |  2 +-
 diff-lib.c      | 12 ++++++------
 diff.h          |  2 +-
 5 files changed, 12 insertions(+), 12 deletions(-)

diff --git a/builtin/am.c b/builtin/am.c
index 642d7047d..200d9dbed 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -1145,7 +1145,7 @@ static int index_has_changes(struct strbuf *sb)
 		DIFF_OPT_SET(&amp;opt, EXIT_WITH_STATUS);
 		if (!sb)
 			DIFF_OPT_SET(&amp;opt, QUICK);
-		do_diff_cache(head.hash, &amp;opt);
+		do_diff_cache(&amp;head, &amp;opt);
 		diffcore_std(&amp;opt);
 		for (i = 0; sb &amp;&amp; i &lt; diff_queued_diff.nr; i++) {
 			if (i)
diff --git a/builtin/blame.c b/builtin/blame.c
index 58bb274d0..e920314a7 100644
--- a/builtin/blame.c
+++ b/builtin/blame.c
@@ -563,7 +563,7 @@ static struct origin *find_origin(struct scoreboard *sb,
 	diff_setup_done(&amp;diff_opts);
 
 	if (is_null_oid(&amp;origin-&gt;commit-&gt;object.oid))
-		do_diff_cache(parent-&gt;tree-&gt;object.oid.hash, &amp;diff_opts);
+		do_diff_cache(&amp;parent-&gt;tree-&gt;object.oid, &amp;diff_opts);
 	else
 		diff_tree_sha1(parent-&gt;tree-&gt;object.oid.hash,
 			       origin-&gt;commit-&gt;tree-&gt;object.oid.hash,
@@ -633,7 +633,7 @@ static struct origin *find_rename(struct scoreboard *sb,
 	diff_setup_done(&amp;diff_opts);
 
 	if (is_null_oid(&amp;origin-&gt;commit-&gt;object.oid))
-		do_diff_cache(parent-&gt;tree-&gt;object.oid.hash, &amp;diff_opts);
+		do_diff_cache(&amp;parent-&gt;tree-&gt;object.oid, &amp;diff_opts);
 	else
 		diff_tree_sha1(parent-&gt;tree-&gt;object.oid.hash,
 			       origin-&gt;commit-&gt;tree-&gt;object.oid.hash,
@@ -1272,7 +1272,7 @@ static void find_copy_in_parent(struct scoreboard *sb,
 		DIFF_OPT_SET(&amp;diff_opts, FIND_COPIES_HARDER);
 
 	if (is_null_oid(&amp;target-&gt;commit-&gt;object.oid))
-		do_diff_cache(parent-&gt;tree-&gt;object.oid.hash, &amp;diff_opts);
+		do_diff_cache(&amp;parent-&gt;tree-&gt;object.oid, &amp;diff_opts);
 	else
 		diff_tree_sha1(parent-&gt;tree-&gt;object.oid.hash,
 			       target-&gt;commit-&gt;tree-&gt;object.oid.hash,
diff --git a/builtin/reset.c b/builtin/reset.c
index 0be52fa36..3415dac5d 100644
--- a/builtin/reset.c
+++ b/builtin/reset.c
@@ -154,7 +154,7 @@ static int read_from_tree(const struct pathspec *pathspec,
 	opt.format_callback = update_index_from_diff;
 	opt.format_callback_data = &amp;intent_to_add;
 
-	if (do_diff_cache(tree_oid-&gt;hash, &amp;opt))
+	if (do_diff_cache(tree_oid, &amp;opt))
 		return 1;
 	diffcore_std(&amp;opt);
 	diff_flush(&amp;opt);
diff --git a/diff-lib.c b/diff-lib.c
index 52447466b..ee9df0f84 100644
--- a/diff-lib.c
+++ b/diff-lib.c
@@ -478,7 +478,7 @@ static int oneway_diff(const struct cache_entry * const *src,
 }
 
 static int diff_cache(struct rev_info *revs,
-		      const unsigned char *tree_sha1,
+		      const struct object_id *tree_oid,
 		      const char *tree_name,
 		      int cached)
 {
@@ -486,10 +486,10 @@ static int diff_cache(struct rev_info *revs,
 	struct tree_desc t;
 	struct unpack_trees_options opts;
 
-	tree = parse_tree_indirect(tree_sha1);
+	tree = parse_tree_indirect(tree_oid-&gt;hash);
 	if (!tree)
 		return error("bad tree object %s",
-			     tree_name ? tree_name : sha1_to_hex(tree_sha1));
+			     tree_name ? tree_name : oid_to_hex(tree_oid));
 	memset(&amp;opts, 0, sizeof(opts));
 	opts.head_idx = 1;
 	opts.index_only = cached;
@@ -512,7 +512,7 @@ int run_diff_index(struct rev_info *revs, int cached)
 	struct object_array_entry *ent;
 
 	ent = revs-&gt;pending.objects;
-	if (diff_cache(revs, ent-&gt;item-&gt;oid.hash, ent-&gt;name, cached))
+	if (diff_cache(revs, &amp;ent-&gt;item-&gt;oid, ent-&gt;name, cached))
 		exit(128);
 
 	diff_set_mnemonic_prefix(&amp;revs-&gt;diffopt, "c/", cached ? "i/" : "w/");
@@ -522,7 +522,7 @@ int run_diff_index(struct rev_info *revs, int cached)
 	return 0;
 }
 
-int do_diff_cache(const unsigned char *tree_sha1, struct diff_options *opt)
+int do_diff_cache(const struct object_id *tree_oid, struct diff_options *opt)
 {
 	struct rev_info revs;
 
@@ -530,7 +530,7 @@ int do_diff_cache(const unsigned char *tree_sha1, struct diff_options *opt)
 	copy_pathspec(&amp;revs.prune_data, &amp;opt-&gt;pathspec);
 	revs.diffopt = *opt;
 
-	if (diff_cache(&amp;revs, tree_sha1, NULL, 1))
+	if (diff_cache(&amp;revs, tree_oid, NULL, 1))
 		exit(128);
 	return 0;
 }
diff --git a/diff.h b/diff.h
index 5be1ee77a..d75e6d15e 100644
--- a/diff.h
+++ b/diff.h
@@ -354,7 +354,7 @@ extern const char *diff_aligned_abbrev(const struct object_id *sha1, int);
 extern int run_diff_files(struct rev_info *revs, unsigned int option);
 extern int run_diff_index(struct rev_info *revs, int cached);
 
-extern int do_diff_cache(const unsigned char *, struct diff_options *);
+extern int do_diff_cache(const struct object_id *, struct diff_options *);
 extern int diff_flush_patch_id(struct diff_options *, unsigned char *, int);
 
 extern int diff_result_code(struct diff_options *, int);

<a href="#mf1693ad7f67b2fe233754b9eadcab84aadf89028" id="ef1693ad7f67b2fe233754b9eadcab84aadf89028">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-51-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#rf1693ad7f67b2fe233754b9eadcab84aadf89028">52+ messages in thread</a></pre><hr><pre><a href="#e983604041bbfadedd072bd3e5c477354fa062e73" id="m983604041bbfadedd072bd3e5c477354fa062e73">*</a> <b>[PATCH v2 51/53] sequencer: convert do_recursive_merge to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#rf1693ad7f67b2fe233754b9eadcab84aadf89028">(47 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#mf1693ad7f67b2fe233754b9eadcab84aadf89028">[PATCH v2 50/53] diff-lib: convert do_diff_cache to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#m8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">[PATCH v2 52/53] tree: convert parse_tree_indirect to struct object_id</a> brian m. carlson
  2017-05-01  2:29 ` <a href="#ma058b65b564ab02c1f795f048dc3a609f2c7550c">[PATCH v2 53/53] object: convert parse_object* to take struct object_id</a> brian m. carlson
  <a href="#r983604041bbfadedd072bd3e5c477354fa062e73">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

This conversion is required to convert parse_tree_indirect.

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 sequencer.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/sequencer.c b/sequencer.c
index b295004af..d2963c6c5 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -426,7 +426,7 @@ void append_conflicts_hint(struct strbuf *msgbuf)
 
 static int do_recursive_merge(struct commit *base, struct commit *next,
 			      const char *base_label, const char *next_label,
-			      unsigned char *head, struct strbuf *msgbuf,
+			      struct object_id *head, struct strbuf *msgbuf,
 			      struct replay_opts *opts)
 {
 	struct merge_options o;
@@ -446,7 +446,7 @@ static int do_recursive_merge(struct commit *base, struct commit *next,
 	if (is_rebase_i(opts))
 		o.buffer_output = 2;
 
-	head_tree = parse_tree_indirect(head);
+	head_tree = parse_tree_indirect(head-&gt;hash);
 	next_tree = next ? next-&gt;tree : empty_tree();
 	base_tree = base ? base-&gt;tree : empty_tree();
 
@@ -1081,7 +1081,7 @@ static int do_pick_commit(enum todo_command command, struct commit *commit,
 		res = -1;
 	else if (!opts-&gt;strategy || !strcmp(opts-&gt;strategy, "recursive") || command == TODO_REVERT) {
 		res = do_recursive_merge(base, next, base_label, next_label,
-					 head.hash, &amp;msgbuf, opts);
+					 &amp;head, &amp;msgbuf, opts);
 		if (res &lt; 0)
 			return res;
 		res |= write_message(msgbuf.buf, msgbuf.len,

<a href="#m983604041bbfadedd072bd3e5c477354fa062e73" id="e983604041bbfadedd072bd3e5c477354fa062e73">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-52-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r983604041bbfadedd072bd3e5c477354fa062e73">52+ messages in thread</a></pre><hr><pre><a href="#e8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7" id="m8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">*</a> <b>[PATCH v2 52/53] tree: convert parse_tree_indirect to struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r983604041bbfadedd072bd3e5c477354fa062e73">(48 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m983604041bbfadedd072bd3e5c477354fa062e73">[PATCH v2 51/53] sequencer: convert do_recursive_merge to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  2017-05-01  2:29 ` <a href="#ma058b65b564ab02c1f795f048dc3a609f2c7550c">[PATCH v2 53/53] object: convert parse_object* to take struct object_id</a> brian m. carlson
  <a href="#r8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái Ngọc Duy

Convert parse_tree_indirect to take a pointer to struct object_id.
Update all the callers.  This transformation was achieved using the
following semantic patch and manual updates to the declaration and
definition.  Update builtin/checkout.c manually as well, since it uses a
ternary expression not handled by the semantic patch.

@@
expression E1;
@@
- parse_tree_indirect(E1.hash)
+ parse_tree_indirect(&amp;E1)

@@
expression E1;
@@
- parse_tree_indirect(E1-&gt;hash)
+ parse_tree_indirect(E1)

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 archive.c                   | 4 ++--
 builtin/am.c                | 6 +++---
 builtin/checkout.c          | 8 ++++----
 builtin/clone.c             | 2 +-
 builtin/commit.c            | 2 +-
 builtin/ls-files.c          | 2 +-
 builtin/ls-tree.c           | 2 +-
 builtin/merge.c             | 6 +++---
 builtin/read-tree.c         | 2 +-
 builtin/reset.c             | 4 ++--
 diff-lib.c                  | 2 +-
 merge.c                     | 4 ++--
 sequencer.c                 | 2 +-
 t/helper/test-match-trees.c | 4 ++--
 tree.c                      | 4 ++--
 tree.h                      | 2 +-
 16 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/archive.c b/archive.c
index 54701e8bb..b15a922da 100644
--- a/archive.c
+++ b/archive.c
@@ -369,7 +369,7 @@ static void parse_treeish_arg(const char **argv,
 		archive_time = time(NULL);
 	}
 
-	tree = parse_tree_indirect(oid.hash);
+	tree = parse_tree_indirect(&amp;oid);
 	if (tree == NULL)
 		die("not a tree object");
 
@@ -383,7 +383,7 @@ static void parse_treeish_arg(const char **argv,
 		if (err || !S_ISDIR(mode))
 			die("current working directory is untracked");
 
-		tree = parse_tree_indirect(tree_oid.hash);
+		tree = parse_tree_indirect(&amp;tree_oid);
 	}
 	ar_args-&gt;tree = tree;
 	ar_args-&gt;commit_sha1 = commit_sha1;
diff --git a/builtin/am.c b/builtin/am.c
index 200d9dbed..a2867f347 100644
--- a/builtin/am.c
+++ b/builtin/am.c
@@ -2045,11 +2045,11 @@ static int clean_index(const struct object_id *head, const struct object_id *rem
 	struct tree *head_tree, *remote_tree, *index_tree;
 	struct object_id index;
 
-	head_tree = parse_tree_indirect(head-&gt;hash);
+	head_tree = parse_tree_indirect(head);
 	if (!head_tree)
 		return error(_("Could not parse object '%s'."), oid_to_hex(head));
 
-	remote_tree = parse_tree_indirect(remote-&gt;hash);
+	remote_tree = parse_tree_indirect(remote);
 	if (!remote_tree)
 		return error(_("Could not parse object '%s'."), oid_to_hex(remote));
 
@@ -2061,7 +2061,7 @@ static int clean_index(const struct object_id *head, const struct object_id *rem
 	if (write_cache_as_tree(index.hash, 0, NULL))
 		return -1;
 
-	index_tree = parse_tree_indirect(index.hash);
+	index_tree = parse_tree_indirect(&amp;index);
 	if (!index_tree)
 		return error(_("Could not parse object '%s'."), oid_to_hex(&amp;index));
 
diff --git a/builtin/checkout.c b/builtin/checkout.c
index 7f1eeea94..13365fb62 100644
--- a/builtin/checkout.c
+++ b/builtin/checkout.c
@@ -527,10 +527,10 @@ static int merge_working_tree(const struct checkout_opts *opts,
 			setup_standard_excludes(topts.dir);
 		}
 		tree = parse_tree_indirect(old-&gt;commit ?
-					   old-&gt;commit-&gt;object.oid.hash :
-					   EMPTY_TREE_SHA1_BIN);
+					   &amp;old-&gt;commit-&gt;object.oid :
+					   &amp;empty_tree_oid);
 		init_tree_desc(&amp;trees[0], tree-&gt;buffer, tree-&gt;size);
-		tree = parse_tree_indirect(new-&gt;commit-&gt;object.oid.hash);
+		tree = parse_tree_indirect(&amp;new-&gt;commit-&gt;object.oid);
 		init_tree_desc(&amp;trees[1], tree-&gt;buffer, tree-&gt;size);
 
 		ret = unpack_trees(2, trees, &amp;topts);
@@ -1050,7 +1050,7 @@ static int parse_branchname_arg(int argc, const char **argv,
 	new-&gt;commit = lookup_commit_reference_gently(rev, 1);
 	if (!new-&gt;commit) {
 		/* not a commit */
-		*source_tree = parse_tree_indirect(rev-&gt;hash);
+		*source_tree = parse_tree_indirect(rev);
 	} else {
 		parse_commit_or_die(new-&gt;commit);
 		*source_tree = new-&gt;commit-&gt;tree;
diff --git a/builtin/clone.c b/builtin/clone.c
index 646f28792..da2d3c1ae 100644
--- a/builtin/clone.c
+++ b/builtin/clone.c
@@ -739,7 +739,7 @@ static int checkout(int submodule_progress)
 	opts.src_index = &amp;the_index;
 	opts.dst_index = &amp;the_index;
 
-	tree = parse_tree_indirect(oid.hash);
+	tree = parse_tree_indirect(&amp;oid);
 	parse_tree(tree);
 	init_tree_desc(&amp;t, tree-&gt;buffer, tree-&gt;size);
 	if (unpack_trees(1, &amp;t, &amp;opts) &lt; 0)
diff --git a/builtin/commit.c b/builtin/commit.c
index e69f466d5..6adc908b3 100644
--- a/builtin/commit.c
+++ b/builtin/commit.c
@@ -313,7 +313,7 @@ static void create_base_index(const struct commit *current_head)
 	opts.dst_index = &amp;the_index;
 
 	opts.fn = oneway_merge;
-	tree = parse_tree_indirect(current_head-&gt;object.oid.hash);
+	tree = parse_tree_indirect(&amp;current_head-&gt;object.oid);
 	if (!tree)
 		die(_("failed to unpack HEAD tree object"));
 	parse_tree(tree);
diff --git a/builtin/ls-files.c b/builtin/ls-files.c
index da0ff849f..f20edabe6 100644
--- a/builtin/ls-files.c
+++ b/builtin/ls-files.c
@@ -421,7 +421,7 @@ void overlay_tree_on_cache(const char *tree_name, const char *prefix)
 
 	if (get_oid(tree_name, &amp;oid))
 		die("tree-ish %s not found.", tree_name);
-	tree = parse_tree_indirect(oid.hash);
+	tree = parse_tree_indirect(&amp;oid);
 	if (!tree)
 		die("bad tree-ish %s", tree_name);
 
diff --git a/builtin/ls-tree.c b/builtin/ls-tree.c
index 5baac3ef2..ee7b293b1 100644
--- a/builtin/ls-tree.c
+++ b/builtin/ls-tree.c
@@ -180,7 +180,7 @@ int cmd_ls_tree(int argc, const char **argv, const char *prefix)
 	for (i = 0; i &lt; pathspec.nr; i++)
 		pathspec.items[i].nowildcard_len = pathspec.items[i].len;
 	pathspec.has_wildcard = 0;
-	tree = parse_tree_indirect(oid.hash);
+	tree = parse_tree_indirect(&amp;oid);
 	if (!tree)
 		die("not a tree object");
 	return !!read_tree_recursive(tree, "", 0, 0, &amp;pathspec, show_tree, NULL);
diff --git a/builtin/merge.c b/builtin/merge.c
index 5ea7f7da9..a4a098f40 100644
--- a/builtin/merge.c
+++ b/builtin/merge.c
@@ -605,13 +605,13 @@ static int read_tree_trivial(struct object_id *common, struct object_id *head,
 	opts.verbose_update = 1;
 	opts.trivial_merges_only = 1;
 	opts.merge = 1;
-	trees[nr_trees] = parse_tree_indirect(common-&gt;hash);
+	trees[nr_trees] = parse_tree_indirect(common);
 	if (!trees[nr_trees++])
 		return -1;
-	trees[nr_trees] = parse_tree_indirect(head-&gt;hash);
+	trees[nr_trees] = parse_tree_indirect(head);
 	if (!trees[nr_trees++])
 		return -1;
-	trees[nr_trees] = parse_tree_indirect(one-&gt;hash);
+	trees[nr_trees] = parse_tree_indirect(one);
 	if (!trees[nr_trees++])
 		return -1;
 	opts.fn = threeway_merge;
diff --git a/builtin/read-tree.c b/builtin/read-tree.c
index 92eff23e4..6d45175f6 100644
--- a/builtin/read-tree.c
+++ b/builtin/read-tree.c
@@ -29,7 +29,7 @@ static int list_tree(struct object_id *oid)
 
 	if (nr_trees &gt;= MAX_UNPACK_TREES)
 		die("I cannot read more than %d trees", MAX_UNPACK_TREES);
-	tree = parse_tree_indirect(oid-&gt;hash);
+	tree = parse_tree_indirect(oid);
 	if (!tree)
 		return -1;
 	trees[nr_trees++] = tree;
diff --git a/builtin/reset.c b/builtin/reset.c
index 3415dac5d..c782739c2 100644
--- a/builtin/reset.c
+++ b/builtin/reset.c
@@ -84,7 +84,7 @@ static int reset_index(const struct object_id *oid, int reset_type, int quiet)
 		return -1;
 
 	if (reset_type == MIXED || reset_type == HARD) {
-		tree = parse_tree_indirect(oid-&gt;hash);
+		tree = parse_tree_indirect(oid);
 		prime_cache_tree(&amp;the_index, tree);
 	}
 
@@ -311,7 +311,7 @@ int cmd_reset(int argc, const char **argv, const char *prefix)
 		struct tree *tree;
 		if (get_sha1_treeish(rev, oid.hash))
 			die(_("Failed to resolve '%s' as a valid tree."), rev);
-		tree = parse_tree_indirect(oid.hash);
+		tree = parse_tree_indirect(&amp;oid);
 		if (!tree)
 			die(_("Could not parse object '%s'."), rev);
 		oidcpy(&amp;oid, &amp;tree-&gt;object.oid);
diff --git a/diff-lib.c b/diff-lib.c
index ee9df0f84..2982bf055 100644
--- a/diff-lib.c
+++ b/diff-lib.c
@@ -486,7 +486,7 @@ static int diff_cache(struct rev_info *revs,
 	struct tree_desc t;
 	struct unpack_trees_options opts;
 
-	tree = parse_tree_indirect(tree_oid-&gt;hash);
+	tree = parse_tree_indirect(tree_oid);
 	if (!tree)
 		return error("bad tree object %s",
 			     tree_name ? tree_name : oid_to_hex(tree_oid));
diff --git a/merge.c b/merge.c
index b0cffe16f..1d441ad94 100644
--- a/merge.c
+++ b/merge.c
@@ -79,10 +79,10 @@ int checkout_fast_forward(const struct object_id *head,
 	opts.fn = twoway_merge;
 	setup_unpack_trees_porcelain(&amp;opts, "merge");
 
-	trees[nr_trees] = parse_tree_indirect(head-&gt;hash);
+	trees[nr_trees] = parse_tree_indirect(head);
 	if (!trees[nr_trees++])
 		return -1;
-	trees[nr_trees] = parse_tree_indirect(remote-&gt;hash);
+	trees[nr_trees] = parse_tree_indirect(remote);
 	if (!trees[nr_trees++])
 		return -1;
 	for (i = 0; i &lt; nr_trees; i++) {
diff --git a/sequencer.c b/sequencer.c
index d2963c6c5..625f0bd64 100644
--- a/sequencer.c
+++ b/sequencer.c
@@ -446,7 +446,7 @@ static int do_recursive_merge(struct commit *base, struct commit *next,
 	if (is_rebase_i(opts))
 		o.buffer_output = 2;
 
-	head_tree = parse_tree_indirect(head-&gt;hash);
+	head_tree = parse_tree_indirect(head);
 	next_tree = next ? next-&gt;tree : empty_tree();
 	base_tree = base ? base-&gt;tree : empty_tree();
 
diff --git a/t/helper/test-match-trees.c b/t/helper/test-match-trees.c
index e93950286..356d8edef 100644
--- a/t/helper/test-match-trees.c
+++ b/t/helper/test-match-trees.c
@@ -12,10 +12,10 @@ int cmd_main(int ac, const char **av)
 		die("cannot parse %s as an object name", av[1]);
 	if (get_oid(av[2], &amp;hash2))
 		die("cannot parse %s as an object name", av[2]);
-	one = parse_tree_indirect(hash1.hash);
+	one = parse_tree_indirect(&amp;hash1);
 	if (!one)
 		die("not a tree-ish %s", av[1]);
-	two = parse_tree_indirect(hash2.hash);
+	two = parse_tree_indirect(&amp;hash2);
 	if (!two)
 		die("not a tree-ish %s", av[2]);
 
diff --git a/tree.c b/tree.c
index 28ce930b9..9adcd8bd4 100644
--- a/tree.c
+++ b/tree.c
@@ -232,9 +232,9 @@ void free_tree_buffer(struct tree *tree)
 	tree-&gt;object.parsed = 0;
 }
 
-struct tree *parse_tree_indirect(const unsigned char *sha1)
+struct tree *parse_tree_indirect(const struct object_id *oid)
 {
-	struct object *obj = parse_object(sha1);
+	struct object *obj = parse_object(oid-&gt;hash);
 	do {
 		if (!obj)
 			return NULL;
diff --git a/tree.h b/tree.h
index 2b2c8dbbe..0d4734b94 100644
--- a/tree.h
+++ b/tree.h
@@ -24,7 +24,7 @@ static inline int parse_tree(struct tree *tree)
 void free_tree_buffer(struct tree *tree);
 
 /* Parses and returns the tree in the given ent, chasing tags and commits. */
-struct tree *parse_tree_indirect(const unsigned char *sha1);
+struct tree *parse_tree_indirect(const struct object_id *oid);
 
 #define READ_TREE_RECURSIVE 1
 typedef int (*read_tree_fn_t)(const unsigned char *, struct strbuf *, const char *, unsigned int, int, void *);

<a href="#m8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7" id="e8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-53-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#r8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">52+ messages in thread</a></pre><hr><pre><a href="#ea058b65b564ab02c1f795f048dc3a609f2c7550c" id="ma058b65b564ab02c1f795f048dc3a609f2c7550c">*</a> <b>[PATCH v2 53/53] object: convert parse_object* to take struct object_id</b>
  2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
                   ` <a href="#r8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">(49 preceding siblings ...)</a>
  2017-05-01  2:29 ` <a href="#m8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">[PATCH v2 52/53] tree: convert parse_tree_indirect to struct object_id</a> brian m. carlson
<b>@ 2017-05-01  2:29 ` brian m. carlson</b>
  <a href="#ra058b65b564ab02c1f795f048dc3a609f2c7550c">50 siblings, 0 replies; 52+ messages in thread</a>
From: brian m. carlson @ 2017-05-01  2:29 UTC (<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/">permalink</a> / <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/raw">raw</a>)
  To: git; +Cc: Michael Haggerty, Stefan Beller, Jeff King, Nguyễn Thái 
Ngọc Duy

Make parse_object, parse_object_or_die, and parse_object_buffer take a
pointer to struct object_id.  Remove the temporary variables inserted
earlier, since they are no longer necessary.  Transform all of the
callers using the following semantic patch:

@@
expression E1;
@@
- parse_object(E1.hash)
+ parse_object(&amp;E1)

@@
expression E1;
@@
- parse_object(E1-&gt;hash)
+ parse_object(E1)

@@
expression E1, E2;
@@
- parse_object_or_die(E1.hash, E2)
+ parse_object_or_die(&amp;E1, E2)

@@
expression E1, E2;
@@
- parse_object_or_die(E1-&gt;hash, E2)
+ parse_object_or_die(E1, E2)

@@
expression E1, E2, E3, E4, E5;
@@
- parse_object_buffer(E1.hash, E2, E3, E4, E5)
+ parse_object_buffer(&amp;E1, E2, E3, E4, E5)

@@
expression E1, E2, E3, E4, E5;
@@
- parse_object_buffer(E1-&gt;hash, E2, E3, E4, E5)
+ parse_object_buffer(E1, E2, E3, E4, E5)

Signed-off-by: brian m. carlson &lt;sandals@crustytoothpaste.net&gt;
---
 builtin/diff-tree.c      |  2 +-
 builtin/diff.c           |  2 +-
 builtin/fast-export.c    |  4 ++--
 builtin/fmt-merge-msg.c  |  4 ++--
 builtin/fsck.c           |  8 ++++----
 builtin/grep.c           |  2 +-
 builtin/index-pack.c     |  3 ++-
 builtin/log.c            |  2 +-
 builtin/name-rev.c       |  6 +++---
 builtin/prune.c          |  3 ++-
 builtin/receive-pack.c   |  6 +++---
 builtin/reflog.c         |  2 +-
 builtin/rev-list.c       |  2 +-
 builtin/unpack-objects.c |  3 ++-
 bundle.c                 | 10 ++++++----
 commit.c                 |  4 ++--
 fetch-pack.c             | 14 +++++++-------
 fsck.c                   |  2 +-
 http-backend.c           |  2 +-
 http-push.c              |  4 ++--
 log-tree.c               |  6 +++---
 merge-recursive.c        |  2 +-
 object.c                 | 44 
+++++++++++++++++++-------------------------
 object.h                 |  8 ++++----
 pack-bitmap.c            |  4 ++--
 pretty.c                 |  2 +-
 reachable.c              |  4 ++--
 ref-filter.c             |  4 ++--
 reflog-walk.c            |  4 ++--
 refs/files-backend.c     |  2 +-
 remote.c                 |  4 ++--
 revision.c               | 12 ++++++------
 server-info.c            |  2 +-
 sha1_name.c              | 14 +++++++-------
 tag.c                    |  4 ++--
 tree.c                   |  4 ++--
 upload-pack.c            |  8 ++++----
 walker.c                 |  2 +-
 38 files changed, 107 insertions(+), 108 deletions(-)

diff --git a/builtin/diff-tree.c b/builtin/diff-tree.c
index 95b8d1ba7..5ea1c1431 100644
--- a/builtin/diff-tree.c
+++ b/builtin/diff-tree.c
@@ -67,7 +67,7 @@ static int diff_tree_stdin(char *line)
 	line[len-1] = 0;
 	if (parse_oid_hex(line, &amp;oid, &amp;p))
 		return -1;
-	obj = parse_object(oid.hash);
+	obj = parse_object(&amp;oid);
 	if (!obj)
 		return -1;
 	if (obj-&gt;type == OBJ_COMMIT)
diff --git a/builtin/diff.c b/builtin/diff.c
index 895f92897..8c03ddaf5 100644
--- a/builtin/diff.c
+++ b/builtin/diff.c
@@ -395,7 +395,7 @@ int cmd_diff(int argc, const char **argv, const char
 *prefix)
 		const char *name = entry-&gt;name;
 		int flags = (obj-&gt;flags &amp; UNINTERESTING);
 		if (!obj-&gt;parsed)
-			obj = parse_object(obj-&gt;oid.hash);
+			obj = parse_object(&amp;obj-&gt;oid);
 		obj = deref_tag(obj, NULL, 0);
 		if (!obj)
 			die(_("invalid object '%s' given."), name);
diff --git a/builtin/fast-export.c b/builtin/fast-export.c
index ae36b14db..969550531 100644
--- a/builtin/fast-export.c
+++ b/builtin/fast-export.c
@@ -240,7 +240,7 @@ static void export_blob(const struct object_id *oid)
 			die ("Could not read blob %s", oid_to_hex(oid));
 		if (check_sha1_signature(oid-&gt;hash, buf, size, typename(type)) 
&lt; 0)
 			die("sha1 mismatch in blob %s", oid_to_hex(oid));
-		object = parse_object_buffer(oid-&gt;hash, type, size, buf, 
&amp;eaten);
+		object = parse_object_buffer(oid, type, size, buf, &amp;eaten);
 	}
 
 	if (!object)
@@ -777,7 +777,7 @@ static struct commit *get_commit(struct 
rev_cmdline_entry *e, char *full_name)
 
 		/* handle nested tags */
 		while (tag &amp;&amp; tag-&gt;object.type == OBJ_TAG) {
-			parse_object(tag-&gt;object.oid.hash);
+			parse_object(&amp;tag-&gt;object.oid);
 			string_list_append(&amp;extra_refs, full_name)-&gt;util = tag;
 			tag = (struct tag *)tag-&gt;tagged;
 		}
diff --git a/builtin/fmt-merge-msg.c b/builtin/fmt-merge-msg.c
index 91dd753dd..70137b0b7 100644
--- a/builtin/fmt-merge-msg.c
+++ b/builtin/fmt-merge-msg.c
@@ -341,7 +341,7 @@ static void shortlog(const char *name,
 	const struct object_id *oid = &amp;origin_data-&gt;oid;
 	int limit = opts-&gt;shortlog_len;
 
-	branch = deref_tag(parse_object(oid-&gt;hash), oid_to_hex(oid), 
GIT_SHA1_HEXSZ);
+	branch = deref_tag(parse_object(oid), oid_to_hex(oid), 
GIT_SHA1_HEXSZ);
 	if (!branch || branch-&gt;type != OBJ_COMMIT)
 		return;
 
@@ -559,7 +559,7 @@ static void find_merge_parents(struct merge_parents 
*result,
 		 * "name" here and we do not want to contaminate its
 		 * util field yet.
 		 */
-		obj = parse_object(oid.hash);
+		obj = parse_object(&amp;oid);
 		parent = (struct commit *)peel_to_type(NULL, 0, obj, OBJ_COMMIT);
 		if (!parent)
 			continue;
diff --git a/builtin/fsck.c b/builtin/fsck.c
index a187054da..8b8146174 100644
--- a/builtin/fsck.c
+++ b/builtin/fsck.c
@@ -385,7 +385,7 @@ static int fsck_obj_buffer(const struct object_id 
*oid, enum object_type type,
 	 * verify_packfile(), data_valid variable for details.
 	 */
 	struct object *obj;
-	obj = parse_object_buffer(oid-&gt;hash, type, size, buffer, eaten);
+	obj = parse_object_buffer(oid, type, size, buffer, eaten);
 	if (!obj) {
 		errors_found |= ERROR_OBJECT;
 		return error("%s: object corrupt or missing", oid_to_hex(oid));
@@ -444,7 +444,7 @@ static int fsck_handle_ref(const char *refname, 
const struct object_id *oid,
 {
 	struct object *obj;
 
-	obj = parse_object(oid-&gt;hash);
+	obj = parse_object(oid);
 	if (!obj) {
 		error("%s: invalid sha1 pointer %s", refname, oid_to_hex(oid));
 		errors_found |= ERROR_REACHABLE;
@@ -506,7 +506,7 @@ static struct object *parse_loose_object(const 
struct object_id *oid,
 	if (!contents &amp;&amp; type != OBJ_BLOB)
 		die("BUG: read_loose_object streamed a non-blob");
 
-	obj = parse_object_buffer(oid-&gt;hash, type, size, contents, 
&amp;eaten);
+	obj = parse_object_buffer(oid, type, size, contents, &amp;eaten);
 
 	if (!eaten)
 		free(contents);
@@ -599,7 +599,7 @@ static int fsck_cache_tree(struct cache_tree *it)
 		fprintf(stderr, "Checking cache tree\n");
 
 	if (0 &lt;= it-&gt;entry_count) {
-		struct object *obj = parse_object(it-&gt;oid.hash);
+		struct object *obj = parse_object(&amp;it-&gt;oid);
 		if (!obj) {
 			error("%s: invalid sha1 pointer in cache-tree",
 			      oid_to_hex(&amp;it-&gt;oid));
diff --git a/builtin/grep.c b/builtin/grep.c
index 3ffb5b4e8..e64e14e94 100644
--- a/builtin/grep.c
+++ b/builtin/grep.c
@@ -1196,7 +1196,7 @@ int cmd_grep(int argc, const char **argv, const 
char *prefix)
 			break;
 		}
 
-		object = parse_object_or_die(oid.hash, arg);
+		object = parse_object_or_die(&amp;oid, arg);
 		if (!seen_dashdash)
 			verify_non_filename(prefix, arg);
 		add_object_array_with_path(object, arg, &amp;list, oc.mode, oc.path);
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index b75133f62..04b9dcaf0 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -845,7 +845,8 @@ static void sha1_object(const void *data, struct 
object_entry *obj_entry,
 			 * we do not need to free the memory here, as the
 			 * buf is deleted by the caller.
 			 */
-			obj = parse_object_buffer(oid-&gt;hash, type, size, buf, 
&amp;eaten);
+			obj = parse_object_buffer(oid, type, size, buf,
+						  &amp;eaten);
 			if (!obj)
 				die(_("invalid %s"), typename(type));
 			if (do_fsck_object &amp;&amp;
diff --git a/builtin/log.c b/builtin/log.c
index d8b56ea41..8dd4e3dae 100644
--- a/builtin/log.c
+++ b/builtin/log.c
@@ -596,7 +596,7 @@ int cmd_show(int argc, const char **argv, const char
 *prefix)
 			rev.shown_one = 1;
 			if (ret)
 				break;
-			o = parse_object(t-&gt;tagged-&gt;oid.hash);
+			o = parse_object(&amp;t-&gt;tagged-&gt;oid);
 			if (!o)
 				ret = error(_("Could not read object %s"),
 					    oid_to_hex(&amp;t-&gt;tagged-&gt;oid));
diff --git a/builtin/name-rev.c b/builtin/name-rev.c
index 00760ecc6..f06261cad 100644
--- a/builtin/name-rev.c
+++ b/builtin/name-rev.c
@@ -142,7 +142,7 @@ static int tipcmp(const void *a_, const void *b_)
 
 static int name_ref(const char *path, const struct object_id *oid, int 
flags, void *cb_data)
 {
-	struct object *o = parse_object(oid-&gt;hash);
+	struct object *o = parse_object(oid);
 	struct name_ref_data *data = cb_data;
 	int can_abbreviate_output = data-&gt;tags_only &amp;&amp; 
data-&gt;name_only;
 	int deref = 0;
@@ -200,7 +200,7 @@ static int name_ref(const char *path, const struct 
object_id *oid, int flags, vo
 		struct tag *t = (struct tag *) o;
 		if (!t-&gt;tagged)
 			break; /* broken repository */
-		o = parse_object(t-&gt;tagged-&gt;oid.hash);
+		o = parse_object(&amp;t-&gt;tagged-&gt;oid);
 		deref = 1;
 		taggerdate = t-&gt;date;
 	}
@@ -385,7 +385,7 @@ int cmd_name_rev(int argc, const char **argv, const 
char *prefix)
 		}
 
 		commit = NULL;
-		object = parse_object(oid.hash);
+		object = parse_object(&amp;oid);
 		if (object) {
 			struct object *peeled = deref_tag(object, *argv, 0);
 			if (peeled &amp;&amp; peeled-&gt;type == OBJ_COMMIT)
diff --git a/builtin/prune.c b/builtin/prune.c
index 96dca7d58..536366056 100644
--- a/builtin/prune.c
+++ b/builtin/prune.c
@@ -127,7 +127,8 @@ int cmd_prune(int argc, const char **argv, const 
char *prefix)
 		const char *name = *argv++;
 
 		if (!get_oid(name, &amp;oid)) {
-			struct object *object = parse_object_or_die(oid.hash, name);
+			struct object *object = parse_object_or_die(&amp;oid,
+								    name);
 			add_pending_object(&amp;revs, object, "");
 		}
 		else
diff --git a/builtin/receive-pack.c b/builtin/receive-pack.c
index 6f0f788b0..36e0e29ea 100644
--- a/builtin/receive-pack.c
+++ b/builtin/receive-pack.c
@@ -1058,8 +1058,8 @@ static const char *update(struct command *cmd, 
struct shallow_info *si)
 		struct object *old_object, *new_object;
 		struct commit *old_commit, *new_commit;
 
-		old_object = parse_object(old_oid-&gt;hash);
-		new_object = parse_object(new_oid-&gt;hash);
+		old_object = parse_object(old_oid);
+		new_object = parse_object(new_oid);
 
 		if (!old_object || !new_object ||
 		    old_object-&gt;type != OBJ_COMMIT ||
@@ -1082,7 +1082,7 @@ static const char *update(struct command *cmd, 
struct shallow_info *si)
 
 	if (is_null_oid(new_oid)) {
 		struct strbuf err = STRBUF_INIT;
-		if (!parse_object(old_oid-&gt;hash)) {
+		if (!parse_object(old_oid)) {
 			old_oid = NULL;
 			if (ref_exists(name)) {
 				rp_warning("Allowing deletion of corrupt ref.");
diff --git a/builtin/reflog.c b/builtin/reflog.c
index 7e89e84dc..8f3f1bd99 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -126,7 +126,7 @@ static int commit_is_complete(struct commit *commit)
 		struct commit_list *parent;
 
 		c = (struct commit *)study.objects[--study.nr].item;
-		if (!c-&gt;object.parsed &amp;&amp; 
!parse_object(c-&gt;object.oid.hash))
+		if (!c-&gt;object.parsed &amp;&amp; 
!parse_object(&amp;c-&gt;object.oid))
 			c-&gt;object.flags |= INCOMPLETE;
 
 		if (c-&gt;object.flags &amp; INCOMPLETE) {
diff --git a/builtin/rev-list.c b/builtin/rev-list.c
index bcf77f0b8..1ddfca32b 100644
--- a/builtin/rev-list.c
+++ b/builtin/rev-list.c
@@ -181,7 +181,7 @@ static void finish_object(struct object *obj, const 
char *name, void *cb_data)
 	if (obj-&gt;type == OBJ_BLOB &amp;&amp; 
!has_object_file(&amp;obj-&gt;oid))
 		die("missing blob object '%s'", oid_to_hex(&amp;obj-&gt;oid));
 	if (info-&gt;revs-&gt;verify_objects &amp;&amp; !obj-&gt;parsed 
&amp;&amp; obj-&gt;type != OBJ_COMMIT)
-		parse_object(obj-&gt;oid.hash);
+		parse_object(&amp;obj-&gt;oid);
 }
 
 static void show_object(struct object *obj, const char *name, void 
*cb_data)
diff --git a/builtin/unpack-objects.c b/builtin/unpack-objects.c
index 7d5efa2b3..8bc999776 100644
--- a/builtin/unpack-objects.c
+++ b/builtin/unpack-objects.c
@@ -260,7 +260,8 @@ static void write_object(unsigned nr, enum 
object_type type,
 		int eaten;
 		hash_sha1_file(buf, size, typename(type), obj_list[nr].oid.hash);
 		added_object(nr, type, buf, size);
-		obj = parse_object_buffer(obj_list[nr].oid.hash, type, size, buf, 
&amp;eaten);
+		obj = parse_object_buffer(&amp;obj_list[nr].oid, type, size, buf,
+					  &amp;eaten);
 		if (!obj)
 			die("invalid %s", typename(type));
 		add_object_buffer(obj, buf, size);
diff --git a/bundle.c b/bundle.c
index 3386dba3b..f4abac467 100644
--- a/bundle.c
+++ b/bundle.c
@@ -142,7 +142,7 @@ int verify_bundle(struct bundle_header *header, int 
verbose)
 	init_revisions(&amp;revs, NULL);
 	for (i = 0; i &lt; p-&gt;nr; i++) {
 		struct ref_list_entry *e = p-&gt;list + i;
-		struct object *o = parse_object(e-&gt;oid.hash);
+		struct object *o = parse_object(&amp;e-&gt;oid);
 		if (o) {
 			o-&gt;flags |= PREREQ_MARK;
 			add_pending_object(&amp;revs, o, e-&gt;name);
@@ -290,12 +290,14 @@ static int compute_and_write_prerequisites(int 
bundle_fd,
 		if (buf.len &gt; 0 &amp;&amp; buf.buf[0] == '-') {
 			write_or_die(bundle_fd, buf.buf, buf.len);
 			if (!get_oid_hex(buf.buf + 1, &amp;oid)) {
-				struct object *object = parse_object_or_die(oid.hash, buf.buf);
+				struct object *object = parse_object_or_die(&amp;oid,
+									    buf.buf);
 				object-&gt;flags |= UNINTERESTING;
 				add_pending_object(revs, object, buf.buf);
 			}
 		} else if (!get_oid_hex(buf.buf, &amp;oid)) {
-			struct object *object = parse_object_or_die(oid.hash, buf.buf);
+			struct object *object = parse_object_or_die(&amp;oid,
+								    buf.buf);
 			object-&gt;flags |= SHOWN;
 		}
 	}
@@ -379,7 +381,7 @@ static int write_bundle_refs(int bundle_fd, struct 
rev_info *revs)
 				 * end up triggering "empty bundle"
 				 * error.
 				 */
-				obj = parse_object_or_die(oid.hash, e-&gt;name);
+				obj = parse_object_or_die(&amp;oid, e-&gt;name);
 				obj-&gt;flags |= SHOWN;
 				add_pending_object(revs, obj, e-&gt;name);
 			}
diff --git a/commit.c b/commit.c
index 8004008bc..424237a8e 100644
--- a/commit.c
+++ b/commit.c
@@ -21,7 +21,7 @@ const char *commit_type = "commit";
 struct commit *lookup_commit_reference_gently(const struct object_id 
*oid,
 					      int quiet)
 {
-	struct object *obj = deref_tag(parse_object(oid-&gt;hash), NULL, 0);
+	struct object *obj = deref_tag(parse_object(oid), NULL, 0);
 
 	if (!obj)
 		return NULL;
@@ -1589,7 +1589,7 @@ struct commit *get_merge_parent(const char *name)
 	struct object_id oid;
 	if (get_sha1(name, oid.hash))
 		return NULL;
-	obj = parse_object(oid.hash);
+	obj = parse_object(&amp;oid);
 	commit = (struct commit *)peel_to_type(name, 0, obj, OBJ_COMMIT);
 	if (commit &amp;&amp; !commit-&gt;util)
 		set_merge_remote_desc(commit, name, obj);
diff --git a/fetch-pack.c b/fetch-pack.c
index 7ec75f278..2880f5d6a 100644
--- a/fetch-pack.c
+++ b/fetch-pack.c
@@ -78,7 +78,7 @@ static void cache_one_alternate(const char *refname,
 				void *vcache)
 {
 	struct alternate_object_cache *cache = vcache;
-	struct object *obj = parse_object(oid-&gt;hash);
+	struct object *obj = parse_object(oid);
 
 	if (!obj || (obj-&gt;flags &amp; ALTERNATE))
 		return;
@@ -120,7 +120,7 @@ static void rev_list_push(struct commit *commit, int
 mark)
 
 static int rev_list_insert_ref(const char *refname, const struct 
object_id *oid)
 {
-	struct object *o = deref_tag(parse_object(oid-&gt;hash), refname, 0);
+	struct object *o = deref_tag(parse_object(oid), refname, 0);
 
 	if (o &amp;&amp; o-&gt;type == OBJ_COMMIT)
 		rev_list_push((struct commit *)o, SEEN);
@@ -137,7 +137,7 @@ static int rev_list_insert_ref_oid(const char 
*refname, const struct object_id *
 static int clear_marks(const char *refname, const struct object_id 
*oid,
 		       int flag, void *cb_data)
 {
-	struct object *o = deref_tag(parse_object(oid-&gt;hash), refname, 0);
+	struct object *o = deref_tag(parse_object(oid), refname, 0);
 
 	if (o &amp;&amp; o-&gt;type == OBJ_COMMIT)
 		clear_commit_marks((struct commit *)o,
@@ -426,7 +426,7 @@ static int find_common(struct fetch_pack_args *args,
 				if (!lookup_object(oid.hash))
 					die(_("object not found: %s"), line);
 				/* make sure that it is parsed as shallow */
-				if (!parse_object(oid.hash))
+				if (!parse_object(&amp;oid))
 					die(_("error in object: %s"), line);
 				if (unregister_shallow(&amp;oid))
 					die(_("no shallow found: %s"), line);
@@ -557,14 +557,14 @@ static struct commit_list *complete;
 
 static int mark_complete(const struct object_id *oid)
 {
-	struct object *o = parse_object(oid-&gt;hash);
+	struct object *o = parse_object(oid);
 
 	while (o &amp;&amp; o-&gt;type == OBJ_TAG) {
 		struct tag *t = (struct tag *) o;
 		if (!t-&gt;tagged)
 			break; /* broken repository */
 		o-&gt;flags |= COMPLETE;
-		o = parse_object(t-&gt;tagged-&gt;oid.hash);
+		o = parse_object(&amp;t-&gt;tagged-&gt;oid);
 	}
 	if (o &amp;&amp; o-&gt;type == OBJ_COMMIT) {
 		struct commit *commit = (struct commit *)o;
@@ -681,7 +681,7 @@ static int everything_local(struct fetch_pack_args 
*args,
 		if (!has_object_file(&amp;ref-&gt;old_oid))
 			continue;
 
-		o = parse_object(ref-&gt;old_oid.hash);
+		o = parse_object(&amp;ref-&gt;old_oid);
 		if (!o)
 			continue;
 
diff --git a/fsck.c b/fsck.c
index ee5224aea..90857e122 100644
--- a/fsck.c
+++ b/fsck.c
@@ -461,7 +461,7 @@ int fsck_walk(struct object *obj, void *data, struct
 fsck_options *options)
 		return -1;
 
 	if (obj-&gt;type == OBJ_NONE)
-		parse_object(obj-&gt;oid.hash);
+		parse_object(&amp;obj-&gt;oid);
 
 	switch (obj-&gt;type) {
 	case OBJ_BLOB:
diff --git a/http-backend.c b/http-backend.c
index eef0a361f..766381332 100644
--- a/http-backend.c
+++ b/http-backend.c
@@ -431,7 +431,7 @@ static int show_text_ref(const char *name, const 
struct object_id *oid,
 {
 	const char *name_nons = strip_namespace(name);
 	struct strbuf *buf = cb_data;
-	struct object *o = parse_object(oid-&gt;hash);
+	struct object *o = parse_object(oid);
 	if (!o)
 		return 0;
 
diff --git a/http-push.c b/http-push.c
index 4e7bd9e42..67c4d4b47 100644
--- a/http-push.c
+++ b/http-push.c
@@ -724,7 +724,7 @@ static void one_remote_object(const struct object_id
 *oid)
 
 	obj = lookup_object(oid-&gt;hash);
 	if (!obj)
-		obj = parse_object(oid-&gt;hash);
+		obj = parse_object(oid);
 
 	/* Ignore remote objects that don't exist locally */
 	if (!obj)
@@ -1462,7 +1462,7 @@ static void add_remote_info_ref(struct 
remote_ls_ctx *ls)
 		return;
 	}
 
-	o = parse_object(ref-&gt;old_oid.hash);
+	o = parse_object(&amp;ref-&gt;old_oid);
 	if (!o) {
 		fprintf(stderr,
 			"Unable to parse object %s for remote ref %s\n",
diff --git a/log-tree.c b/log-tree.c
index 6532c892c..a4ec11c2b 100644
--- a/log-tree.c
+++ b/log-tree.c
@@ -105,13 +105,13 @@ static int add_ref_decoration(const char *refname,
 const struct object_id *oid,
 			warning("invalid replace ref %s", refname);
 			return 0;
 		}
-		obj = parse_object(original_oid.hash);
+		obj = parse_object(&amp;original_oid);
 		if (obj)
 			add_name_decoration(DECORATION_GRAFTED, "replaced", obj);
 		return 0;
 	}
 
-	obj = parse_object(oid-&gt;hash);
+	obj = parse_object(oid);
 	if (!obj)
 		return 0;
 
@@ -132,7 +132,7 @@ static int add_ref_decoration(const char *refname, 
const struct object_id *oid,
 		if (!obj)
 			break;
 		if (!obj-&gt;parsed)
-			parse_object(obj-&gt;oid.hash);
+			parse_object(&amp;obj-&gt;oid);
 		add_name_decoration(DECORATION_REF_TAG, refname, obj);
 	}
 	return 0;
diff --git a/merge-recursive.c b/merge-recursive.c
index 92e0a63dc..ae5238d82 100644
--- a/merge-recursive.c
+++ b/merge-recursive.c
@@ -2103,7 +2103,7 @@ static struct commit *get_ref(const struct 
object_id *oid, const char *name)
 {
 	struct object *object;
 
-	object = deref_tag(parse_object(oid-&gt;hash), name, strlen(name));
+	object = deref_tag(parse_object(oid), name, strlen(name));
 	if (!object)
 		return NULL;
 	if (object-&gt;type == OBJ_TREE)
diff --git a/object.c b/object.c
index dd4d3a1ea..06ba3a11d 100644
--- a/object.c
+++ b/object.c
@@ -180,24 +180,21 @@ struct object *lookup_unknown_object(const 
unsigned char *sha1)
 	return obj;
 }
 
-struct object *parse_object_buffer(const unsigned char *sha1, enum 
object_type type, unsigned long size, void *buffer, int *eaten_p)
+struct object *parse_object_buffer(const struct object_id *oid, enum 
object_type type, unsigned long size, void *buffer, int *eaten_p)
 {
-	struct object_id oid;
 	struct object *obj;
 	*eaten_p = 0;
 
-	hashcpy(oid.hash, sha1);
-
 	obj = NULL;
 	if (type == OBJ_BLOB) {
-		struct blob *blob = lookup_blob(&amp;oid);
+		struct blob *blob = lookup_blob(oid);
 		if (blob) {
 			if (parse_blob_buffer(blob, buffer, size))
 				return NULL;
 			obj = &amp;blob-&gt;object;
 		}
 	} else if (type == OBJ_TREE) {
-		struct tree *tree = lookup_tree(&amp;oid);
+		struct tree *tree = lookup_tree(oid);
 		if (tree) {
 			obj = &amp;tree-&gt;object;
 			if (!tree-&gt;buffer)
@@ -209,7 +206,7 @@ struct object *parse_object_buffer(const unsigned 
char *sha1, enum object_type t
 			}
 		}
 	} else if (type == OBJ_COMMIT) {
-		struct commit *commit = lookup_commit(&amp;oid);
+		struct commit *commit = lookup_commit(oid);
 		if (commit) {
 			if (parse_commit_buffer(commit, buffer, size))
 				return NULL;
@@ -220,57 +217,54 @@ struct object *parse_object_buffer(const unsigned 
char *sha1, enum object_type t
 			obj = &amp;commit-&gt;object;
 		}
 	} else if (type == OBJ_TAG) {
-		struct tag *tag = lookup_tag(&amp;oid);
+		struct tag *tag = lookup_tag(oid);
 		if (tag) {
 			if (parse_tag_buffer(tag, buffer, size))
 			       return NULL;
 			obj = &amp;tag-&gt;object;
 		}
 	} else {
-		warning("object %s has unknown type id %d", sha1_to_hex(sha1), type);
+		warning("object %s has unknown type id %d", oid_to_hex(oid), type);
 		obj = NULL;
 	}
 	return obj;
 }
 
-struct object *parse_object_or_die(const unsigned char *sha1,
+struct object *parse_object_or_die(const struct object_id *oid,
 				   const char *name)
 {
-	struct object *o = parse_object(sha1);
+	struct object *o = parse_object(oid);
 	if (o)
 		return o;
 
-	die(_("unable to parse object: %s"), name ? name : sha1_to_hex(sha1));
+	die(_("unable to parse object: %s"), name ? name : oid_to_hex(oid));
 }
 
-struct object *parse_object(const unsigned char *sha1)
+struct object *parse_object(const struct object_id *oid)
 {
 	unsigned long size;
 	enum object_type type;
 	int eaten;
-	const unsigned char *repl = lookup_replace_object(sha1);
+	const unsigned char *repl = lookup_replace_object(oid-&gt;hash);
 	void *buffer;
 	struct object *obj;
-	struct object_id oid;
 
-	hashcpy(oid.hash, sha1);
-
-	obj = lookup_object(oid.hash);
+	obj = lookup_object(oid-&gt;hash);
 	if (obj &amp;&amp; obj-&gt;parsed)
 		return obj;
 
 	if ((obj &amp;&amp; obj-&gt;type == OBJ_BLOB) ||
-	    (!obj &amp;&amp; has_sha1_file(sha1) &amp;&amp;
-	     sha1_object_info(sha1, NULL) == OBJ_BLOB)) {
+	    (!obj &amp;&amp; has_object_file(oid) &amp;&amp;
+	     sha1_object_info(oid-&gt;hash, NULL) == OBJ_BLOB)) {
 		if (check_sha1_signature(repl, NULL, 0, NULL) &lt; 0) {
-			error("sha1 mismatch %s", sha1_to_hex(repl));
+			error("sha1 mismatch %s", oid_to_hex(oid));
 			return NULL;
 		}
-		parse_blob_buffer(lookup_blob(&amp;oid), NULL, 0);
-		return lookup_object(sha1);
+		parse_blob_buffer(lookup_blob(oid), NULL, 0);
+		return lookup_object(oid-&gt;hash);
 	}
 
-	buffer = read_sha1_file(sha1, &amp;type, &amp;size);
+	buffer = read_sha1_file(oid-&gt;hash, &amp;type, &amp;size);
 	if (buffer) {
 		if (check_sha1_signature(repl, buffer, size, typename(type)) &lt; 0) {
 			free(buffer);
@@ -278,7 +272,7 @@ struct object *parse_object(const unsigned char 
*sha1)
 			return NULL;
 		}
 
-		obj = parse_object_buffer(sha1, type, size, buffer, &amp;eaten);
+		obj = parse_object_buffer(oid, type, size, buffer, &amp;eaten);
 		if (!eaten)
 			free(buffer);
 		return obj;
diff --git a/object.h b/object.h
index f52957dcb..33e5cc994 100644
--- a/object.h
+++ b/object.h
@@ -89,20 +89,20 @@ void *object_as_type(struct object *obj, enum 
object_type type, int quiet);
  *
  * Returns NULL if the object is missing or corrupt.
  */
-struct object *parse_object(const unsigned char *sha1);
+struct object *parse_object(const struct object_id *oid);
 
 /*
  * Like parse_object, but will die() instead of returning NULL. If the
  * "name" parameter is not NULL, it is included in the error message
- * (otherwise, the sha1 hex is given).
+ * (otherwise, the hex object ID is given).
  */
-struct object *parse_object_or_die(const unsigned char *sha1, const 
char *name);
+struct object *parse_object_or_die(const struct object_id *oid, const 
char *name);
 
 /* Given the result of read_sha1_file(), returns the object after
  * parsing it.  eaten_p indicates if the object has a borrowed copy
  * of buffer and the caller should not free() it.
  */
-struct object *parse_object_buffer(const unsigned char *sha1, enum 
object_type type, unsigned long size, void *buffer, int *eaten_p);
+struct object *parse_object_buffer(const struct object_id *oid, enum 
object_type type, unsigned long size, void *buffer, int *eaten_p);
 
 /** Returns the object, with potentially excess memory allocated. **/
 struct object *lookup_unknown_object(const unsigned  char *sha1);
diff --git a/pack-bitmap.c b/pack-bitmap.c
index 39bcc1684..a3ac3dccd 100644
--- a/pack-bitmap.c
+++ b/pack-bitmap.c
@@ -673,7 +673,7 @@ int prepare_bitmap_walk(struct rev_info *revs)
 		struct object *object = pending_e[i].item;
 
 		if (object-&gt;type == OBJ_NONE)
-			parse_object_or_die(object-&gt;oid.hash, NULL);
+			parse_object_or_die(&amp;object-&gt;oid, NULL);
 
 		while (object-&gt;type == OBJ_TAG) {
 			struct tag *tag = (struct tag *) object;
@@ -685,7 +685,7 @@ int prepare_bitmap_walk(struct rev_info *revs)
 
 			if (!tag-&gt;tagged)
 				die("bad tag");
-			object = parse_object_or_die(tag-&gt;tagged-&gt;oid.hash, NULL);
+			object = parse_object_or_die(&amp;tag-&gt;tagged-&gt;oid, NULL);
 		}
 
 		if (object-&gt;flags &amp; UNINTERESTING)
diff --git a/pretty.c b/pretty.c
index d0f86f5d8..c4a0ace34 100644
--- a/pretty.c
+++ b/pretty.c
@@ -1137,7 +1137,7 @@ static size_t format_commit_one(struct strbuf *sb,
 /* in UTF-8 */
 
 	/* these depend on the commit */
 	if (!commit-&gt;object.parsed)
-		parse_object(commit-&gt;object.oid.hash);
+		parse_object(&amp;commit-&gt;object.oid);
 
 	switch (placeholder[0]) {
 	case 'H':		/* commit hash */
diff --git a/reachable.c b/reachable.c
index 3bbc84417..69ca176f6 100644
--- a/reachable.c
+++ b/reachable.c
@@ -33,7 +33,7 @@ static int add_one_ref(const char *path, const struct 
object_id *oid,
 		return 0;
 	}
 
-	object = parse_object_or_die(oid-&gt;hash, path);
+	object = parse_object_or_die(oid, path);
 	add_pending_object(revs, object, "");
 
 	return 0;
@@ -82,7 +82,7 @@ static void add_recent_object(const struct object_id 
*oid,
 	switch (type) {
 	case OBJ_TAG:
 	case OBJ_COMMIT:
-		obj = parse_object_or_die(oid-&gt;hash, NULL);
+		obj = parse_object_or_die(oid, NULL);
 		break;
 	case OBJ_TREE:
 		obj = (struct object *)lookup_tree(oid);
diff --git a/ref-filter.c b/ref-filter.c
index 56fc990a5..3f7cf71b5 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -683,7 +683,7 @@ static void *get_obj(const struct object_id *oid, 
struct object **obj, unsigned
 	void *buf = read_sha1_file(oid-&gt;hash, &amp;type, sz);
 
 	if (buf)
-		*obj = parse_object_buffer(oid-&gt;hash, type, *sz, buf, eaten);
+		*obj = parse_object_buffer(oid, type, *sz, buf, eaten);
 	else
 		*obj = NULL;
 	return buf;
@@ -1687,7 +1687,7 @@ static const struct object_id 
*match_points_at(struct oid_array *points_at,
 
 	if (oid_array_lookup(points_at, oid) &gt;= 0)
 		return oid;
-	obj = parse_object(oid-&gt;hash);
+	obj = parse_object(oid);
 	if (!obj)
 		die(_("malformed object at '%s'"), refname);
 	if (obj-&gt;type == OBJ_TAG)
diff --git a/reflog-walk.c b/reflog-walk.c
index c8fdf051d..110e18f1f 100644
--- a/reflog-walk.c
+++ b/reflog-walk.c
@@ -238,13 +238,13 @@ void fake_reflog_parent(struct reflog_walk_info 
*info, struct commit *commit)
 	do {
 		reflog = 
&amp;commit_reflog-&gt;reflogs-&gt;items[commit_reflog-&gt;recno];
 		commit_reflog-&gt;recno--;
-		logobj = parse_object(reflog-&gt;ooid.hash);
+		logobj = parse_object(&amp;reflog-&gt;ooid);
 	} while (commit_reflog-&gt;recno &amp;&amp; (logobj &amp;&amp; 
logobj-&gt;type != OBJ_COMMIT));
 
 	if (!logobj &amp;&amp; commit_reflog-&gt;recno &gt;= 0 &amp;&amp; 
is_null_oid(&amp;reflog-&gt;ooid)) {
 		/* a root commit, but there are still more entries to show */
 		reflog = 
&amp;commit_reflog-&gt;reflogs-&gt;items[commit_reflog-&gt;recno];
-		logobj = parse_object(reflog-&gt;noid.hash);
+		logobj = parse_object(&amp;reflog-&gt;noid);
 	}
 
 	if (!logobj || logobj-&gt;type != OBJ_COMMIT) {
diff --git a/refs/files-backend.c b/refs/files-backend.c
index 12be6746b..42cfcf585 100644
--- a/refs/files-backend.c
+++ b/refs/files-backend.c
@@ -2060,7 +2060,7 @@ static int write_ref_to_lockfile(struct ref_lock 
*lock,
 	struct object *o;
 	int fd;
 
-	o = parse_object(oid-&gt;hash);
+	o = parse_object(oid);
 	if (!o) {
 		strbuf_addf(err,
 			    "trying to write ref '%s' with nonexistent object %s",
diff --git a/remote.c b/remote.c
index bf9a47d95..38ca1353b 100644
--- a/remote.c
+++ b/remote.c
@@ -1954,12 +1954,12 @@ int ref_newer(const struct object_id *new_oid, 
const struct object_id *old_oid)
 	 * Both new and old must be commit-ish and new is descendant of
 	 * old.  Otherwise we require --force.
 	 */
-	o = deref_tag(parse_object(old_oid-&gt;hash), NULL, 0);
+	o = deref_tag(parse_object(old_oid), NULL, 0);
 	if (!o || o-&gt;type != OBJ_COMMIT)
 		return 0;
 	old = (struct commit *) o;
 
-	o = deref_tag(parse_object(new_oid-&gt;hash), NULL, 0);
+	o = deref_tag(parse_object(new_oid), NULL, 0);
 	if (!o || o-&gt;type != OBJ_COMMIT)
 		return 0;
 	new = (struct commit *) o;
diff --git a/revision.c b/revision.c
index 80f74bb7b..64e67e017 100644
--- a/revision.c
+++ b/revision.c
@@ -181,7 +181,7 @@ void add_head_to_pending(struct rev_info *revs)
 	struct object *obj;
 	if (get_oid("HEAD", &amp;oid))
 		return;
-	obj = parse_object(oid.hash);
+	obj = parse_object(&amp;oid);
 	if (!obj)
 		return;
 	add_pending_object(revs, obj, "HEAD");
@@ -193,7 +193,7 @@ static struct object *get_reference(struct rev_info 
*revs, const char *name,
 {
 	struct object *object;
 
-	object = parse_object(oid-&gt;hash);
+	object = parse_object(oid);
 	if (!object) {
 		if (revs-&gt;ignore_missing)
 			return object;
@@ -228,7 +228,7 @@ static struct commit *handle_commit(struct rev_info 
*revs,
 			add_pending_object(revs, object, tag-&gt;tag);
 		if (!tag-&gt;tagged)
 			die("bad tag");
-		object = parse_object(tag-&gt;tagged-&gt;oid.hash);
+		object = parse_object(&amp;tag-&gt;tagged-&gt;oid);
 		if (!object) {
 			if (flags &amp; UNINTERESTING)
 				return NULL;
@@ -1200,7 +1200,7 @@ static void handle_one_reflog_commit(struct 
object_id *oid, void *cb_data)
 {
 	struct all_refs_cb *cb = cb_data;
 	if (!is_null_oid(oid)) {
-		struct object *o = parse_object(oid-&gt;hash);
+		struct object *o = parse_object(oid);
 		if (o) {
 			o-&gt;flags |= cb-&gt;all_flags;
 			/* ??? CMDLINEFLAGS ??? */
@@ -1479,8 +1479,8 @@ int handle_revision_arg(const char *arg_, struct 
rev_info *revs, int flags, unsi
 				verify_non_filename(revs-&gt;prefix, arg);
 			}
 
-			a_obj = parse_object(from_oid.hash);
-			b_obj = parse_object(oid.hash);
+			a_obj = parse_object(&amp;from_oid);
+			b_obj = parse_object(&amp;oid);
 			if (!a_obj || !b_obj) {
 			missing:
 				if (revs-&gt;ignore_missing)
diff --git a/server-info.c b/server-info.c
index f6c1a3dfb..6f865b73a 100644
--- a/server-info.c
+++ b/server-info.c
@@ -53,7 +53,7 @@ static int add_info_ref(const char *path, const struct
 object_id *oid,
 			int flag, void *cb_data)
 {
 	FILE *fp = cb_data;
-	struct object *o = parse_object(oid-&gt;hash);
+	struct object *o = parse_object(oid);
 	if (!o)
 		return -1;
 
diff --git a/sha1_name.c b/sha1_name.c
index 72e72ab9a..de8278530 100644
--- a/sha1_name.c
+++ b/sha1_name.c
@@ -241,7 +241,7 @@ static int disambiguate_committish_only(const struct
 object_id *oid, void *cb_da
 		return 0;
 
 	/* We need to do this the hard way... */
-	obj = deref_tag(parse_object(oid-&gt;hash), NULL, 0);
+	obj = deref_tag(parse_object(oid), NULL, 0);
 	if (obj &amp;&amp; obj-&gt;type == OBJ_COMMIT)
 		return 1;
 	return 0;
@@ -265,7 +265,7 @@ static int disambiguate_treeish_only(const struct 
object_id *oid, void *cb_data_
 		return 0;
 
 	/* We need to do this the hard way... */
-	obj = deref_tag(parse_object(oid-&gt;hash), NULL, 0);
+	obj = deref_tag(parse_object(oid), NULL, 0);
 	if (obj &amp;&amp; (obj-&gt;type == OBJ_TREE || obj-&gt;type == 
OBJ_COMMIT))
 		return 1;
 	return 0;
@@ -776,7 +776,7 @@ struct object *peel_to_type(const char *name, int 
namelen,
 	if (name &amp;&amp; !namelen)
 		namelen = strlen(name);
 	while (1) {
-		if (!o || (!o-&gt;parsed &amp;&amp; !parse_object(o-&gt;oid.hash)))
+		if (!o || (!o-&gt;parsed &amp;&amp; !parse_object(&amp;o-&gt;oid)))
 			return NULL;
 		if (expected_type == OBJ_ANY || o-&gt;type == expected_type)
 			return o;
@@ -849,12 +849,12 @@ static int peel_onion(const char *name, int len, 
unsigned char *sha1,
 	if (get_sha1_1(name, sp - name - 2, outer.hash, lookup_flags))
 		return -1;
 
-	o = parse_object(outer.hash);
+	o = parse_object(&amp;outer);
 	if (!o)
 		return -1;
 	if (!expected_type) {
 		o = deref_tag(o, name, sp - name - 2);
-		if (!o || (!o-&gt;parsed &amp;&amp; !parse_object(o-&gt;oid.hash)))
+		if (!o || (!o-&gt;parsed &amp;&amp; !parse_object(&amp;o-&gt;oid)))
 			return -1;
 		hashcpy(sha1, o-&gt;oid.hash);
 		return 0;
@@ -981,7 +981,7 @@ static int handle_one_ref(const char *path, const 
struct object_id *oid,
 			  int flag, void *cb_data)
 {
 	struct commit_list **list = cb_data;
-	struct object *object = parse_object(oid-&gt;hash);
+	struct object *object = parse_object(oid);
 	if (!object)
 		return 0;
 	if (object-&gt;type == OBJ_TAG) {
@@ -1027,7 +1027,7 @@ static int get_sha1_oneline(const char *prefix, 
unsigned char *sha1,
 		int matches;
 
 		commit = pop_most_recent_commit(&amp;list, ONELINE_SEEN);
-		if (!parse_object(commit-&gt;object.oid.hash))
+		if (!parse_object(&amp;commit-&gt;object.oid))
 			continue;
 		buf = get_commit_buffer(commit, NULL);
 		p = strstr(buf, "\n\n");
diff --git a/tag.c b/tag.c
index 571798519..eb7b146f4 100644
--- a/tag.c
+++ b/tag.c
@@ -66,7 +66,7 @@ struct object *deref_tag(struct object *o, const char 
*warn, int warnlen)
 {
 	while (o &amp;&amp; o-&gt;type == OBJ_TAG)
 		if (((struct tag *)o)-&gt;tagged)
-			o = parse_object(((struct tag *)o)-&gt;tagged-&gt;oid.hash);
+			o = parse_object(&amp;((struct tag *)o)-&gt;tagged-&gt;oid);
 		else
 			o = NULL;
 	if (!o &amp;&amp; warn) {
@@ -80,7 +80,7 @@ struct object *deref_tag(struct object *o, const char 
*warn, int warnlen)
 struct object *deref_tag_noverify(struct object *o)
 {
 	while (o &amp;&amp; o-&gt;type == OBJ_TAG) {
-		o = parse_object(o-&gt;oid.hash);
+		o = parse_object(&amp;o-&gt;oid);
 		if (o &amp;&amp; o-&gt;type == OBJ_TAG &amp;&amp; ((struct tag 
*)o)-&gt;tagged)
 			o = ((struct tag *)o)-&gt;tagged;
 		else
diff --git a/tree.c b/tree.c
index 9adcd8bd4..603b29ee8 100644
--- a/tree.c
+++ b/tree.c
@@ -234,7 +234,7 @@ void free_tree_buffer(struct tree *tree)
 
 struct tree *parse_tree_indirect(const struct object_id *oid)
 {
-	struct object *obj = parse_object(oid-&gt;hash);
+	struct object *obj = parse_object(oid);
 	do {
 		if (!obj)
 			return NULL;
@@ -247,6 +247,6 @@ struct tree *parse_tree_indirect(const struct 
object_id *oid)
 		else
 			return NULL;
 		if (!obj-&gt;parsed)
-			parse_object(obj-&gt;oid.hash);
+			parse_object(&amp;obj-&gt;oid);
 	} while (1);
 }
diff --git a/upload-pack.c b/upload-pack.c
index 5b9d21089..8619ec435 100644
--- a/upload-pack.c
+++ b/upload-pack.c
@@ -296,7 +296,7 @@ static int got_oid(const char *hex, struct object_id
 *oid)
 	if (!has_object_file(oid))
 		return -1;
 
-	o = parse_object(oid-&gt;hash);
+	o = parse_object(oid);
 	if (!o)
 		die("oops (%s)", oid_to_hex(oid));
 	if (o-&gt;type == OBJ_COMMIT) {
@@ -334,7 +334,7 @@ static int reachable(struct commit *want)
 			break;
 		}
 		if (!commit-&gt;object.parsed)
-			parse_object(commit-&gt;object.oid.hash);
+			parse_object(&amp;commit-&gt;object.oid);
 		if (commit-&gt;object.flags &amp; REACHABLE)
 			continue;
 		commit-&gt;object.flags |= REACHABLE;
@@ -755,7 +755,7 @@ static void receive_needs(void)
 			struct object *object;
 			if (get_oid_hex(arg, &amp;oid))
 				die("invalid shallow line: %s", line);
-			object = parse_object(oid.hash);
+			object = parse_object(&amp;oid);
 			if (!object)
 				continue;
 			if (object-&gt;type != OBJ_COMMIT)
@@ -821,7 +821,7 @@ static void receive_needs(void)
 		if (parse_feature_request(features, "include-tag"))
 			use_include_tag = 1;
 
-		o = parse_object(oid_buf.hash);
+		o = parse_object(&amp;oid_buf);
 		if (!o) {
 			packet_write_fmt(1,
 					 "ERR upload-pack: not our ref %s",
diff --git a/walker.c b/walker.c
index eae9fb974..274f1a493 100644
--- a/walker.c
+++ b/walker.c
@@ -180,7 +180,7 @@ static int loop(struct walker *walker)
 			}
 		}
 		if (!obj-&gt;type)
-			parse_object(obj-&gt;oid.hash);
+			parse_object(&amp;obj-&gt;oid);
 		if (process_object(walker, obj))
 			return -1;
 	}

<a href="#ma058b65b564ab02c1f795f048dc3a609f2c7550c" id="ea058b65b564ab02c1f795f048dc3a609f2c7550c">^</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/">permalink</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/raw">raw</a> <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/#R">reply</a>	[<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/T/#u"><b>flat</b></a>|<a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-54-sandals@crustytoothpaste.net/t/#u">threaded</a>] <a href="#ra058b65b564ab02c1f795f048dc3a609f2c7550c">52+ messages in thread</a></pre><hr><pre>end of thread, back to <a href="http://hjrcffqmbrq6wope.onion/git/">index</a>

<b id="t">Thread overview:</b> 52+ messages (download: <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/t.mbox.gz">mbox.gz</a> / follow: <a href="http://hjrcffqmbrq6wope.onion/git/20170501022946.258735-43-sandals@crustytoothpaste.net/t.atom">Atom feed</a>)
-- links below jump to the message on this page --
2017-05-01  2:28 <a href="#md30e3cf6335ffd783b9c23ba587ff7a405153480" id="rd30e3cf6335ffd783b9c23ba587ff7a405153480">[PATCH v2 00/53] object_id part 8</a> brian m. carlson
2017-05-01  2:28 ` <a href="#m2dca3826d10f379ac5b197846b5d57e93318cfa1" id="r2dca3826d10f379ac5b197846b5d57e93318cfa1">[PATCH v2 03/53] Convert struct cache_tree to use struct object_id</a> brian m. carlson
2017-05-01  2:28 ` <a href="#m1c64f91280af1ea8ed7b70c97a7609da8cd48da1" id="r1c64f91280af1ea8ed7b70c97a7609da8cd48da1">[PATCH v2 04/53] builtin/name-rev: convert to struct object_id</a> brian m. carlson
2017-05-01  2:28 ` <a href="#mc36a40b25b4c0081342f0b7715549e0aa08f046e" id="rc36a40b25b4c0081342f0b7715549e0aa08f046e">[PATCH v2 05/53] builtin/prune: convert to struct object_id</a> brian m. carlson
2017-05-01  2:28 ` <a href="#m502cedc8f4fe38d0aea50d12e0589b397f603796" id="r502cedc8f4fe38d0aea50d12e0589b397f603796">[PATCH v2 06/53] bundle: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m3e82d921d5e2b5c8a78bda08a60f6dde46fcb095" id="r3e82d921d5e2b5c8a78bda08a60f6dde46fcb095">[PATCH v2 07/53] branch: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mac7d1623a7bafeff0fe577e1266a73b89fc6a9e3" id="rac7d1623a7bafeff0fe577e1266a73b89fc6a9e3">[PATCH v2 08/53] builtin/blame: convert static function to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m898ba4f5509a44046f947c1b10520fec35bd0023" id="r898ba4f5509a44046f947c1b10520fec35bd0023">[PATCH v2 09/53] builtin/rev-parse: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f" id="rc0f911ba90d4e5d4f89b5f60bf4a2890e6482b5f">[PATCH v2 10/53] fast-import: convert internal structs to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8814834573a2c203c0ac5b61e7511c9cf7f29af8" id="r8814834573a2c203c0ac5b61e7511c9cf7f29af8">[PATCH v2 11/53] fast-import: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mc36780c4224c14bded80f8b7f2e7614a7bfa3126" id="rc36780c4224c14bded80f8b7f2e7614a7bfa3126">[PATCH v2 12/53] submodule: convert merge_submodule to use struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mbc9f9e942bda81c08789042dcdcf43d807835ed4" id="rbc9f9e942bda81c08789042dcdcf43d807835ed4">[PATCH v2 13/53] notes-cache: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mc900c2480b9789e818c71dfe5d656d72a12ff11f" id="rc900c2480b9789e818c71dfe5d656d72a12ff11f">[PATCH v2 14/53] parse-options-cb: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mf1e5b31660971729ded825ec86b0049d0fc75b6b" id="rf1e5b31660971729ded825ec86b0049d0fc75b6b">[PATCH v2 15/53] reflog_expire: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m9c9208a9abcd097978a370d97042d904a47dc0d9" id="r9c9208a9abcd097978a370d97042d904a47dc0d9">[PATCH v2 16/53] builtin/verify-commit: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8c869cf6099f85b733a5fd4e03a4c6cfd384c80f" id="r8c869cf6099f85b733a5fd4e03a4c6cfd384c80f">[PATCH v2 17/53] tag: convert parse_tag_buffer to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mef1151106d4c86a080bd2d3e9b34d2967d6cc7ef" id="ref1151106d4c86a080bd2d3e9b34d2967d6cc7ef">[PATCH v2 18/53] http-push: convert some static functions to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mc2e019a6a423c74691c07980be20b395f185a1c0" id="rc2e019a6a423c74691c07980be20b395f185a1c0">[PATCH v2 19/53] notes-utils: convert internals to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8f91994e5bedfddc142fed1122e6854d6855af5a" id="r8f91994e5bedfddc142fed1122e6854d6855af5a">[PATCH v2 20/53] revision: convert prepare_show_merge to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3" id="r2b876f1f7ccdf66cfc45f3cbba230dc899f71eb3">[PATCH v2 21/53] shallow: convert shallow registration functions to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m646b705faf5339ed8feb874743febcb15228488f" id="r646b705faf5339ed8feb874743febcb15228488f">[PATCH v2 22/53] sequencer: convert some functions to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m7aa9bb0875f3aefd5a7b992675a7c718f653ea61" id="r7aa9bb0875f3aefd5a7b992675a7c718f653ea61">[PATCH v2 23/53] builtin/tag: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mfbb146bb18b5cbedc5e48356e1458a77bba0af11" id="rfbb146bb18b5cbedc5e48356e1458a77bba0af11">[PATCH v2 24/53] Convert remaining callers of lookup_commit_reference* to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952" id="r2d3eb568afb8ec7c0b17cc0818c9c5a2fd5c4952">[PATCH v2 25/53] Convert lookup_commit* to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m891b1840f7953004bf78a2705362287ba2ff8e22" id="r891b1840f7953004bf78a2705362287ba2ff8e22">[PATCH v2 26/53] pack: convert struct pack_idx_entry to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m76defffb3dd7d6d7027beed4ec6a0db95d866870" id="r76defffb3dd7d6d7027beed4ec6a0db95d866870">[PATCH v2 27/53] builtin/unpack-objects: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m020525f5d6be19bd2171fce4b1d77e84be12feeb" id="r020525f5d6be19bd2171fce4b1d77e84be12feeb">[PATCH v2 28/53] Convert remaining callers of lookup_blob to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mca131828dd17e3bb6c6e9f11f6425cff1f7ad27f" id="rca131828dd17e3bb6c6e9f11f6425cff1f7ad27f">[PATCH v2 29/53] Convert lookup_blob to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m1189201e1cbe8ea272665337fabb2d3ed65ea3fb" id="r1189201e1cbe8ea272665337fabb2d3ed65ea3fb">[PATCH v2 30/53] tree: convert read_tree_1 to use struct object_id internally</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m6401726cb6374424ac36da9790da16ca18fbe4e5" id="r6401726cb6374424ac36da9790da16ca18fbe4e5">[PATCH v2 31/53] builtin/reflog: convert tree_is_complete to take struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m391adf34d36b0e6a3310cd9b07c12a79f53c1457" id="r391adf34d36b0e6a3310cd9b07c12a79f53c1457">[PATCH v2 32/53] Convert lookup_tree to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m663203f9dd55b3399d534345634dea0738de99f6" id="r663203f9dd55b3399d534345634dea0738de99f6">[PATCH v2 33/53] log-tree: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8cd4976cf14f674146e9ed8cea81aa8aee2ec554" id="r8cd4976cf14f674146e9ed8cea81aa8aee2ec554">[PATCH v2 34/53] Convert lookup_tag to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m43ca35cb6d4cf1c251a29a4a0b10009f639c8014" id="r43ca35cb6d4cf1c251a29a4a0b10009f639c8014">[PATCH v2 35/53] Convert the verify_pack callback to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m02ced868770a7c67f5b7e1d7a054601f4af81473" id="r02ced868770a7c67f5b7e1d7a054601f4af81473">[PATCH v2 36/53] Convert struct ref_array_item to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m60a7de9b41905363acb0fbd42eacb298bb47af26" id="r60a7de9b41905363acb0fbd42eacb298bb47af26">[PATCH v2 37/53] ref-filter: convert some static functions to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8220cedc15796315efb7be2c60c4f981a89e6864" id="r8220cedc15796315efb7be2c60c4f981a89e6864">[PATCH v2 38/53] refs: convert struct ref_update to use struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mbbc5a0892326a643bb95010e8b8a11dda2f843c2" id="rbbc5a0892326a643bb95010e8b8a11dda2f843c2">[PATCH v2 39/53] refs/files-backend: convert many internals to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mf83d6ab2107273110534406eb521db25eb0acd77" id="rf83d6ab2107273110534406eb521db25eb0acd77">[PATCH v2 40/53] http-push: convert process_ls_object and descendants to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mb570f4354485c39e3a0e560626571a95a25a990d" id="rb570f4354485c39e3a0e560626571a95a25a990d">[PATCH v2 41/53] revision: rename add_pending_sha1 to add_pending_oid</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mc41d3211081d0964c919f84e4c00eb4de1a7f6df" id="rc41d3211081d0964c919f84e4c00eb4de1a7f6df">[PATCH v2 42/53] revision: convert remaining parse_object callers to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mfd9765dc878f10a7eeba0bf1f73efa2196eba891" id="rfd9765dc878f10a7eeba0bf1f73efa2196eba891">[PATCH v2 43/53] upload-pack: convert remaining parse_object callers to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8f380b1897acf9bc1c19d0649c73dde9577ecde7" id="r8f380b1897acf9bc1c19d0649c73dde9577ecde7">[PATCH v2 44/53] sha1_name: convert internals of peel_onion to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m49aa033377306c7b5ae145b505e04d295b9b6b6b" id="r49aa033377306c7b5ae145b505e04d295b9b6b6b">[PATCH v2 45/53] builtin/read-tree: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m607f6a4b8c19f208b4d6b35c4d60b657c3854b72" id="r607f6a4b8c19f208b4d6b35c4d60b657c3854b72">[PATCH v2 46/53] builtin/ls-files: convert overlay_tree_on_cache to object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m3eb79c7ed25fdce8306c3099f05061c62668af70" id="r3eb79c7ed25fdce8306c3099f05061c62668af70">[PATCH v2 47/53] sequencer: convert fast_forward_to to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#md23aa796bd1b61ecfdb7f836846e649518747c74" id="rd23aa796bd1b61ecfdb7f836846e649518747c74">[PATCH v2 48/53] merge: convert checkout_fast_forward to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#ma4e1b00422265eee46e4ad4d21251b063cfb20d8" id="ra4e1b00422265eee46e4ad4d21251b063cfb20d8">[PATCH v2 49/53] builtin/ls-tree: convert to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#mf1693ad7f67b2fe233754b9eadcab84aadf89028" id="rf1693ad7f67b2fe233754b9eadcab84aadf89028">[PATCH v2 50/53] diff-lib: convert do_diff_cache to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m983604041bbfadedd072bd3e5c477354fa062e73" id="r983604041bbfadedd072bd3e5c477354fa062e73">[PATCH v2 51/53] sequencer: convert do_recursive_merge to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#m8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7" id="r8d8a334d779f8d15cc34d33bf6b40fe9e5980ca7">[PATCH v2 52/53] tree: convert parse_tree_indirect to struct object_id</a> brian m. carlson
2017-05-01  2:29 ` <a href="#ma058b65b564ab02c1f795f048dc3a609f2c7550c" id="ra058b65b564ab02c1f795f048dc3a609f2c7550c">[PATCH v2 53/53] object: convert parse_object* to take struct object_id</a> brian m. carlson
</pre><hr><pre>git@vger.kernel.org mailing list mirror (one of many)

Archives are clonable:
	git clone --mirror http://hjrcffqmbrq6wope.onion/git
	git clone --mirror <a href="http://czquwvybam4bgbro.onion/git">http://czquwvybam4bgbro.onion/git</a>
	git clone --mirror <a href="http://ou63pmih66umazou.onion/git">http://ou63pmih66umazou.onion/git</a>

Newsgroups are available over NNTP:
	<a href="nntp://hjrcffqmbrq6wope.onion/inbox.comp.version-control.git">nntp://hjrcffqmbrq6wope.onion/inbox.comp.version-control.git</a>
	<a href="nntp://czquwvybam4bgbro.onion/inbox.comp.version-control.git">nntp://czquwvybam4bgbro.onion/inbox.comp.version-control.git</a>
	<a href="nntp://ou63pmih66umazou.onion/inbox.comp.version-control.git">nntp://ou63pmih66umazou.onion/inbox.comp.version-control.git</a>
	<a href="nntp://news.public-inbox.org/inbox.comp.version-control.git">nntp://news.public-inbox.org/inbox.comp.version-control.git</a>
	<a href="nntp://news.gmane.org/gmane.comp.version-control.git">nntp://news.gmane.org/gmane.comp.version-control.git</a>

 note: .onion URLs require Tor: <a href="https://www.torproject.org/">https://www.torproject.org/</a>
       or Tor2web: <a href="https://www.tor2web.org/">https://www.tor2web.org/</a>

AGPL code for this site: git clone <a href="https://public-inbox.org/">https://public-inbox.org/</a> public-inbox</pre></body></html>
